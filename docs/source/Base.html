<!DOCTYPE html><html><head><title>Sencha Documentation Project</title><link rel="stylesheet" href="../reset.css" type="text/css"><link rel="stylesheet" href="../prettify.css" type="text/css"><link rel="stylesheet" href="../prettify_sa.css" type="text/css"><script type="text/javascript" src="../prettify.js"></script></head><body onload="prettyPrint()"><pre class="prettyprint"><pre><a name="cls-Ext.Base"></a>/**
 * @author Jacky Nguyen &lt;jacky@sencha.com&gt;
 * @docauthor Jacky Nguyen &lt;jacky@sencha.com&gt;
 * @class Ext.Base
 *
 * The root of all classes created with {@link Ext#define}
 * All prototype and static members of this class are inherited by any other class
 *
 */
(function(flexSetter) {

var Base = Ext.Base = function() {};
    Base.prototype = {
        $className: &#39;Ext.Base&#39;,

        $class: Base,

        <a name="prop-Ext.Base-self"></a>/**
         * Get the reference to the current class from which this object was instantiated. Unlike {@link Ext.Base#statics},
         * `this.self` is scope-dependent and it&#39;s meant to be used for dynamic inheritance. See {@link Ext.Base#statics}
         * for a detailed comparison

    Ext.define(&#39;My.Cat&#39;, {
        statics: {
            speciesName: &#39;Cat&#39; // My.Cat.speciesName = &#39;Cat&#39;
        },

        constructor: function() {
            alert(this.self.speciesName); / dependent on &#39;this&#39;

            return this;
        },

        clone: function() {
            return new this.self();
        }
    });


    Ext.define(&#39;My.SnowLeopard&#39;, {
        extend: &#39;My.Cat&#39;,
        statics: {
            speciesName: &#39;Snow Leopard&#39;         // My.SnowLeopard.speciesName = &#39;Snow Leopard&#39;
        }
    });

    var cat = new My.Cat();                     // alerts &#39;Cat&#39;
    var snowLeopard = new My.SnowLeopard();     // alerts &#39;Snow Leopard&#39;

    var clone = snowLeopard.clone();
    alert(Ext.getClassName(clone));             // alerts &#39;My.SnowLeopard&#39;

         * @type Class
         * @protected
         * @markdown
         */
        self: Base,

        <a name="method-Ext.Base-constructor"></a>/**
         * Default constructor, simply returns `this`
         *
         * @constructor
         * @protected
         * @return {Object} this
         */
        constructor: function() {
            return this;
        },

        <a name="method-Ext.Base-initConfig"></a>/**
         * Initialize configuration for this class. a typical example:

    Ext.define(&#39;My.awesome.Class&#39;, {
        // The default config
        config: {
            name: &#39;Awesome&#39;,
            isAwesome: true
        },

        constructor: function(config) {
            this.initConfig(config);

            return this;
        }
    });

    var awesome = new My.awesome.Class({
        name: &#39;Super Awesome&#39;
    });

    alert(awesome.getName()); // &#39;Super Awesome&#39;

         * @protected
         * @param {Object} config
         * @return {Object} mixins The mixin prototypes as key - value pairs
         * @markdown
         */
        initConfig: function(config) {
            if (!this.$configInited) {
                this.config = Ext.Object.merge({}, this.config || {}, config || {});

                this.applyConfig(this.config);

                this.$configInited = true;
            }

            return this;
        },

        /**
         * @private
         */
        setConfig: function(config) {
            this.applyConfig(config || {});

            return this;
        },

        /**
         * @private
         */
        applyConfig: flexSetter(function(name, value) {
            var setter = &#39;set&#39; + Ext.String.capitalize(name);

            if (typeof this[setter] === &#39;function&#39;) {
                this[setter].call(this, value);
            }

            return this;
        }),

        <a name="method-Ext.Base-callParent"></a>/**
         * Call the overridden superclass&#39; method. For example:

    Ext.define(&#39;My.own.A&#39;, {
        constructor: function(test) {
            alert(test);
        }
    });

    Ext.define(&#39;My.own.B&#39;, {
        constructor: function(test) {
            alert(test);

            this.callParent([test + 1]);
        }
    });

    var a = new My.own.A(1); // alerts &#39;1&#39;
    var b = new My.own.B(1); // alerts &#39;1&#39;, then alerts &#39;2&#39;

         * @protected
         * @param {Array/Arguments} args The arguments, either an array or the `arguments` object
         * from the current method, for example: `this.callParent(arguments)`
         * @return {Mixed} Returns the result from the superclass&#39; method
         * @markdown
         */
        callParent: function(args) {
            var method = this.callParent.caller,
                parentClass, methodName;

            if (!method.$owner) {
                //&lt;debug error&gt;
                if (!method.caller) {
                    throw new Error(&quot;[&quot; + Ext.getClassName(this) + &quot;#callParent] Calling a protected method from the public scope&quot;);
                }
                //&lt;/debug&gt;

                method = method.caller;
            }

            parentClass = method.$owner.superclass;
            methodName = method.$name;

            //&lt;debug error&gt;
            if (!(methodName in parentClass)) {
                throw new Error(&quot;[&quot; + Ext.getClassName(this) + &quot;#&quot; + methodName + &quot;] this.callParent() was called but there&#39;s no such method (&quot; + methodName + &quot;) found in the parent class (&quot; +
                                (Ext.getClassName(parentClass) || &#39;Object&#39;) + &quot;)&quot;);
            }
            //&lt;/debug&gt;

            return parentClass[methodName].apply(this, args || []);
        },


        <a name="method-Ext.Base-statics"></a>/**
         * Get the reference to the class from which this object was instantiated. Note that unlike {@link Ext.Base#self},
         * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
         * `this` points to during run-time

    Ext.define(&#39;My.Cat&#39;, {
        statics: {
            totalCreated: 0,
            speciesName: &#39;Cat&#39; // My.Cat.speciesName = &#39;Cat&#39;
        },

        constructor: function() {
            var statics = this.statics();

            alert(statics.speciesName);     // always equals to &#39;Cat&#39; no matter what &#39;this&#39; refers to
                                            // equivalent to: My.Cat.speciesName

            alert(this.self.speciesName);   // dependent on &#39;this&#39;

            statics.totalCreated++;

            return this;
        },

        clone: function() {
            var cloned = new this.self;                      // dependent on &#39;this&#39;

            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName

            return cloned;
        }
    });


    Ext.define(&#39;My.SnowLeopard&#39;, {
        extend: &#39;My.Cat&#39;,

        statics: {
            speciesName: &#39;Snow Leopard&#39;     // My.SnowLeopard.speciesName = &#39;Snow Leopard&#39;
        },

        constructor: function() {
            this.callParent();
        }
    });

    var cat = new My.Cat();                 // alerts &#39;Cat&#39;, then alerts &#39;Cat&#39;

    var snowLeopard = new My.SnowLeopard(); // alerts &#39;Cat&#39;, then alerts &#39;Snow Leopard&#39;

    var clone = snowLeopard.clone();
    alert(Ext.getClassName(clone));         // alerts &#39;My.SnowLeopard&#39;
    alert(clone.groupName);                 // alerts &#39;Cat&#39;

    alert(My.Cat.totalCreated);             // alerts 3

         * @protected
         * @return {Class}
         * @markdown
         */
        statics: function() {
            var method = this.statics.caller,
                self = this.self;

            if (!method) {
                return self;
            }

            return method.$owner;
        },

        <a name="method-Ext.Base-callOverridden"></a>/**
         * Call the original method that was previously overridden with {@link Ext.Base#override}

    Ext.define(&#39;My.Cat&#39;, {
        constructor: function() {
            alert(&quot;I&#39;m a cat!&quot;);

            return this;
        }
    });

    My.Cat.override({
        constructor: function() {
            alert(&quot;I&#39;m going to be a cat!&quot;);

            var instance = this.callOverridden();

            alert(&quot;Meeeeoooowwww&quot;);

            return instance;
        }
    });

    var kitty = new My.Cat(); // alerts &quot;I&#39;m going to be a cat!&quot;
                              // alerts &quot;I&#39;m a cat!&quot;
                              // alerts &quot;Meeeeoooowwww&quot;

         * @param {Array/Arguments} args The arguments, either an array or the `arguments` object
         * @return {Mixed} Returns the result after calling the overridden method
         * @markdown
         */
        callOverridden: function(args) {
            var method = this.callOverridden.caller;

            //&lt;debug error&gt;
            if (!method.$owner) {
                throw new Error(&quot;[&quot; + Ext.getClassName(this) + &quot;#callOverridden] Calling a protected method from the &quot; +
                                &quot;public scope&quot;);
            }

            if (!method.$previous) {
                throw new Error(&quot;[&quot; + Ext.getClassName(this) + &quot;] this.callOverridden was called in &#39;&quot; + method.$name +
                                &quot;&#39; but this method has never been overridden&quot;);
            }
            //&lt;/debug&gt;

            return method.$previous.apply(this, args || []);
        },

        destroy: function() {}
    };

    // These static properties will be copied to every newly created class with {@link Ext#define}
    Ext.apply(Ext.Base, {

        /**
         * @private
         */
        ownMethod: function(name, fn) {
            var originalFn;

            if (fn.$owner !== undefined &amp;&amp; fn !== Ext.emptyFn) {
                originalFn = fn;

                fn = function() {
                    return originalFn.apply(this, arguments);
                };
            }

            //&lt;debug&gt;
            var className;
            className = Ext.getClassName(this);
            if (className) {
                fn.displayName = className + &#39;#&#39; + name;
            }
            //&lt;/debug&gt;
            fn.$owner = this;
            fn.$name = name;

            this.prototype[name] = fn;
        },

        /**
         * @private
         */
        borrowMethod: function(name, fn) {
            if (fn.$owner === undefined) {
                this.ownMethod(name, fn);
            }
            else {
                this.prototype[name] = fn;
            }
        },

        <a name="method-Ext.Base-Ext.Base.addStatics"></a>/**
         * Add / override static properties of this class.

    Ext.define(&#39;My.cool.Class&#39;, {
        ...
    });

    My.cool.Class.addStatics({
        someProperty: &#39;someValue&#39;,      // My.cool.Class.someProperty = &#39;someValue&#39;
        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
    });

         * @property addStatics
         * @static
         * @type Function
         * @param {Object} members
         * @markdown
         */
        addStatics: function(members) {
            for (var name in members) {
                if (members.hasOwnProperty(name)) {
                    this[name] = members[name];
                }
            }

            return this;
        },

        <a name="method-Ext.Base-Ext.Base.extend"></a>/**
         * Add / override prototype properties of this class.

    Ext.define(&#39;My.cool.Class&#39;, {
        ...
    });

    // Object with key - value pairs
    My.cool.Class.extend({
        someProperty: &#39;someValue&#39;,
        method1: function() { ... },
        method2: function() { ... }
    });

    var cool = new My.cool.Class();
    alert(cool.someProperty); // alerts &#39;someValue&#39;
    cool.method1();
    cool.method2();

         * @property extend
         * @static
         * @type Function
         * @param {Object} members
         * @markdown
         */
        extend: function(members) {
            var name, i, member;

            for (name in members) {
                if (members.hasOwnProperty(name)) {
                    member = members[name];

                    if (member instanceof Function) {
                        this.ownMethod(name, member);
                    }
                    else {
                        this.prototype[name] = member;
                    }
                }
            }

            if (Ext.enumerables) {
                var enumerables = Ext.enumerables;

                for (i = enumerables.length; i--;) {
                    name = enumerables[i];

                    if (members.hasOwnProperty(name)) {
                        this.ownMethod(name, members[name]);
                    }
                }
            }

            return this;
        },

        //&lt;debug&gt;
        <a name="method-Ext.Base-implement"></a>/**
         * This method is deprecated, please use {@link Ext.Base#extend} instead
         */
        implement: function() {
            if (Ext.isDefined(Ext.global.console)) {
                Ext.global.console.warn(&quot;[DEPRECATED][Ext.Base] Class.implement is deprecated, please use Class.extend instead&quot;);
                return this.extend.apply(this, arguments);
            }
        },
        //&lt;/debug&gt;

        <a name="method-Ext.Base-Ext.Base.override"></a>/**
         * Add / override prototype properties of this class. This method is similar to {@link Ext.Base#extend},
         * except that it stores the reference of the overridden method which can be called later on via {@link Ext.Base#callOverridden}

    Ext.define(&#39;My.Cat&#39;, {
        constructor: function() {
            alert(&quot;I&#39;m a cat!&quot;);

            return this;
        }
    });

    My.Cat.override({
        constructor: function() {
            alert(&quot;I&#39;m going to be a cat!&quot;);

            var instance = this.callOverridden();

            alert(&quot;Meeeeoooowwww&quot;);

            return instance;
        }
    });

    var kitty = new My.Cat(); // alerts &quot;I&#39;m going to be a cat!&quot;
                              // alerts &quot;I&#39;m a cat!&quot;
                              // alerts &quot;Meeeeoooowwww&quot;

         * @property override
         * @static
         * @type Function
         * @param {String/Object} name See {@link Ext.Function#flexSetter flexSetter}
         * @param {Mixed} value See {@link Ext.Function#flexSetter flexSetter}
         * @markdown
         */
        override: flexSetter(function(name, value) {
            if (Ext.isObject(this.prototype[name]) &amp;&amp; Ext.isObject(value)) {
                Ext.Object.merge(this.prototype[name], value);
            }
            else if (Ext.isFunction(value)) {
                if (Ext.isFunction(this.prototype[name])) {
                    var previous = this.prototype[name];
                    this.ownMethod(name, value);
                    this.prototype[name].$previous = previous;
                }
                else {
                    this.ownMethod(name, value);
                }
            }
            else {
                this.prototype[name] = value;
            }
        }),

       /**
         * Used internally by the mixins pre-processor
         * @private
         */
        mixin: flexSetter(function(name, cls) {
            var mixinPrototype = cls.prototype,
                myPrototype = this.prototype,
                i;

            for (i in mixinPrototype) {
                if (mixinPrototype.hasOwnProperty(i)) {
                    if (myPrototype[i] === undefined) {
                        if (Ext.isFunction(mixinPrototype[i])) {
                            this.borrowMethod(i, mixinPrototype[i]);
                        }
                        else {
                            myPrototype[i] = mixinPrototype[i];
                        }
                    }
                    else if (i === &#39;config&#39; &amp;&amp; Ext.isObject(myPrototype[i]) &amp;&amp; Ext.isObject(mixinPrototype[i])) {
                        Ext.Object.merge(myPrototype[i], mixinPrototype[i]);
                    }
                }
            }

            if (!myPrototype.mixins) {
                myPrototype.mixins = {};
            }

            myPrototype.mixins[name] = mixinPrototype;
        }),

        <a name="method-Ext.Base-getName"></a>/**
         * Get the current class&#39; name in string format.

    Ext.define(&#39;My.cool.Class&#39;, {
        constructor: function() {
            alert(this.self.getName()); // alerts &#39;My.cool.Class&#39;
        }
    });

         * @return {String} className
         * @markdown
         */
        getName: function() {
            return Ext.getClassName(this);
        },

        <a name="method-Ext.Base-Ext.Base.createAlias"></a>/**
         * Create aliases for current prototype methods. Example:

    Ext.define(&#39;My.cool.Class&#39;, {
        method1: function() { ... },
        method2: function() { ... }
    });

    var test = new My.cool.Class();

    My.cool.Class.createAlias({
        method3: &#39;method1&#39;,
        method4: &#39;method2&#39;
    });

    test.method3(); // test.method1()

    My.cool.Class.createAlias(&#39;method5&#39;, &#39;method3&#39;);

    test.method5(); // test.method3() -&gt; test.method1()

         * @property createAlias
         * @static
         * @type Function
         * @param {String/Object} alias The new method name, or an object to set multiple aliases. See
         * {@link Ext.Function#flexSetter flexSetter}
         * @param {String/Object} origin The original method name
         * @markdown
         */
        createAlias: flexSetter(function(alias, origin) {
            this.prototype[alias] = this.prototype[origin];
        })
    });

})(Ext.Function.flexSetter);
￿</pre></pre></body></html>