<!DOCTYPE html><html><head><title>Sencha Documentation Project</title><link rel="stylesheet" href="../reset.css" type="text/css"><link rel="stylesheet" href="../prettify.css" type="text/css"><link rel="stylesheet" href="../prettify_sa.css" type="text/css"><script type="text/javascript" src="../prettify.js"></script></head><body onload="prettyPrint()"><pre class="prettyprint"><pre><a name="cls-Ext.form.HtmlEditor"></a>/**
 * @class Ext.form.HtmlEditor
 * @extends Ext.Component
 * Provides a lightweight HTML Editor component. Some toolbar features are not supported by Safari and will be
 * automatically hidden when needed.  These are noted in the config options where appropriate.
 * &lt;br&gt;&lt;br&gt;The editor&#39;s toolbar buttons have tooltips defined in the {@link #buttonTips} property, but they are not
 * enabled by default unless the global {@link Ext.tip.QuickTips} singleton is {@link Ext.tip.QuickTips#init initialized}.
 * &lt;br&gt;&lt;br&gt;An Editor is a sensitive component that can&#39;t be used in all spots standard fields can be used. Putting an Editor within
 * any element that has display set to &#39;none&#39; can cause problems in Safari and Firefox due to their default iframe reloading bugs.
 * &lt;br&gt;&lt;br&gt;Example usage:
 * <br><span style="display: none">**/</span>// Simple example rendered with default options:
Ext.tip.QuickTips.init();  // enable tooltips
new Ext.form.HtmlEditor({
    renderTo: Ext.getBody(),
    width: 800,
    height: 300
});

// Passed via xtype into a container and with custom options:
Ext.tip.QuickTips.init();  // enable tooltips
new Ext.panel.Panel({
    title: &#39;HTML Editor&#39;,
    renderTo: Ext.getBody(),
    width: 600,
    height: 300,
    frame: true,
    layout: &#39;fit&#39;,
    items: {
        xtype: &#39;htmleditor&#39;,
        enableColors: false,
        enableAlignments: false
    }
});
<br><span style="display: none">/**</span> * @constructor
 * Create a new HtmlEditor
 * @param {Object} config
 * @xtype htmleditor
 */

Ext.define(&#39;Ext.form.HtmlEditor&#39;, {
    extend:&#39;Ext.Component&#39;,
    mixins: {
        labelable: &#39;Ext.form.Labelable&#39;,
        field: &#39;Ext.form.Field&#39;
    },
    alias: &#39;widget.htmleditor&#39;,
    requires: [
        &#39;Ext.tip.QuickTips&#39;,
        &#39;Ext.picker.Color&#39;,
        &#39;Ext.toolbar.Item&#39;,
        &#39;Ext.toolbar.Toolbar&#39;,
        &#39;Ext.util.Format&#39;,
        &#39;Ext.layout.component.form.HtmlEditor&#39;
    ],

    <a name="cfg-Ext.form.HtmlEditor-enableFormat"></a>/**
     * @cfg {Boolean} enableFormat Enable the bold, italic and underline buttons (defaults to true)
     */
    enableFormat : true,
    <a name="cfg-Ext.form.HtmlEditor-enableFontSize"></a>/**
     * @cfg {Boolean} enableFontSize Enable the increase/decrease font size buttons (defaults to true)
     */
    enableFontSize : true,
    <a name="cfg-Ext.form.HtmlEditor-enableColors"></a>/**
     * @cfg {Boolean} enableColors Enable the fore/highlight color buttons (defaults to true)
     */
    enableColors : true,
    <a name="cfg-Ext.form.HtmlEditor-enableAlignments"></a>/**
     * @cfg {Boolean} enableAlignments Enable the left, center, right alignment buttons (defaults to true)
     */
    enableAlignments : true,
    <a name="cfg-Ext.form.HtmlEditor-enableLists"></a>/**
     * @cfg {Boolean} enableLists Enable the bullet and numbered list buttons. Not available in Safari. (defaults to true)
     */
    enableLists : true,
    <a name="cfg-Ext.form.HtmlEditor-enableSourceEdit"></a>/**
     * @cfg {Boolean} enableSourceEdit Enable the switch to source edit button. Not available in Safari. (defaults to true)
     */
    enableSourceEdit : true,
    <a name="cfg-Ext.form.HtmlEditor-enableLinks"></a>/**
     * @cfg {Boolean} enableLinks Enable the create link button. Not available in Safari. (defaults to true)
     */
    enableLinks : true,
    <a name="cfg-Ext.form.HtmlEditor-enableFont"></a>/**
     * @cfg {Boolean} enableFont Enable font selection. Not available in Safari. (defaults to true)
     */
    enableFont : true,
    <a name="cfg-Ext.form.HtmlEditor-createLinkText"></a>/**
     * @cfg {String} createLinkText The default text for the create link prompt
     */
    createLinkText : &#39;Please enter the URL for the link:&#39;,
    <a name="cfg-Ext.form.HtmlEditor-defaultLinkValue"></a>/**
     * @cfg {String} defaultLinkValue The default value for the create link prompt (defaults to http:/ /)
     */
    defaultLinkValue : &#39;http:/&#39;+&#39;/&#39;,
    <a name="cfg-Ext.form.HtmlEditor-fontFamilies"></a>/**
     * @cfg {Array} fontFamilies An array of available font families
     */
    fontFamilies : [
        &#39;Arial&#39;,
        &#39;Courier New&#39;,
        &#39;Tahoma&#39;,
        &#39;Times New Roman&#39;,
        &#39;Verdana&#39;
    ],
    defaultFont: &#39;tahoma&#39;,
    <a name="cfg-Ext.form.HtmlEditor-defaultValue"></a>/**
     * @cfg {String} defaultValue A default value to be put into the editor to resolve focus issues (defaults to &amp;#160; (Non-breaking space) in Opera and IE6, &amp;#8203; (Zero-width space) in all other browsers).
     */
    defaultValue: (Ext.isOpera || Ext.isIE6) ? &#39;&amp;#160;&#39; : &#39;&amp;#8203;&#39;,

    fieldBodyCls: Ext.baseCSSPrefix + &#39;html-editor-wrap&#39;,

    componentLayout: &#39;htmleditor&#39;,

    // private properties
    initialized : false,
    activated : false,
    sourceEditMode : false,
    iframePad:3,
    hideMode:&#39;offsets&#39;,

    // private
    initComponent : function(){
        var me = this;

        me.addEvents(
            <a name="event-Ext.form.HtmlEditor-initialize"></a>/**
             * @event initialize
             * Fires when the editor is fully initialized (including the iframe)
             * @param {Ext.form.HtmlEditor} this
             */
            &#39;initialize&#39;,
            <a name="event-Ext.form.HtmlEditor-activate"></a>/**
             * @event activate
             * Fires when the editor is first receives the focus. Any insertion must wait
             * until after this event.
             * @param {Ext.form.HtmlEditor} this
             */
            &#39;activate&#39;,
             <a name="event-Ext.form.HtmlEditor-beforesync"></a>/**
             * @event beforesync
             * Fires before the textarea is updated with content from the editor iframe. Return false
             * to cancel the sync.
             * @param {Ext.form.HtmlEditor} this
             * @param {String} html
             */
            &#39;beforesync&#39;,
             <a name="event-Ext.form.HtmlEditor-beforepush"></a>/**
             * @event beforepush
             * Fires before the iframe editor is updated with content from the textarea. Return false
             * to cancel the push.
             * @param {Ext.form.HtmlEditor} this
             * @param {String} html
             */
            &#39;beforepush&#39;,
             <a name="event-Ext.form.HtmlEditor-sync"></a>/**
             * @event sync
             * Fires when the textarea is updated with content from the editor iframe.
             * @param {Ext.form.HtmlEditor} this
             * @param {String} html
             */
            &#39;sync&#39;,
             <a name="event-Ext.form.HtmlEditor-push"></a>/**
             * @event push
             * Fires when the iframe editor is updated with content from the textarea.
             * @param {Ext.form.HtmlEditor} this
             * @param {String} html
             */
            &#39;push&#39;,
             <a name="event-Ext.form.HtmlEditor-editmodechange"></a>/**
             * @event editmodechange
             * Fires when the editor switches edit modes
             * @param {Ext.form.HtmlEditor} this
             * @param {Boolean} sourceEdit True if source edit, false if standard editing.
             */
            &#39;editmodechange&#39;
        );

        me.callParent(arguments);

        // Init mixins
        me.initLabelable();
        me.initField();
    },

    /*
     * Protected method that will not generally be called directly. It
     * is called when the editor creates its toolbar. Override this method if you need to
     * add custom toolbar buttons.
     * @param {Ext.form.HtmlEditor} editor
     */
    createToolbar : function(editor){
        var me = this,
            items = [],
            tipsEnabled = Ext.tip.QuickTips &amp;&amp; Ext.tip.QuickTips.isEnabled(),
            baseCSSPrefix = Ext.baseCSSPrefix,
            fontSelectItem, toolbar, undef;

        function btn(id, toggle, handler){
            return {
                itemId : id,
                cls : baseCSSPrefix + &#39;btn-icon&#39;,
                iconCls: baseCSSPrefix + &#39;edit-&#39;+id,
                enableToggle:toggle !== false,
                scope: editor,
                handler:handler||editor.relayBtnCmd,
                clickEvent:&#39;mousedown&#39;,
                tooltip: tipsEnabled ? editor.buttonTips[id] || undef : undef,
                overflowText: editor.buttonTips[id].title || undef,
                tabIndex:-1
            };
        }


        if (me.enableFont &amp;&amp; !Ext.isSafari2) {
            fontSelectItem = Ext.widget(&#39;component&#39;, {
                renderTpl: [
                    &#39;&lt;select class=&quot;{cls}&quot;&gt;&#39;,
                        &#39;&lt;tpl for=&quot;fonts&quot;&gt;&#39;,
                            &#39;&lt;option value=&quot;{[values.toLowerCase()]}&quot; style=&quot;font-family:{.}&quot;&lt;tpl if=&quot;values.toLowerCase()==parent.defaultFont&quot;&gt; selected&lt;/tpl&gt;&gt;{.}&lt;/option&gt;&#39;,
                        &#39;&lt;/tpl&gt;&#39;,
                    &#39;&lt;/select&gt;&#39;
                ],
                renderData: {
                    cls: baseCSSPrefix + &#39;font-select&#39;,
                    fonts: me.fontFamilies,
                    defaultFont: me.defaultFont
                },
                renderSelectors: {
                    selectEl: &#39;select&#39;
                },
                onDisable: function() {
                    var selectEl = this.selectEl;
                    if (selectEl) {
                        selectEl.dom.disabled = true;
                    }
                    Ext.Component.superclass.onDisable.apply(arguments);
                },
                onEnable: function() {
                    var selectEl = this.selectEl;
                    if (selectEl) {
                        selectEl.dom.disabled = false;
                    }
                    Ext.Component.superclass.onEnable.apply(arguments);
                }
            });

            items.push(
                fontSelectItem,
                &#39;-&#39;
            );
        }

        if (me.enableFormat) {
            items.push(
                btn(&#39;bold&#39;),
                btn(&#39;italic&#39;),
                btn(&#39;underline&#39;)
            );
        }

        if (me.enableFontSize) {
            items.push(
                &#39;-&#39;,
                btn(&#39;increasefontsize&#39;, false, me.adjustFont),
                btn(&#39;decreasefontsize&#39;, false, me.adjustFont)
            );
        }

        if (me.enableColors) {
            items.push(
                &#39;-&#39;, {
                    itemId: &#39;forecolor&#39;,
                    cls: baseCSSPrefix + &#39;btn-icon&#39;,
                    iconCls: baseCSSPrefix + &#39;edit-forecolor&#39;,
                    clickEvent:&#39;mousedown&#39;,
                    tooltip: tipsEnabled ? editor.buttonTips.forecolor || undef : undef,
                    tabIndex:-1,
                    menu : Ext.widget(&#39;menu&#39;, {
                        plain: true,
                        items: [{
                            xtype: &#39;colorpicker&#39;,
                            allowReselect: true,
                            focus: Ext.emptyFn,
                            value: &#39;000000&#39;,
                            plain: true,
                            clickEvent: &#39;mousedown&#39;,
                            handler: function(cp, color) {
                                me.execCmd(&#39;forecolor&#39;, Ext.isWebKit || Ext.isIE ? &#39;#&#39;+color : color);
                                me.deferFocus();
                                this.up(&#39;menu&#39;).hide();
                            }
                        }]
                    })
                }, {
                    itemId: &#39;backcolor&#39;,
                    cls: baseCSSPrefix + &#39;btn-icon&#39;,
                    iconCls: baseCSSPrefix + &#39;edit-backcolor&#39;,
                    clickEvent:&#39;mousedown&#39;,
                    tooltip: tipsEnabled ? editor.buttonTips.backcolor || undef : undef,
                    tabIndex:-1,
                    menu : Ext.widget(&#39;menu&#39;, {
                        plain: true,
                        items: [{
                            xtype: &#39;colorpicker&#39;,
                            focus: Ext.emptyFn,
                            value: &#39;FFFFFF&#39;,
                            plain: true,
                            allowReselect: true,
                            clickEvent: &#39;mousedown&#39;,
                            handler: function(cp, color) {
                                if (Ext.isGecko) {
                                    me.execCmd(&#39;useCSS&#39;, false);
                                    me.execCmd(&#39;hilitecolor&#39;, color);
                                    me.execCmd(&#39;useCSS&#39;, true);
                                    me.deferFocus();
                                } else {
                                    me.execCmd(Ext.isOpera ? &#39;hilitecolor&#39; : &#39;backcolor&#39;, Ext.isWebKit || Ext.isIE ? &#39;#&#39;+color : color);
                                    me.deferFocus();
                                }
                                this.up(&#39;menu&#39;).hide();
                            }
                        }]
                    })
                }
            );
        }

        if (me.enableAlignments) {
            items.push(
                &#39;-&#39;,
                btn(&#39;justifyleft&#39;),
                btn(&#39;justifycenter&#39;),
                btn(&#39;justifyright&#39;)
            );
        }

        if (!Ext.isSafari2) {
            if (me.enableLinks) {
                items.push(
                    &#39;-&#39;,
                    btn(&#39;createlink&#39;, false, me.createLink)
                );
            }

            if (me.enableLists) {
                items.push(
                    &#39;-&#39;,
                    btn(&#39;insertorderedlist&#39;),
                    btn(&#39;insertunorderedlist&#39;)
                );
            }
            if (me.enableSourceEdit) {
                items.push(
                    &#39;-&#39;,
                    btn(&#39;sourceedit&#39;, true, function(btn){
                        me.toggleSourceEdit(!me.sourceEditMode);
                    })
                );
            }
        }

        // build the toolbar
        toolbar = Ext.widget(&#39;toolbar&#39;, {
            renderTo: me.toolbarWrap,
            padding: &#39;0 0 0 2px&#39;,
            items: items
        });

        if (fontSelectItem) {
            me.fontSelect = fontSelectItem.selectEl;

            me.mon(me.fontSelect, &#39;change&#39;, function(){
                me.relayCmd(&#39;fontname&#39;, me.fontSelect.dom.value);
                me.deferFocus();
            });
        }

        // stop form submits
        me.mon(toolbar.el, &#39;click&#39;, function(e){
            e.preventDefault();
        });

        me.toolbar = toolbar;
    },

    onDisable: function() {
        this.bodyEl.mask();
        this.callParent(arguments);
    },

    onEnable: function() {
        this.bodyEl.unmask();
        this.callParent(arguments);
    },

    <a name="method-Ext.form.HtmlEditor-setReadOnly"></a>/**
     * Sets the read only state of this field.
     * @param {Boolean} readOnly Whether the field should be read only.
     */
    setReadOnly: function(readOnly) {
        var me = this,
            textareaEl = me.textareaEl,
            iframeEl = me.iframeEl,
            body;

        me.readOnly = readOnly;

        if (textareaEl) {
            textareaEl.dom.readOnly = readOnly;
        }

        if (me.initialized) {
            body = me.getEditorBody();
            if (Ext.isIE) {
                // Hide the iframe while setting contentEditable so it doesn&#39;t grab focus
                iframeEl.setDisplayed(false);
                body.contentEditable = !readOnly;
                iframeEl.setDisplayed(true);
            } else {
                me.setDesignMode(!readOnly);
            }
            if (body) {
                body.style.cursor = readOnly ? &#39;default&#39; : &#39;text&#39;;
            }
            me.disableItems(readOnly);
        }
    },

    <a name="method-Ext.form.HtmlEditor-getDocMarkup"></a>/**
     * Protected method that will not generally be called directly. It
     * is called when the editor initializes the iframe with HTML contents. Override this method if you
     * want to change the initialization markup of the iframe (e.g. to add stylesheets).
     *
     * Note: IE8-Standards has unwanted scroller behavior, so the default meta tag forces IE7 compatibility.
     * Also note that forcing IE7 mode works when the page is loaded normally, but if you are using IE&#39;s Web
     * Developer Tools to manually set the document mode, that will take precedence and override what this
     * code sets by default. This can be confusing when developing, but is not a user-facing issue.
     */
    getDocMarkup: function() {
        var me = this,
            h = me.iframeEl.getHeight() - me.iframePad * 2;
        return Ext.String.format(&#39;&lt;html&gt;&lt;head&gt;&lt;style type=&quot;text/css&quot;&gt;body{border:0;margin:0;padding:{0}px;height:{1}px;cursor:text}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&#39;, me.iframePad, h);
    },

    // private
    getEditorBody: function() {
        var doc = this.getDoc();
        return doc.body || doc.documentElement;
    },

    // private
    getDoc: function() {
        return (!Ext.isIE &amp;&amp; this.iframeEl.dom.contentDocument) || this.getWin().document;
    },

    // private
    getWin: function() {
        return Ext.isIE ? this.iframeEl.dom.contentWindow : window.frames[this.iframeEl.dom.name];
    },

    // private
    onRender: function() {
        var me = this,
            renderSelectors = me.renderSelectors;

        Ext.applyIf(renderSelectors, me.getLabelableSelectors());

        Ext.applyIf(renderSelectors, {
            toolbarWrap: &#39;div.&#39; + Ext.baseCSSPrefix + &#39;html-editor-tb&#39;,
            iframeEl: &#39;iframe&#39;,
            textareaEl: &#39;textarea&#39;
        });

        me.callParent(arguments);
        
        me.textareaEl.dom.value = me.value || &#39;&#39;;

        // Start polling for when the iframe document is ready to be manipulated
        me.monitorTask = Ext.TaskMgr.start({
            run: me.checkDesignMode,
            scope: me,
            interval:100
        });

        me.createToolbar(me);
        me.disableItems(true);
    },

    initRenderTpl: function() {
        var me = this;
        if (!me.hasOwnProperty(&#39;renderTpl&#39;)) {
            me.renderTpl = me.labelableRenderTpl;
        }
        return me.callParent();
    },

    initRenderData: function() {
        return Ext.applyIf(this.callParent(), this.getLabelableRenderData());
    },

    getSubTplData: function() {
        var cssPrefix = Ext.baseCSSPrefix;
        return {
            toolbarWrapCls: cssPrefix + &#39;html-editor-tb&#39;,
            textareaCls: cssPrefix + &#39;hidden&#39;,
            iframeName: Ext.id(),
            iframeSrc: Ext.SSL_SECURE_URL,
            size: &#39;width:550px;height:100px;&#39;
        };
    },

    getSubTplMarkup: function() {
        return this.fieldSubTpl.apply(this.getSubTplData());
    },

    initFrameDoc: function() {
        var me = this,
            doc, task;
        
        Ext.TaskMgr.stop(me.monitorTask);
        
        doc = me.getDoc();
        me.win = me.getWin();

        doc.open();
        doc.write(me.getDocMarkup());
        doc.close();

        task = { // must defer to wait for browser to be ready
            run: function() {
                var doc = me.getDoc();
                if (doc.body || doc.readyState === &#39;complete&#39;) {
                    Ext.TaskMgr.stop(task);
                    me.setDesignMode(true);
                    Ext.defer(me.initEditor, 10, me);
                }
            },
            interval : 10,
            duration:10000,
            scope: me
        };
        Ext.TaskMgr.start(task);
    },


    checkDesignMode: function() {
        var me = this,
            doc = me.getDoc();
        if (doc &amp;&amp; (!doc.editorInitialized || me.getDesignMode() !== &#39;on&#39;)) {
            me.initFrameDoc();
        }
    },

    /* private
     * set current design mode. To enable, mode can be true or &#39;on&#39;, off otherwise
     */
    setDesignMode: function(mode) {
        var me = this,
            doc = me.getDoc();
        if (doc) {
            if (me.readOnly) {
                mode = false;
            }
            doc.designMode = (/on|true/i).test(String(mode).toLowerCase()) ?&#39;on&#39;:&#39;off&#39;;
        }
    },

    // private
    getDesignMode: function() {
        var doc = this.getDoc();
        return !doc ? &#39;&#39; : String(doc.designMode).toLowerCase();
    },

    disableItems: function(disabled) {
        this.getToolbar().items.each(function(item){
            if(item.getItemId() !== &#39;sourceedit&#39;){
                item.setDisabled(disabled);
            }
        });
    },

    <a name="method-Ext.form.HtmlEditor-toggleSourceEdit"></a>/**
     * Toggles the editor between standard and source edit mode.
     * @param {Boolean} sourceEditMode (optional) True for source edit, false for standard
     */
    toggleSourceEdit: function(sourceEditMode) {
        var me = this,
            iframe = me.iframeEl,
            textarea = me.textareaEl,
            hiddenCls = Ext.baseCSSPrefix + &#39;hidden&#39;,
            btn = me.getToolbar().getComponent(&#39;sourceedit&#39;);

        if (!Ext.isBoolean(sourceEditMode)) {
            sourceEditMode = !me.sourceEditMode;
        }
        me.sourceEditMode = sourceEditMode;

        if (btn.pressed !== sourceEditMode) {
            btn.toggle(sourceEditMode);
        }
        if (sourceEditMode) {
            me.disableItems(true);
            me.syncValue();
            iframe.addCls(hiddenCls);
            textarea.removeCls(hiddenCls);
            textarea.dom.removeAttribute(&#39;tabIndex&#39;);
            textarea.focus();
        }
        else {
            if (me.initialized) {
                me.disableItems(me.readOnly);
            }
            me.pushValue();
            iframe.removeCls(hiddenCls);
            textarea.addCls(hiddenCls);
            textarea.dom.setAttribute(&#39;tabIndex&#39;, -1);
            me.deferFocus();
        }
        me.fireEvent(&#39;editmodechange&#39;, me, sourceEditMode);
        me.doComponentLayout();
    },

    // private used internally
    createLink : function() {
        var url = prompt(this.createLinkText, this.defaultLinkValue);
        if (url &amp;&amp; url !== &#39;http:/&#39;+&#39;/&#39;) {
            this.relayCmd(&#39;createlink&#39;, url);
        }
    },
    
    clearInvalid: Ext.emptyFn,

    // docs inherit from Field
    setValue: function(value) {
        var me = this,
            textarea = me.textareaEl;
        me.mixins.field.setValue.call(me, value);
        if (value === null || value === undefined) {
            value = &#39;&#39;;
        }
        if (textarea) {
            textarea.dom.value = value;
        }
        me.pushValue();
        return this;
    },

    <a name="method-Ext.form.HtmlEditor-cleanHtml"></a>/**
     * Protected method that will not generally be called directly. If you need/want
     * custom HTML cleanup, this is the method you should override.
     * @param {String} html The HTML to be cleaned
     * @return {String} The cleaned HTML
     */
    cleanHtml: function(html) {
        html = String(html);
        if (Ext.isWebKit) { // strip safari nonsense
            html = html.replace(/\sclass=&quot;(?:Apple-style-span|khtml-block-placeholder)&quot;/gi, &#39;&#39;);
        }

        /*
         * Neat little hack. Strips out all the non-digit characters from the default
         * value and compares it to the character code of the first character in the string
         * because it can cause encoding issues when posted to the server.
         */
        if (html.charCodeAt(0) === this.defaultValue.replace(/\D/g, &#39;&#39;)) {
            html = html.substring(1);
        }
        return html;
    },

    <a name="method-Ext.form.HtmlEditor-syncValue"></a>/**
     * @protected method that will not generally be called directly. Syncs the contents
     * of the editor iframe with the textarea.
     */
    syncValue : function(){
        var me = this,
            body, html, bodyStyle, match;
        if (me.initialized) {
            body = me.getEditorBody();
            html = body.innerHTML;
            if (Ext.isWebKit) {
                bodyStyle = body.getAttribute(&#39;style&#39;); // Safari puts text-align styles on the body element!
                match = bodyStyle.match(/text-align:(.*?);/i);
                if (match &amp;&amp; match[1]) {
                    html = &#39;&lt;div style=&quot;&#39; + match[0] + &#39;&quot;&gt;&#39; + html + &#39;&lt;/div&gt;&#39;;
                }
            }
            html = me.cleanHtml(html);
            if (me.fireEvent(&#39;beforesync&#39;, me, html) !== false) {
                me.textareaEl.dom.value = html;
                me.fireEvent(&#39;sync&#39;, me, html);
            }
        }
    },

    //docs inherit from Field
    getValue : function() {
        var me = this,
            value;
        if (!me.sourceEditMode) {
            me.syncValue();
        }
        value = me.rendered ? me.textareaEl.dom.value : me.value;
        me.value = value;
        return value;
    },

    <a name="method-Ext.form.HtmlEditor-pushValue"></a>/**
     * @protected method that will not generally be called directly. Pushes the value of the textarea
     * into the iframe editor.
     */
    pushValue: function() {
        var me = this,
            v;
        if(me.initialized){
            v = me.textareaEl.dom.value || &#39;&#39;;
            if (!me.activated &amp;&amp; v.length &lt; 1) {
                v = me.defaultValue;
            }
            if (me.fireEvent(&#39;beforepush&#39;, me, v) !== false) {
                me.getEditorBody().innerHTML = v;
                if (Ext.isGecko) {
                    // Gecko hack, see: https://bugzilla.mozilla.org/show_bug.cgi?id=232791#c8
                    me.setDesignMode(false);  //toggle off first
                    me.setDesignMode(true);
                }
                me.fireEvent(&#39;push&#39;, me, v);
            }
        }
    },

    // private
    deferFocus : function(){
         this.focus(false, true);
    },

    getFocusEl: function() {
        var me = this,
            win = me.win;
        return win &amp;&amp; !me.sourceEditMode ? win : me.textareaEl;
    },

    // private
    initEditor : function(){
        //Destroying the component during/before initEditor can cause issues.
        try {
            var me = this,
                dbody = me.getEditorBody(),
                ss = me.textareaEl.getStyles(&#39;font-size&#39;, &#39;font-family&#39;, &#39;background-image&#39;, &#39;background-repeat&#39;, &#39;background-color&#39;, &#39;color&#39;),
                doc,
                fn;

            ss[&#39;background-attachment&#39;] = &#39;fixed&#39;; // w3c
            dbody.bgProperties = &#39;fixed&#39;; // ie

            Ext.core.DomHelper.applyStyles(dbody, ss);

            doc = me.getDoc();

            if (doc) {
                try {
                    Ext.EventManager.removeAll(doc);
                } catch(e) {}
            }

            /*
             * We need to use createDelegate here, because when using buffer, the delayed task is added
             * as a property to the function. When the listener is removed, the task is deleted from the function.
             * Since onEditorEvent is shared on the prototype, if we have multiple html editors, the first time one of the editors
             * is destroyed, it causes the fn to be deleted from the prototype, which causes errors. Essentially, we&#39;re just anonymizing the function.
             */
            fn = Ext.Function.bind(me.onEditorEvent, me);
            Ext.EventManager.on(doc, {
                mousedown: fn,
                dblclick: fn,
                click: fn,
                keyup: fn,
                buffer:100
            });

            if (Ext.isGecko) {
                Ext.EventManager.on(doc, &#39;keypress&#39;, me.applyCommand, me);
            }
            if (Ext.isIE || Ext.isWebKit || Ext.isOpera) {
                Ext.EventManager.on(doc, &#39;keydown&#39;, me.fixKeys, me);
            }
            doc.editorInitialized = true;
            me.initialized = true;
            me.pushValue();
            me.setReadOnly(me.readOnly);
            me.fireEvent(&#39;initialize&#39;, me);
        } catch(ex) {}
    },

    // private
    beforeDestroy : function(){
        var me = this,
            monitorTask = me.monitorTask,
            doc, prop;

        if (monitorTask) {
            Ext.TaskMgr.stop(monitorTask);
        }
        if (me.rendered) {
            doc = me.getDoc();
            if (doc) {
                try {
                    Ext.EventManager.removeAll(doc);
                    for (prop in doc) {
                        if (doc.hasOwnProperty(prop)) {
                            delete doc[prop];
                        }
                    }
                } catch(e) {}
            }
            Ext.destroyMembers(&#39;tb&#39;, &#39;toolbarWrap&#39;, &#39;iframeEl&#39;, &#39;textareaEl&#39;);
        }
        me.callParent();
    },

    // private
    onFirstFocus : function(){
        var me = this,
            selection, range;
        me.activated = true;
        me.disableItems(me.readOnly);
        if (Ext.isGecko) { // prevent silly gecko errors
            me.win.focus();
            selection = me.win.getSelection();
            if (!selection.focusNode || selection.focusNode.nodeType !== 3) {
                range = selection.getRangeAt(0);
                range.selectNodeContents(me.getEditorBody());
                range.collapse(true);
                me.deferFocus();
            }
            try {
                me.execCmd(&#39;useCSS&#39;, true);
                me.execCmd(&#39;styleWithCSS&#39;, false);
            } catch(e) {}
        }
        me.fireEvent(&#39;activate&#39;, me);
    },

    // private
    adjustFont: function(btn) {
        var adjust = btn.getItemId() === &#39;increasefontsize&#39; ? 1 : -1,
            size = this.getDoc().queryCommandValue(&#39;FontSize&#39;) || &#39;2&#39;,
            isPxSize = size.indexOf(&#39;px&#39;) !== -1,
            isSafari;
        size = parseInt(size, 10);
        if (isPxSize) {
            // Safari 3 values
            // 1 = 10px, 2 = 13px, 3 = 16px, 4 = 18px, 5 = 24px, 6 = 32px
            if (size &lt;= 10) {
                size = 1 + adjust;
            }
            else if (size &lt;= 13) {
                size = 2 + adjust;
            }
            else if (size &lt;= 16) {
                size = 3 + adjust;
            }
            else if (size &lt;= 18) {
                size = 4 + adjust;
            }
            else if (size &lt;= 24) {
                size = 5 + adjust;
            }
            else {
                size = 6 + adjust;
            }
            size = Ext.Number.constrain(size, 1, 6);
        } else {
            isSafari = Ext.isSafari;
            if (isSafari) { // safari
                adjust *= 2;
            }
            size = Math.max(1, size + adjust) + (isSafari ? &#39;px&#39; : 0);
        }
        this.execCmd(&#39;FontSize&#39;, size);
    },

    // private
    onEditorEvent: function(e) {
        this.updateToolbar();
    },


    <a name="method-Ext.form.HtmlEditor-updateToolbar"></a>/**
     * Protected method that will not generally be called directly. It triggers
     * a toolbar update by reading the markup state of the current selection in the editor.
     */
    updateToolbar: function() {
        var me = this,
            btns, doc, name, fontSelect;

        if (me.readOnly) {
            return;
        }

        if (!me.activated) {
            me.onFirstFocus();
            return;
        }

        btns = me.getToolbar().items.map;
        doc = me.getDoc();

        if (me.enableFont &amp;&amp; !Ext.isSafari2) {
            name = (doc.queryCommandValue(&#39;FontName&#39;) || me.defaultFont).toLowerCase();
            fontSelect = me.fontSelect.dom;
            if (name !== fontSelect.value) {
                fontSelect.value = name;
            }
        }

        function updateButtons() {
            Ext.Array.forEach(Ext.Array.toArray(arguments), function(name) {
                btns[name].toggle(doc.queryCommandState(name));
            });
        }
        if(me.enableFormat){
            updateButtons(&#39;bold&#39;, &#39;italic&#39;, &#39;underline&#39;);
        }
        if(me.enableAlignments){
            updateButtons(&#39;justifyleft&#39;, &#39;justifycenter&#39;, &#39;justifyright&#39;);
        }
        if(!Ext.isSafari2 &amp;&amp; me.enableLists){
            updateButtons(&#39;insertorderedlist&#39;, &#39;insertunorderedlist&#39;);
        }

        Ext.menu.MenuManager.hideAll();

        me.syncValue();
    },

    // private
    relayBtnCmd: function(btn) {
        this.relayCmd(btn.getItemId());
    },

    <a name="method-Ext.form.HtmlEditor-relayCmd"></a>/**
     * Executes a Midas editor command on the editor document and performs necessary focus and
     * toolbar updates. &lt;b&gt;This should only be called after the editor is initialized.&lt;/b&gt;
     * @param {String} cmd The Midas command
     * @param {String/Boolean} value (optional) The value to pass to the command (defaults to null)
     */
    relayCmd: function(cmd, value) {
        Ext.defer(function() {
            var me = this;
            me.focus();
            me.execCmd(cmd, value);
            me.updateToolbar();
        }, 10, this);
    },

    <a name="method-Ext.form.HtmlEditor-execCmd"></a>/**
     * Executes a Midas editor command directly on the editor document.
     * For visual commands, you should use {@link #relayCmd} instead.
     * &lt;b&gt;This should only be called after the editor is initialized.&lt;/b&gt;
     * @param {String} cmd The Midas command
     * @param {String/Boolean} value (optional) The value to pass to the command (defaults to null)
     */
    execCmd : function(cmd, value){
        var me = this,
            doc = me.getDoc(),
            undef;
        doc.execCommand(cmd, false, value === undef ? null : value);
        me.syncValue();
    },

    // private
    applyCommand : function(e){
        if (e.ctrlKey) {
            var me = this,
                c = e.getCharCode(), cmd;
            if (c &gt; 0) {
                c = String.fromCharCode(c);
                switch (c) {
                    case &#39;b&#39;:
                        cmd = &#39;bold&#39;;
                    break;
                    case &#39;i&#39;:
                        cmd = &#39;italic&#39;;
                    break;
                    case &#39;u&#39;:
                        cmd = &#39;underline&#39;;
                    break;
                }
                if (cmd) {
                    me.win.focus();
                    me.execCmd(cmd);
                    me.deferFocus();
                    e.preventDefault();
                }
            }
        }
    },

    <a name="method-Ext.form.HtmlEditor-insertAtCursor"></a>/**
     * Inserts the passed text at the current cursor position. Note: the editor must be initialized and activated
     * to insert text.
     * @param {String} text
     */
    insertAtCursor : function(text){
        var me = this,
            range;

        if (me.activated) {
            me.win.focus();
            if (Ext.isIE) {
                range = me.getDoc().selection.createRange();
                if (range) {
                    range.pasteHTML(text);
                    me.syncValue();
                    me.deferFocus();
                }
            }else{
                me.execCmd(&#39;InsertHTML&#39;, text);
                me.deferFocus();
            }
        }
    },

    // private
    fixKeys: function() { // load time branching for fastest keydown performance
        if (Ext.isIE) {
            return function(e){
                var me = this,
                    k = e.getKey(),
                    doc = me.getDoc(),
                    range, target;
                if (k === e.TAB) {
                    e.stopEvent();
                    range = doc.selection.createRange();
                    if(range){
                        range.collapse(true);
                        range.pasteHTML(&#39;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#39;);
                        me.deferFocus();
                    }
                }
                else if (k === e.ENTER) {
                    range = doc.selection.createRange();
                    if (range) {
                        target = range.parentElement();
                        if(!target || target.tagName.toLowerCase() !== &#39;li&#39;){
                            e.stopEvent();
                            range.pasteHTML(&#39;&lt;br /&gt;&#39;);
                            range.collapse(false);
                            range.select();
                        }
                    }
                }
            };
        }
        else if (Ext.isOpera) {
            return function(e){
                var me = this;
                if (e.getKey() === e.TAB) {
                    e.stopEvent();
                    me.win.focus();
                    me.execCmd(&#39;InsertHTML&#39;,&#39;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#39;);
                    me.deferFocus();
                }
            };
        }
        else if (Ext.isWebKit) {
            return function(e){
                var me = this,
                    k = e.getKey();
                if (k === e.TAB) {
                    e.stopEvent();
                    me.execCmd(&#39;InsertText&#39;,&#39;\t&#39;);
                    me.deferFocus();
                }
                else if (k === e.ENTER) {
                    e.stopEvent();
                    me.execCmd(&#39;InsertHtml&#39;,&#39;&lt;br /&gt;&lt;br /&gt;&#39;);
                    me.deferFocus();
                }
             };
        }
    }(),

    <a name="method-Ext.form.HtmlEditor-getToolbar"></a>/**
     * Returns the editor&#39;s toolbar. &lt;b&gt;This is only available after the editor has been rendered.&lt;/b&gt;
     * @return {Ext.toolbar.Toolbar}
     */
    getToolbar : function(){
        return this.toolbar;
    },

    <a name="prop-Ext.form.HtmlEditor-buttonTips"></a>/**
     * Object collection of toolbar tooltips for the buttons in the editor. The key
     * is the command id associated with that button and the value is a valid QuickTips object.
     * For example:
<br><span style="display: none">**/</span>{
    bold : {
        title: &#39;Bold (Ctrl+B)&#39;,
        text: &#39;Make the selected text bold.&#39;,
        cls: &#39;x-html-editor-tip&#39;
    },
    italic : {
        title: &#39;Italic (Ctrl+I)&#39;,
        text: &#39;Make the selected text italic.&#39;,
        cls: &#39;x-html-editor-tip&#39;
    },
    ...
<br><span style="display: none">/**</span>    * @type Object
     */
    buttonTips : {
        bold : {
            title: &#39;Bold (Ctrl+B)&#39;,
            text: &#39;Make the selected text bold.&#39;,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tip&#39;
        },
        italic : {
            title: &#39;Italic (Ctrl+I)&#39;,
            text: &#39;Make the selected text italic.&#39;,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tip&#39;
        },
        underline : {
            title: &#39;Underline (Ctrl+U)&#39;,
            text: &#39;Underline the selected text.&#39;,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tip&#39;
        },
        increasefontsize : {
            title: &#39;Grow Text&#39;,
            text: &#39;Increase the font size.&#39;,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tip&#39;
        },
        decreasefontsize : {
            title: &#39;Shrink Text&#39;,
            text: &#39;Decrease the font size.&#39;,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tip&#39;
        },
        backcolor : {
            title: &#39;Text Highlight Color&#39;,
            text: &#39;Change the background color of the selected text.&#39;,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tip&#39;
        },
        forecolor : {
            title: &#39;Font Color&#39;,
            text: &#39;Change the color of the selected text.&#39;,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tip&#39;
        },
        justifyleft : {
            title: &#39;Align Text Left&#39;,
            text: &#39;Align text to the left.&#39;,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tip&#39;
        },
        justifycenter : {
            title: &#39;Center Text&#39;,
            text: &#39;Center text in the editor.&#39;,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tip&#39;
        },
        justifyright : {
            title: &#39;Align Text Right&#39;,
            text: &#39;Align text to the right.&#39;,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tip&#39;
        },
        insertunorderedlist : {
            title: &#39;Bullet List&#39;,
            text: &#39;Start a bulleted list.&#39;,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tip&#39;
        },
        insertorderedlist : {
            title: &#39;Numbered List&#39;,
            text: &#39;Start a numbered list.&#39;,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tip&#39;
        },
        createlink : {
            title: &#39;Hyperlink&#39;,
            text: &#39;Make the selected text a hyperlink.&#39;,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tip&#39;
        },
        sourceedit : {
            title: &#39;Source Edit&#39;,
            text: &#39;Switch to source editing mode.&#39;,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tip&#39;
        }
    }

    // hide stuff that is not compatible
    <a name="event-Ext.form.HtmlEditor-blur"></a>/**
     * @event blur
     * @hide
     */
    <a name="event-Ext.form.HtmlEditor-change"></a>/**
     * @event change
     * @hide
     */
    <a name="event-Ext.form.HtmlEditor-focus"></a>/**
     * @event focus
     * @hide
     */
    <a name="event-Ext.form.HtmlEditor-specialkey"></a>/**
     * @event specialkey
     * @hide
     */
    <a name="cfg-Ext.form.HtmlEditor-fieldCls"></a>/**
     * @cfg {String} fieldCls @hide
     */
    <a name="cfg-Ext.form.HtmlEditor-focusCls"></a>/**
     * @cfg {String} focusCls @hide
     */
    <a name="cfg-Ext.form.HtmlEditor-autoCreate"></a>/**
     * @cfg {String} autoCreate @hide
     */
    <a name="cfg-Ext.form.HtmlEditor-inputType"></a>/**
     * @cfg {String} inputType @hide
     */
    <a name="cfg-Ext.form.HtmlEditor-invalidCls"></a>/**
     * @cfg {String} invalidCls @hide
     */
    <a name="cfg-Ext.form.HtmlEditor-invalidText"></a>/**
     * @cfg {String} invalidText @hide
     */
    <a name="cfg-Ext.form.HtmlEditor-msgFx"></a>/**
     * @cfg {String} msgFx @hide
     */
    <a name="cfg-Ext.form.HtmlEditor-allowDomMove"></a>/**
     * @cfg {Boolean} allowDomMove  @hide
     */
    <a name="cfg-Ext.form.HtmlEditor-applyTo"></a>/**
     * @cfg {String} applyTo @hide
     */
    <a name="cfg-Ext.form.HtmlEditor-readOnly"></a>/**
     * @cfg {String} readOnly  @hide
     */
    <a name="cfg-Ext.form.HtmlEditor-tabIndex"></a>/**
     * @cfg {String} tabIndex  @hide
     */
    <a name="method-Ext.form.HtmlEditor-validate"></a>/**
     * @method validate
     * @hide
     */
}, function() {

    this.prototype.fieldSubTpl = new Ext.XTemplate(
        &#39;&lt;div class=&quot;{toolbarWrapCls}&quot;&gt;&lt;/div&gt;&#39;,
        &#39;&lt;textarea id=&quot;{id}&quot; name=&quot;{name}&quot; tabIndex=&quot;-1&quot; class=&quot;{textareaCls}&quot; &#39;,
            &#39;style=&quot;{size}&quot; autocomplete=&quot;off&quot;&gt;&lt;/textarea&gt;&#39;,
        &#39;&lt;iframe name=&quot;{iframeName}&quot; frameBorder=&quot;0&quot; style=&quot;overflow:auto;{size}&quot; src=&quot;{iframeSrc}&quot;&gt;&lt;/iframe&gt;&#39;,
        {
            compiled: true,
            disableFormats: true
        }
    );

});
￿</pre></pre></body></html>