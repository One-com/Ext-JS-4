<!DOCTYPE html><html><head><title>Sencha Documentation Project</title><link rel="stylesheet" href="../reset.css" type="text/css"><link rel="stylesheet" href="../prettify.css" type="text/css"><link rel="stylesheet" href="../prettify_sa.css" type="text/css"><script type="text/javascript" src="../prettify.js"></script></head><body onload="prettyPrint()"><pre class="prettyprint"><pre><a name="cls-Ext.data.TreeStore"></a>/**
 * @class Ext.data.TreeStore
 * @extends Ext.data.AbstractStore
 * Tree Store
 */
Ext.define(&#39;Ext.data.TreeStore&#39;, {
    extend: &#39;Ext.data.AbstractStore&#39;,
    alias: &#39;store.tree&#39;,
    requires: [&#39;Ext.data.Tree&#39;, &#39;Ext.data.NodeInterface&#39;, &#39;Ext.data.NodeStore&#39;],

    <a name="cfg-Ext.data.TreeStore-clearOnLoad"></a>/**
     * @cfg {Boolean} clearOnLoad (optional) Default to true. Remove previously existing
     * child nodes before loading.
     */
    clearOnLoad : true,

    <a name="cfg-Ext.data.TreeStore-nodeParam"></a>/**
     * @cfg {String} nodeParam The name of the parameter sent to the server which contains
     * the identifier of the node. Defaults to &lt;tt&gt;&#39;node&#39;&lt;/tt&gt;.
     */
    nodeParam: &#39;node&#39;,

    <a name="cfg-Ext.data.TreeStore-defaultRootId"></a>/**
     * @cfg {String} defaultRootId
     * The default root id. Defaults to &#39;root&#39;
     */
    defaultRootId: &#39;root&#39;,

    <a name="cfg-Ext.data.TreeStore-folderSort"></a>/**
     * @cfg {Boolean} folderSort Set to true to automatically prepend a leaf sorter (defaults to &lt;tt&gt;undefined&lt;/tt&gt;)
     */
    folderSort: false,
    
    constructor: function(config) {
        var me = this, root;
        config = config || {};
        
        if (!config.proxy) {
            config.proxy = {type: &#39;memory&#39;};
        }
        
        if (!config.proxy.isProxy) {
            config.proxy.reader = Ext.applyIf(config.proxy.reader || {}, {
                type: &#39;json&#39;,
                root: &#39;children&#39;
            });
        }
        
        if (!config.model &amp;&amp; !config.fields) {
            config.fields = [{name: &#39;text&#39;, type: &#39;string&#39;}];
        }

        me.callParent([config]);
        
        // We create our data tree.
        me.tree = Ext.create(&#39;Ext.data.Tree&#39;);
        
        me.tree.on({
            beforeexpand: this.onBeforeNodeExpand,
            beforecollapse: this.onBeforeNodeCollapse,
            scope: this
        });

        me.onBeforeSort();
                
        root = me.root;
        delete me.root;
        me.setRootNode(root);

        me.relayEvents(me.tree, [
            <a name="event-Ext.data.TreeStore-append"></a>/**
             * @event append
             * Fires when a new child node is appended to a node in this store&#39;s tree.
             * @param {Tree} tree The owner tree
             * @param {Node} parent The parent node
             * @param {Node} node The newly appended node
             * @param {Number} index The index of the newly appended node
             */
            &quot;append&quot;,
            
            <a name="event-Ext.data.TreeStore-remove"></a>/**
             * @event remove
             * Fires when a child node is removed from a node in this store&#39;s tree.
             * @param {Tree} tree The owner tree
             * @param {Node} parent The parent node
             * @param {Node} node The child node removed
             */
            &quot;remove&quot;,
            
            <a name="event-Ext.data.TreeStore-move"></a>/**
             * @event move
             * Fires when a node is moved to a new location in the store&#39;s tree
             * @param {Tree} tree The owner tree
             * @param {Node} node The node moved
             * @param {Node} oldParent The old parent of this node
             * @param {Node} newParent The new parent of this node
             * @param {Number} index The index it was moved to
             */
            &quot;move&quot;,
            
            <a name="event-Ext.data.TreeStore-insert"></a>/**
             * @event insert
             * Fires when a new child node is inserted in a node in this store&#39;s tree.
             * @param {Tree} tree The owner tree
             * @param {Node} parent The parent node
             * @param {Node} node The child node inserted
             * @param {Node} refNode The child node the node was inserted before
             */
            &quot;insert&quot;,
            
            <a name="event-Ext.data.TreeStore-beforeappend"></a>/**
             * @event beforeappend
             * Fires before a new child is appended to a node in this store&#39;s tree, return false to cancel the append.
             * @param {Tree} tree The owner tree
             * @param {Node} parent The parent node
             * @param {Node} node The child node to be appended
             */
            &quot;beforeappend&quot;,
            
            <a name="event-Ext.data.TreeStore-beforeremove"></a>/**
             * @event beforeremove
             * Fires before a child is removed from a node in this store&#39;s tree, return false to cancel the remove.
             * @param {Tree} tree The owner tree
             * @param {Node} parent The parent node
             * @param {Node} node The child node to be removed
             */
            &quot;beforeremove&quot;,
            
            <a name="event-Ext.data.TreeStore-beforemove"></a>/**
             * @event beforemove
             * Fires before a node is moved to a new location in the store&#39;s tree. Return false to cancel the move.
             * @param {Tree} tree The owner tree
             * @param {Node} node The node being moved
             * @param {Node} oldParent The parent of the node
             * @param {Node} newParent The new parent the node is moving to
             * @param {Number} index The index it is being moved to
             */
            &quot;beforemove&quot;,
            
            <a name="event-Ext.data.TreeStore-beforeinsert"></a>/**
             * @event beforeinsert
             * Fires before a new child is inserted in a node in this store&#39;s tree, return false to cancel the insert.
             * @param {Tree} tree The owner tree
             * @param {Node} parent The parent node
             * @param {Node} node The child node to be inserted
             * @param {Node} refNode The child node the node is being inserted before
             */
            &quot;beforeinsert&quot;,
             
             <a name="event-Ext.data.TreeStore-expand"></a>/**
              * @event expand
              * Fires when this node is expanded.
              * @param {Node} this The expanding node
              */
             &quot;expand&quot;,
             
             <a name="event-Ext.data.TreeStore-collapse"></a>/**
              * @event collapse
              * Fires when this node is collapsed.
              * @param {Node} this The collapsing node
              */
             &quot;collapse&quot;,
             
             <a name="event-Ext.data.TreeStore-beforeexpand"></a>/**
              * @event beforeexpand
              * Fires before this node is expanded.
              * @param {Node} this The expanding node
              */
             &quot;beforeexpand&quot;,
             
             <a name="event-Ext.data.TreeStore-beforecollapse"></a>/**
              * @event beforecollapse
              * Fires before this node is collapsed.
              * @param {Node} this The collapsing node
              */
             &quot;beforecollapse&quot;,

             <a name="event-Ext.data.TreeStore-sort"></a>/**
              * @event sort
              * Fires when this TreeStore is sorted.
              * @param {Node} node The node that is sorted.
              */             
             &quot;sort&quot;          
        ]);
        
        //&lt;deprecated since=0.99&gt;
        if (Ext.isDefined(me.nodeParameter)) {
            throw &quot;Ext.data.TreeStore: nodeParameter has been renamed to nodeParam for consistency&quot;;
        }
        //&lt;/deprecated&gt;
    },
    
    onBeforeSort: function() {
        if (this.folderSort) {
            this.sort({
                property: &#39;leaf&#39;,
                direction: &#39;ASC&#39;
            }, &#39;prepend&#39;, false);    
        }
    },
    
    onBeforeNodeExpand: function(node, callback, scope) {
        if (node.loaded) {
            callback.call(scope || node, node.childNodes);
        }
        else {
            this.read({
                node: node,
                callback: callback,
                scope: scope || node
            });
        }
    },
    
    onBeforeNodeCollapse: function(node, callback, scope) {
        callback.call(scope || node, node.childNodes);
    },

    setRootNode: function(root) {
        var me = this,
            proxy = me.getProxy(),
            reader = proxy.getReader(),
            children, dataRoot;

        root = root || {};        
        if (!root.isNode) {
            // create a default rootNode and create internal data struct.        
            Ext.applyIf(root, {
                id: me.defaultRootId,
                text: &#39;Root&#39;
            });
            dataRoot = reader.getRoot(root);
            root = Ext.ModelMgr.create(root, me.model);
        }

        // When we add the root to the tree, it will automaticaly get the NodeInterface
        me.tree.setRootNode(root);

        // Because the tree might have decorated the model with new fields,
        // we need to build new extactor functions on the reader.
        me.getProxy().getReader().buildExtractors(true);
        
        // We want to load any children descending the root node        
        if (dataRoot) {
            children = reader.extractData(dataRoot);
            this.fillNode(root, children);
        }

        // If the user has set expanded: true on the root, we want to call the expand function
        if (root.isExpanded()) {
            root.expand();
        }
    },
    
    <a name="method-Ext.data.TreeStore-getRootNode"></a>/**
     * Returns the root node for this tree.
     * @return {Ext.data.Record}
     */
    getRootNode: function() {
        return this.tree.getRootNode();
    },

    <a name="method-Ext.data.TreeStore-getNodeById"></a>/**
     * Returns the record node by id
     * @return {Ext.data.Record}
     */
    getNodeById: function(id) {
        return this.tree.getNodeById(id);
    },


    // new options are
    // * node - a node within the tree
    // * doPreload - private option used to preload existing childNodes
    load: function(options) {
        options = options || {};
        options.params = options.params || {};
        
        var me = this,
            node = options.node || me.tree.getRootNode(),
            reader = this.proxy.reader,
            root;
        
        if (me.clearOnLoad) {
            node.removeAll();
        }
        
        Ext.applyIf(options, {
            node: node
        });
        options.params[me.nodeParam] = node ? node.get(&#39;id&#39;) : &#39;root&#39;;
        return me.callParent([options]);
    },
        
    // @private
    // fills an Ext.data.RecordNode with records
    fillNode: function(node, records) {
        var me = this,
            ln = records ? records.length : 0,
            reader = me.proxy.reader,
            recordNode,
            record,
            dataRoot,
            preloadChildren,
            i = 0,
            raw;

        if (ln &amp;&amp; me.sortOnLoad &amp;&amp; !me.remoteSort &amp;&amp; me.sorters &amp;&amp; me.sorters.items) {
            sortCollection = Ext.create(&#39;Ext.util.MixedCollection&#39;);
            sortCollection.addAll(records);
            sortCollection.sort(me.sorters.items);
            records = sortCollection.items;
        }

        node.loaded = true;
        for (; i &lt; ln; i++) {
            record = records[i];
            node.appendChild(record, true);
            
            // Since we are suppressing the event, we have to manually register the node with the tree
            me.tree.registerNode(record);
            
            // If the record contains any children then extract them and add them
            if (record.raw) {
                dataRoot = reader.getRoot(record.raw);
                if (dataRoot) {
                    preloadChildren = reader.extractData(dataRoot);
                    me.fillNode(record, preloadChildren);    
                }
            }
        }
        
        return records;
    },

    onProxyLoad: function(operation) {
        var me = this,
            successful = operation.wasSuccessful(),
            records = operation.getRecords(),
            node = operation.node,
            sortCollection;

        if (successful) {
            records = me.fillNode(node, records);
        }
        // deprecate read?
        me.fireEvent(&#39;read&#39;, me, operation.node, records, successful);
        me.fireEvent(&#39;load&#39;, me, operation.node, records, successful);
        //this is a callback that would have been passed to the &#39;read&#39; function and is optional
        Ext.callback(operation.callback, operation.scope || me, [records, operation, successful]);
    },

    removeAll: function() {
        this.getRootNode().destroy();
    },

    doSort: function(sorterFn) {
        var me = this;
        if (me.remoteSort) {
            //the load function will pick up the new sorters and request the sorted data from the proxy
            me.load();
        } else {
            me.tree.sort(sorterFn, true);
            me.fireEvent(&#39;datachanged&#39;, me);
        }   
        me.fireEvent(&#39;sort&#39;, me);
    }
});￿</pre></pre></body></html>