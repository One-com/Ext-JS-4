<!DOCTYPE html><html><head><title>Sencha Documentation Project</title><link rel="stylesheet" href="../reset.css" type="text/css"><link rel="stylesheet" href="../prettify.css" type="text/css"><link rel="stylesheet" href="../prettify_sa.css" type="text/css"><script type="text/javascript" src="../prettify.js"></script></head><body onload="prettyPrint()"><pre class="prettyprint"><pre><a name="cls-Ext.layout.container.Border"></a>/**
 * @class Ext.layout.container.Border
 * @extends Ext.layout.Container
 * &lt;p&gt;This is a multi-pane, application-oriented UI layout style that supports multiple
 * nested panels, automatic bars between regions and built-in
 * {@link Ext.panel.Panel#collapsible expanding and collapsing} of regions.&lt;/p&gt;
 * &lt;p&gt;This class is intended to be extended or created via the &lt;code&gt;layout:&#39;border&#39;&lt;/code&gt;
 * {@link Ext.container.Container#layout} config, and should generally not need to be created directly
 * via the new keyword.&lt;/p&gt;
 * &lt;p&gt;Example usage:&lt;/p&gt;
 * <br><span style="display: none">**/</span>var myBorderPanel = new Ext.panel.Panel({
    {@link Ext.Component#renderTo renderTo}: document.body,
    {@link Ext.AbstractComponent#width width}: 700,
    {@link Ext.AbstractComponent#height height}: 500,
    {@link Ext.panel.Panel#title title}: &#39;Border Layout&#39;,
    {@link Ext.container.Container#layout layout}: &#39;border&#39;,
    {@link Ext.container.Container#items items}: [{
        {@link Ext.panel.Panel#title title}: &#39;South Region is resizable&#39;,
        region: &#39;south&#39;,     // position for region
        {@link Ext.AbstractComponent#height height}: 100,
        split: true,         // enable resizing
        margins: &#39;0 5 5 5&#39;
    },{
        // xtype: &#39;panel&#39; implied by default
        {@link Ext.panel.Panel#title title}: &#39;West Region is collapsible&#39;,
        region:&#39;west&#39;,
        margins: &#39;5 0 0 5&#39;,
        {@link Ext.AbstractComponent#width width}: 200,
        collapsible: true,   // make collapsible
        {@link Ext.Component#id id}: &#39;west-region-container&#39;,
        {@link Ext.container.Container#layout layout}: &#39;fit&#39;,
        {@link Ext.panel.Panel#unstyled unstyled}: true
    },{
        {@link Ext.panel.Panel#title title}: &#39;Center Region&#39;,
        region: &#39;center&#39;,     // center region is required, no width/height specified
        {@link Ext.Component#xtype xtype}: &#39;container&#39;,
        {@link Ext.container.Container#layout layout}: &#39;fit&#39;,
        margins: &#39;5 5 0 0&#39;
    }]
});
<br><span style="display: none">/**</span> * &lt;p&gt;&lt;b&gt;&lt;u&gt;Notes&lt;/u&gt;&lt;/b&gt;:&lt;/p&gt;&lt;div class=&quot;mdetail-params&quot;&gt;&lt;ul&gt;
 * &lt;li&gt;Any Container using the Border layout &lt;b&gt;must&lt;/b&gt; have a child item with &lt;code&gt;region:&#39;center&#39;&lt;/code&gt;.
 * The child item in the center region will always be resized to fill the remaining space not used by
 * the other regions in the layout.&lt;/li&gt;
 * &lt;li&gt;Any child items with a region of &lt;code&gt;west&lt;/code&gt; or &lt;code&gt;east&lt;/code&gt; may be configured with either
 * an initial &lt;code&gt;width&lt;/code&gt;, or a {@link Ext.layout.container.Box#flex} value, or an initial percentage width &lt;b&gt;string&lt;/b&gt; (Which is simply divided by 100 and used as a flex value). The &#39;center&#39; region has a flex value of &lt;code&gt;1&lt;/code&gt;.&lt;/li&gt;
 * &lt;li&gt;Any child items with a region of &lt;code&gt;north&lt;/code&gt; or &lt;code&gt;south&lt;/code&gt; may be configured with either
 * an initial &lt;code&gt;height&lt;/code&gt;, or a {@link Ext.layout.container.Box#flex} value, or an initial percentage height &lt;b&gt;string&lt;/b&gt; (Which is simply divided by 100 and used as a flex value). The &#39;center&#39; region has a flex value of &lt;code&gt;1&lt;/code&gt;.&lt;/li&gt;
 * &lt;li&gt;The regions of a BorderLayout are &lt;b&gt;fixed at render time&lt;/b&gt; and thereafter, its child Components may not be removed or added&lt;/b&gt;.To add/remove
 * Components within a BorderLayout, have them wrapped by an additional Container which is directly
 * managed by the BorderLayout.  If the region is to be collapsible, the Container used directly
 * by the BorderLayout manager should be a Panel.  In the following example a Container (an Ext.panel.Panel)
 * is added to the west region:<br><span style="display: none">**/</span>wrc = {@link Ext#getCmp Ext.getCmp}(&#39;west-region-container&#39;);
wrc.{@link Ext.container.Container#removeAll removeAll}();
wrc.{@link Ext.container.Container#add add}({
    title: &#39;Added Panel&#39;,
    html: &#39;Some content&#39;
});
 * <br><span style="display: none">/**</span> * &lt;/li&gt;
 * &lt;li&gt;&lt;b&gt;There is no BorderLayout.Region class in ExtJS 4.0+&lt;/b&gt;&lt;/li&gt;
 * &lt;/ul&gt;&lt;/div&gt;
 */
Ext.define(&#39;Ext.layout.container.Border&#39;, {

    alias: [&#39;layout.border&#39;],
    extend: &#39;Ext.layout.Container&#39;,
    requires: [&#39;Ext.resizer.Splitter&#39;, &#39;Ext.container.Container&#39;, &#39;Ext.fx.Anim&#39;],
    alternateClassName: &#39;Ext.layout.BorderLayout&#39;,

    targetCls: Ext.baseCSSPrefix + &#39;border-layout-ct&#39;,

    itemCls: Ext.baseCSSPrefix + &#39;border-item&#39;,

    bindToOwnerCtContainer: true,

    fixedLayout: false,

    percentageRe: /(\d+)%/,

    slideDirection: {
        north: &#39;t&#39;,
        south: &#39;b&#39;,
        west: &#39;l&#39;,
        east: &#39;r&#39;
    },

    constructor: function(config) {
        this.initialConfig = config;
        this.callParent(arguments);
    },

    onLayout: function() {
        var me = this;
        if (!me.borderLayoutInitialized) {
            me.initializeBorderLayout();
        }

        // Delegate this operation to the shadow &quot;V&quot; or &quot;H&quot; box layout, and then down to any embedded layout.
        me.shadowLayout.onLayout();
        if (me.embeddedContainer) {
            me.embeddedContainer.layout.onLayout();
        }

        // If the panel was originally configured with collapsed: true, it will have
        // been initialized with a &quot;borderCollapse&quot; flag: Collapse it now before the first layout.
        if (!me.initialCollapsedComplete) {
            Ext.iterate(me.regions, function(name, region){
                if (region.borderCollapse) {
                    me.onBeforeRegionCollapse(region, region.collapseDirection, false, 0);
                }
            });
            me.initialCollapsedComplete = true;
        }
    },

    isValidParent : function(item, target, position) {
        if (!this.borderLayoutInitialized) {
            this.initializeBorderLayout();
        }

        // Delegate this operation to the shadow &quot;V&quot; or &quot;H&quot; box layout.
        return this.shadowLayout.isValidParent(item, target, position);
    },

    beforeLayout: function() {
        if (!this.borderLayoutInitialized) {
            this.initializeBorderLayout();
        }

        // Delegate this operation to the shadow &quot;V&quot; or &quot;H&quot; box layout.
        this.shadowLayout.beforeLayout();
    },

    renderItems: function(items, target) {
        throw &#39;This should not be called&#39;;
    },

    renderItem: function(item) {
        throw &#39;This should not be called&#39;;
    },

    initializeBorderLayout: function() {
        var me = this,
            i = 0,
            items = me.getLayoutItems(),
            ln = items.length,
            regions = (me.regions = {}),
            vBoxItems = [],
            hBoxItems = [],
            horizontalFlex = 0,
            verticalFlex = 0,
            comp, percentage;

        // Map of Splitters for each region
        me.splitters = {};

        // Map of regions
        for (; i &lt; ln; i++) {
            comp = items[i];
            regions[comp.region] = comp;

            // Intercept collapsing to implement showing an alternate Component as a collapsed placeHolder
            if (comp.region != &#39;center&#39; &amp;&amp; comp.collapsible &amp;&amp; comp.collapseMode != &#39;header&#39;) {

                // This layout intercepts any initial collapsed state. Panel must not do this itself.
                comp.borderCollapse = comp.collapsed;
                delete comp.collapsed;

                comp.on({
                    beforecollapse: me.onBeforeRegionCollapse,
                    beforeexpand: me.onBeforeRegionExpand,
                    destroy: me.onRegionDestroy,
                    scope: me
                });
                me.setupState(comp);
            }
        }
        if (!regions.center) {
            throw &quot;No center region defined in BorderLayout.&quot;;
        }
        comp = regions.center;
        if (!comp.flex) {
            comp.flex = 1;
        }
        delete comp.width;
        comp.maintainFlex = true;

        // Begin the VBox and HBox item list.
        comp = regions.west;
        if (comp) {
            comp.collapseDirection = Ext.Component.DIRECTION_LEFT;
            hBoxItems.push(comp);
            if (comp.split) {
                hBoxItems.push(me.splitters.west = me.createSplitter(comp));
            }
            percentage = Ext.isString(comp.width) &amp;&amp; comp.width.match(me.percentageRe);
            if (percentage) {
                horizontalFlex += (comp.flex = parseInt(percentage[1], 10) / 100);
                delete comp.width;
            }
        }
        comp = regions.north;
        if (comp) {
            comp.collapseDirection = Ext.Component.DIRECTION_TOP;
            vBoxItems.push(comp);
            if (comp.split) {
                vBoxItems.push(me.splitters.north = me.createSplitter(comp));
            }
            percentage = Ext.isString(comp.height) &amp;&amp; comp.height.match(me.percentageRe);
            if (percentage) {
                verticalFlex += (comp.flex = parseInt(percentage[1], 10) / 100);
                delete comp.height;
            }
        }

        // Decide into which Collection the center region goes.
        if (regions.north || regions.south) {
            if (regions.east || regions.west) {

                // Create the embedded center. Mark it with the region: &#39;center&#39; property so that it can be identified as the center.
                vBoxItems.push(me.embeddedContainer = new Ext.container.Container({
                    xtype: &#39;container&#39;,
                    region: &#39;center&#39;,
                    id: me.owner.id + &#39;-embedded-center&#39;,
                    cls: Ext.baseCSSPrefix + &#39;border-item&#39;,
                    flex: regions.center.flex,
                    maintainFlex: true,
                    layout: {
                        type: &#39;hbox&#39;,
                        align: &#39;stretch&#39;
                    }
                }));
                hBoxItems.push(regions.center);
            }
            // No east or west: the original center goes straight into the vbox
            else {
                vBoxItems.push(regions.center);
            }
        }
        // If we have no north or south, then the center is part of the HBox items
        else {
            hBoxItems.push(regions.center);
        }

        // Finish off the VBox and HBox item list.
        comp = regions.south;
        if (comp) {
            comp.collapseDirection = Ext.Component.DIRECTION_BOTTOM;
            if (comp.split) {
                vBoxItems.push(me.splitters.south = me.createSplitter(comp));
            }
            percentage = Ext.isString(comp.height) &amp;&amp; comp.height.match(me.percentageRe);
            if (percentage) {
                verticalFlex += (comp.flex = parseInt(percentage[1], 10) / 100);
                delete comp.height;
            }
            vBoxItems.push(comp);
        }
        comp = regions.east;
        if (comp) {
            comp.collapseDirection = Ext.Component.DIRECTION_RIGHT;
            if (comp.split) {
                hBoxItems.push(me.splitters.east = me.createSplitter(comp));
            }
            percentage = Ext.isString(comp.width) &amp;&amp; comp.width.match(me.percentageRe);
            if (percentage) {
                horizontalFlex += (comp.flex = parseInt(percentage[1], 10) / 100);
                delete comp.width;
            }
            hBoxItems.push(comp);
        }

        // Create the injected &quot;items&quot; collections for the Containers.
        // If we have north or south, then the shadow Container will be a VBox.
        // If there are also east or west regions, its center will be a shadow HBox.
        // If there are *only* east or west regions, then the shadow layout will be an HBox (or Fit).
        if (regions.north || regions.south) {

            me.shadowContainer = new Ext.container.Container({
                ownerCt: me.owner,
                el: me.getTarget(),
                layout: Ext.applyIf({
                    type: &#39;vbox&#39;,
                    align: &#39;stretch&#39;
                }, me.initialConfig)
            });
            me.createItems(me.shadowContainer, vBoxItems);

            // Allow the Splitters to orientate themselves
            if (me.splitters.north) {
                me.splitters.north.ownerCt = me.shadowContainer;
            }
            if (me.splitters.south) {
                me.splitters.south.ownerCt = me.shadowContainer;
            }

            // Inject items into the HBox Container if there is one - if there was an east or west.
            if (me.embeddedContainer) {
                me.embeddedContainer.ownerCt = me.shadowContainer;
                me.createItems(me.embeddedContainer, hBoxItems);

                // Allow the Splitters to orientate themselves
                if (me.splitters.east) {
                    me.splitters.east.ownerCt = me.embeddedContainer;
                }
                if (me.splitters.west) {
                    me.splitters.west.ownerCt = me.embeddedContainer;
                }

                // The east or west region wanted a percentage
                if (horizontalFlex) {
                    regions.center.flex -= horizontalFlex;
                }
                // The north or south region wanted a percentage
                if (verticalFlex) {
                    me.embeddedContainer.flex -= verticalFlex;
                }
            } else {
                // The north or south region wanted a percentage
                if (verticalFlex) {
                    regions.center.flex -= verticalFlex;
                }
            }
        }
        // If we have no north or south, then there&#39;s only one Container, and it&#39;s
        // an HBox, or, if only a center region was specified, a Fit.
        else {
            me.shadowContainer = new Ext.container.Container({
                ownerCt: me.owner,
                el: me.getTarget(),
                layout: Ext.applyIf({
                    type: (hBoxItems.length == 1) ? &#39;fit&#39; : &#39;hbox&#39;,
                    align: &#39;stretch&#39;
                }, me.initialConfig)
            });
            me.createItems(me.shadowContainer, hBoxItems);

            // Allow the Splitters to orientate themselves
            if (me.splitters.east) {
                me.splitters.east.ownerCt = me.shadowContainer;
            }
            if (me.splitters.west) {
                me.splitters.west.ownerCt = me.shadowContainer;
            }

            // The east or west region wanted a percentage
            if (horizontalFlex) {
                regions.center.flex -= verticalFlex;
            }
        }

        // Create upward links from the region Components to their shadow ownerCts
        for (i = 0, items = me.shadowContainer.items.items, ln = items.length; i &lt; ln; i++) {
            items[i].shadowOwnerCt = me.shadowContainer;
        }
        if (me.embeddedContainer) {
            for (i = 0, items = me.embeddedContainer.items.items, ln = items.length; i &lt; ln; i++) {
                items[i].shadowOwnerCt = me.embeddedContainer;
            }
        }

        // This is the layout that we delegate all operations to
        me.shadowLayout = me.shadowContainer.getLayout();

        me.borderLayoutInitialized = true;
    },
    
    
    setupState: function(comp){
        var getState = comp.getState;
        comp.getState = function(){
            // call the original getState
            var state = getState.call(comp) || {},
                region = comp.region;
                
            state.collapsed = !!comp.collapsed;
            if (region == &#39;west&#39; || region == &#39;east&#39;) {
                state.width = comp.getWidth();
            } else {
                state.height = comp.getHeight();
            }
            return state;
        };
        comp.addStateEvents([&#39;collapse&#39;, &#39;expand&#39;, &#39;resize&#39;]);
    },
    
    /**
     * Create the items collection for our shadow/embedded containers
     * @private
     */
    createItems: function(container, items){
        // Have to inject an items Collection *after* construction.
        // The child items of the shadow layout must retain their original, user-defined ownerCt
        delete container.items;
        container.initItems();
        container.items.addAll(items);
    },

    // Private
    // Create a splitter for a child of the layout.
    createSplitter: function(comp) {
        var me = this,
            interceptCollapse = (comp.collapseMode != &#39;header&#39;),
            resizer;

        resizer = new Ext.resizer.Splitter({
            hidden: !!comp.hidden,
            collapseTarget: comp,
            performCollapse: !interceptCollapse,
            listeners: interceptCollapse ? {
                click: {
                    fn: Ext.Function.bind(me.onSplitterCollapseClick, me, [comp]),
                    element: &#39;collapseEl&#39;
                }
            } : null
        });

        // Mini collapse means that the splitter is the placeholder Component
        if (comp.collapseMode == &#39;mini&#39;) {
            comp.placeHolder = resizer;
        }

        // Arrange to hide/show a region&#39;s associated splitter when the region is hidden/shown
        comp.on({
            hide: me.onRegionVisibilityChange,
            show: me.onRegionVisibilityChange,
            scope: me
        });
        return resizer;
    },

    // Hide/show a region&#39;s associated splitter when the region is hidden/shown
    onRegionVisibilityChange: function(comp){
        this.splitters[comp.region][comp.hidden ? &#39;hide&#39; : &#39;show&#39;]();
        this.layout();
    },

    // Called when a splitter mini-collapse tool is clicked on.
    // The listener is only added if this layout is controlling collapsing,
    // not if the component&#39;s collapseMode is &#39;mini&#39; or &#39;header&#39;.
    onSplitterCollapseClick: function(comp) {
        if (comp.collapsed) {
            this.onPlaceHolderToolClick(null, null, null, {client: comp});
        } else {
            comp.collapse();
        }
    },

    <a name="method-Ext.layout.container.Border-getPlaceHolder"></a>/**
     * &lt;p&gt;Return the {@link Ext.panel.Panel#placeHolder placeHolder} Component to which the passed child Panel of the layout will collapse.
     * By default, this will be a {@link Ext.panel.Header Header} component (Docked to the appropriate border). See {@link Ext.panel.Panel#placeHolder placeHolder}.
     * config to customize this.&lt;/p&gt;
     * &lt;p&gt;&lt;b&gt;Note that this will be a fully instantiated Component, but will only be &lt;i&gt;rendered&lt;/i&gt; when the Panel is first collapsed.&lt;/b&gt;&lt;/p&gt;
     * @param {Panel} panel The child Panel of the layout for which to return the {@link Ext.panel.Panel#placeHolder placeHolder}.
     * @returns {Component} The Panel&#39;s {@link Ext.panel.Panel#placeHolder placeHolder} unless the {@link Ext.panel.Panel#collapseMode collapseMode} is
     * &lt;code&gt;&#39;header&#39;&lt;/code&gt;, in which case &lt;i&gt;undefined&lt;/i&gt; is returned.
     */
    getPlaceHolder: function(comp) {
        var me = this,
            placeHolder = comp.placeHolder,
            shadowContainer = comp.shadowOwnerCt,
            shadowLayout = shadowContainer.layout,
            oppositeDirection = Ext.panel.Panel.prototype.getOppositeDirection(comp.collapseDirection),
            horiz = (comp.region == &#39;north&#39; || comp.region == &#39;south&#39;);

        // No placeHolder if the collapse mode is not the Border layout default
        if (comp.collapseMode == &#39;header&#39;) {
            return;
        }

        // Provide a replacement Container with an expand tool
        if (!placeHolder) {
            if (comp.collapseMode == &#39;mini&#39;) {
                placeHolder = new Ext.resizer.Splitter({
                    id: &#39;collapse-placeholder-&#39; + comp.id,
                    collapseTarget: comp,
                    performCollapse: false,
                    listeners: {
                        click: {
                            fn: Ext.Function.bind(me.onSplitterCollapseClick, me, [comp]),
                            element: &#39;collapseEl&#39;
                        }
                    }
                });
                placeHolder.addCls(placeHolder.collapsedCls);
            } else {
                placeHolder = {
                    id: &#39;collapse-placeholder-&#39; + comp.id,
                    margins: comp.initialConfig.margins,
                    xtype: &#39;header&#39;,
                    orientation: horiz ? &#39;horizontal&#39; : &#39;vertical&#39;,
                    title: comp.title,
                    textCls: comp.headerTextCls,
                    iconCls: comp.iconCls,
                    baseCls: comp.baseCls + &#39;-header&#39;,
                    ui: comp.ui,
                    indicateDrag: comp.draggable,
                    cls: Ext.baseCSSPrefix + &#39;region-collapsed-placeholder &#39; + Ext.baseCSSPrefix + &#39;region-collapsed-&#39; + comp.collapseDirection + &#39;-placeholder&#39;,
                    listeners: comp.floatable ? {
                        click: {
                            fn: function(e) {
                                me.floatCollapsedPanel(e, comp);
                            },
                            element: &#39;el&#39;
                        }
                    } : null
                };
                // Hack for IE6/7/IEQuirks&#39;s inability to display an inline-block
                if ((Ext.isIE6 || Ext.isIE7 || (Ext.isIEQuirks)) &amp;&amp; !horiz) {
                    placeHolder.width = 25;
                }
                placeHolder[horiz ? &#39;tools&#39; : &#39;items&#39;] = [{
                    xtype: &#39;tool&#39;,
                    client: comp,
                    type: &#39;expand-&#39; + oppositeDirection,
                    handler: me.onPlaceHolderToolClick,
                    scope: me
                }];
            }
            placeHolder = me.owner.createComponent(placeHolder);
        }

        // The collapsed Component holds a reference to its placeHolder and vice versa
        comp.placeHolder = placeHolder;
        placeHolder.comp = comp;

        return placeHolder;
    },

    /**
     * @private
     * Calculates the size and positioning of the passed child item. Must be present because Panel&#39;s expand,
     * when configured with a flex, calls this method on its ownerCt&#39;s layout.
     * @param {Component} child The child Component to calculate the box for
     * @return {Object} Object containing box measurements for the child. Properties are left,top,width,height.
     */
    calculateChildBox: function(comp) {
        var me = this;
        if (me.shadowContainer.items.contains(comp)) {
            return me.shadowContainer.layout.calculateChildBox(comp);
        }
        else if (me.embeddedContainer &amp;&amp; me.embeddedContainer.items.contains(comp)) {
            return me.embeddedContainer.layout.calculateChildBox(comp);
        }
    },

    /**
     * @private
     * Intercepts the Panel&#39;s own collapse event and perform&#39;s substitution of the Panel
     * with a placeholder Header orientated in the appropriate dimension.
     * @param comp The Panel being collapsed.
     * @param direction
     * @param animate
     * @returns {Boolean} false to inhibit the Panel from performing its own collapse.
     */
    onBeforeRegionCollapse: function(comp, direction, animate) {
        var me = this,
            compEl = comp.el,
            miniCollapse = comp.collapseMode == &#39;mini&#39;,
            shadowContainer = comp.shadowOwnerCt,
            shadowLayout = shadowContainer.layout,
            centerComp = shadowContainer.child(&#39;[region=center]&#39;),
            placeHolder = comp.placeHolder,
            placeHolderBox,
            targetSize = shadowLayout.getLayoutTargetSize(),
            sl = me.owner.suspendLayout,
            scsl = shadowContainer.suspendLayout,
            isNorthOrWest = (comp.region == &#39;north&#39; || comp.region == &#39;west&#39;); // Flag to keep the placeHolder non-adjacent to any Splitter

        // Do not trigger a layout during transition to collapsed Component
        me.owner.suspendLayout = true;
        shadowContainer.suspendLayout = true;

        // Prevent upward notifications from downstream layouts
        shadowLayout.layoutBusy = true;
        if (shadowContainer.componentLayout) {
            shadowContainer.componentLayout.layoutBusy = true;
        }
        me.shadowContainer.layout.layoutBusy = true;
        me.layoutBusy = true;
        me.owner.componentLayout.layoutBusy = true;

        // Provide a replacement Container with an expand tool
        if (!placeHolder) {
            placeHolder = me.getPlaceHolder(comp);
        }

        // placeHolder already in place; show it.
        if (placeHolder.shadowOwnerCt === shadowContainer) {
            placeHolder.show();
        }
        // Insert the collapsed placeHolder Component into the appropriate Box layout shadow Container
        // It must go next to its client Component, but non-adjacent to the splitter so splitter can find its collapse client.
        // Inject an ownerCt value pointing to the owner, border layout Container as the user will expect.
        else {
            shadowContainer.insert(shadowContainer.items.indexOf(comp) + (isNorthOrWest ? 0 : 1), placeHolder);
            placeHolder.shadowOwnerCt = shadowContainer;
            placeHolder.ownerCt = me.owner;
        }

        // Flag the collapsing Component as hidden and show the placeHolder.
        // This causes the shadow Box layout&#39;s calculateChildBoxes to calculate the correct new arrangement.
        // We hide or slideOut the Component&#39;s element
        comp.hidden = true;

        if (!placeHolder.rendered) {
            shadowLayout.renderItem(placeHolder, shadowLayout.innerCt);
        }

        // Jobs to be done after the collapse has been done
        function afterCollapse() {

            // Reinstate automatic laying out.
            me.owner.suspendLayout = sl;
            shadowContainer.suspendLayout = scsl;
            delete shadowLayout.layoutBusy;
            if (shadowContainer.componentLayout) {
                delete shadowContainer.componentLayout.layoutBusy;
            }
            delete me.shadowContainer.layout.layoutBusy;
            delete me.layoutBusy;
            delete me.owner.componentLayout.layoutBusy;

            // Fire the collapse event: The Panel has in fact been collapsed, but by substitution of an alternative Component
            comp.collapsed = true;
            comp.fireEvent(&#39;collapse&#39;, comp);
        }

        /*
         * Set everything to the new positions. Note that we
         * only want to animate the collapse if it wasn&#39;t configured
         * initially with collapsed: true
         */
        if (comp.animCollapse &amp;&amp; me.initialCollapsedComplete) {
            shadowLayout.layout();
            compEl.dom.style.zIndex = 100;

            // If we&#39;re mini-collapsing, the placholder is a Splitter. We don&#39;t want it to &quot;bounce in&quot;
            if (!miniCollapse) {
                placeHolder.el.hide();
            }
            compEl.slideOut(me.slideDirection[comp.region], {
                duration: Ext.num(comp.animCollapse, Ext.fx.Anim.prototype.duration),
                listeners: {
                    afteranimate: function() {
                        compEl.show().setLeftTop(-10000, -10000);
                        compEl.dom.style.zIndex = &#39;&#39;;

                        // If we&#39;re mini-collapsing, the placholder is a Splitter. We don&#39;t want it to &quot;bounce in&quot;
                       if (!miniCollapse) {
                            placeHolder.el.slideIn(me.slideDirection[comp.region], {
                                easing: &#39;linear&#39;,
                                duration: 100
                            });
                        }
                        afterCollapse();
                    }
                }
            });
        } else {
            compEl.setLeftTop(-10000, -10000);
            shadowLayout.layout();
            afterCollapse();
        }

        return false;
    },

    // Hijack the expand operation to remove the placeholder and slide the region back in.
    onBeforeRegionExpand: function(comp, animate) {
        this.onPlaceHolderToolClick(null, null, null, {client: comp});
        return false;
    },

    // Called when the collapsed placeHolder is clicked to reinstate a &quot;collapsed&quot; (in reality hidden) Panel.
    onPlaceHolderToolClick: function(e, target, owner, tool) {
        var me = this,
            comp = tool.client,

            // Hide the placeholder unless it was the Component&#39;s preexisting splitter
            hidePlaceholder = (comp.collapseMode != &#39;mini&#39;) || !comp.split,
            compEl = comp.el,
            toCompBox,
            placeHolder = comp.placeHolder,
            placeHolderEl = placeHolder.el,
            shadowContainer = comp.shadowOwnerCt,
            shadowLayout = shadowContainer.layout,
            curSize,
            sl = me.owner.suspendLayout,
            scsl = shadowContainer.suspendLayout,
            isFloating;

        // If the slide in is still going, stop it.
        // This will either leave the Component in its fully floated state (which is processed below)
        // or in its collapsed state. Either way, we expand it..
        if (comp.hasActiveFx()) {
            comp.stopFx();
        }

        // If the Component is fully floated when they click the placeHolder Tool,
        // it will be primed with a slide out animation object... so delete that
        // and remove the mouseout listeners
        if (comp.slideOutAnim) {
            // Remove mouse leave monitors
            compEl.un(comp.panelMouseMon);
            placeHolderEl.un(comp.placeHolderMouseMon);

            delete comp.slideOutAnim;
            delete comp.panelMouseMon;
            delete comp.placeHolderMouseMon;

            // If the Panel was floated and primed with a slideOut animation, we don&#39;t want to animate its layout operation.
            isFloating = true;
        }

        // Do not trigger a layout during transition to expanded Component
        me.owner.suspendLayout = true;
        shadowContainer.suspendLayout = true;

        // Prevent upward notifications from downstream layouts
        shadowLayout.layoutBusy = true;
        if (shadowContainer.componentLayout) {
            shadowContainer.componentLayout.layoutBusy = true;
        }
        me.shadowContainer.layout.layoutBusy = true;
        me.layoutBusy = true;
        me.owner.componentLayout.layoutBusy = true;

        // Unset the hidden and collapsed flags set in onBeforeRegionCollapse. The shadowLayout will now take it into account
        // Find where the shadow Box layout plans to put the expanding Component.
        comp.hidden = false;
        comp.collapsed = false;
        if (hidePlaceholder) {
            placeHolder.hidden = true;
        }
        toCompBox = shadowLayout.calculateChildBox(comp);

        // Show the collapse tool in case it was hidden by the slide-in
        if (comp.collapseTool) {
            comp.collapseTool.show();
        }

        // If we&#39;re going to animate, we need to hide the component before moving it back into position
        if (comp.animCollapse &amp;&amp; !isFloating) {
            compEl.setStyle(&#39;visibility&#39;, &#39;hidden&#39;);
        }
        compEl.setLeftTop(toCompBox.left, toCompBox.top);

        // Equalize the size of the expanding Component prior to animation
        // in case the layout area has changed size during the time it was collapsed.
        curSize = comp.getSize();
        if (curSize.height != toCompBox.height || curSize.width != toCompBox.width) {
            me.setItemSize(comp, toCompBox.width, toCompBox.height);
        }

        // Jobs to be done after the expand has been done
        function afterExpand() {
            // Reinstate automatic laying out.
            me.owner.suspendLayout = sl;
            shadowContainer.suspendLayout = scsl;
            delete shadowLayout.layoutBusy;
            if (shadowContainer.componentLayout) {
                delete shadowContainer.componentLayout.layoutBusy;
            }
            delete me.shadowContainer.layout.layoutBusy;
            delete me.layoutBusy;
            delete me.owner.componentLayout.layoutBusy;

            // In case it was floated out and they clicked the re-expand tool
            comp.removeCls(Ext.baseCSSPrefix + &#39;border-region-slide-in&#39;);

            // Fire the expand event: The Panel has in fact been expanded, but by removal of an alternative Component
            comp.fireEvent(&#39;expand&#39;, comp);
        }

        // Hide the placeholder
        if (hidePlaceholder) {
            placeHolder.el.hide();
        }

        // Slide the expanding Component to its new position.
        // When that is done, layout the layout.
        if (comp.animCollapse &amp;&amp; !isFloating) {
            compEl.dom.style.zIndex = 100;
            compEl.slideIn(me.slideDirection[comp.region], {
                duration: Ext.num(comp.animCollapse, Ext.fx.Anim.prototype.duration),
                listeners: {
                    afteranimate: function() {
                        compEl.dom.style.zIndex = &#39;&#39;;
                        comp.hidden = false;
                        shadowLayout.onLayout();
                        afterExpand();
                    }
                }
            });
        } else {
            shadowLayout.onLayout();
            afterExpand();
        }
    },

    floatCollapsedPanel: function(e, comp) {

        if (comp.floatable === false) {
            return;
        }

        var me = this,
            compEl = comp.el,
            placeHolder = comp.placeHolder,
            placeHolderEl = placeHolder.el,
            shadowContainer = comp.shadowOwnerCt,
            shadowLayout = shadowContainer.layout,
            placeHolderBox = shadowLayout.getChildBox(placeHolder),
            scsl = shadowContainer.suspendLayout,
            curSize, toCompBox, compAnim;

        // Ignore clicks on tools.
        if (e.getTarget(&#39;.&#39; + Ext.baseCSSPrefix + &#39;tool&#39;)) {
            return;
        }

        // It&#39;s *being* animated, ignore the click.
        // Possible future enhancement: Stop and *reverse* the current active Fx.
        if (compEl.hasActiveFx()) {
            return;
        }

        // If the Component is already fully floated when they click the placeHolder,
        // it will be primed with a slide out animation object... so slide it out.
        if (comp.slideOutAnim) {
            me.slideOutFloatedComponent(comp);
            return;
        }

        // Function to be called when the mouse leaves the floated Panel
        // Slide out when the mouse leaves the region bounded by the slid Component and its placeHolder.
        function onMouseLeaveFloated(e) {
            var slideRegion = compEl.getRegion().union(placeHolderEl.getRegion()).adjust(1, -1, -1, 1);

            // If mouse is not within slide Region, slide it out
            if (!slideRegion.contains(e.getPoint())) {
                me.slideOutFloatedComponent(comp);
            }
        }

        // Do not trigger a layout during slide out of the Component
        shadowContainer.suspendLayout = true;

        // Prevent upward notifications from downstream layouts
        me.layoutBusy = true;
        me.owner.componentLayout.layoutBusy = true;

        // The collapse tool is hidden while slid.
        // It is re-shown on expand.
        if (comp.collapseTool) {
            comp.collapseTool.hide();
        }

        // Set flags so that the layout will calculate the boxes for what we want
        comp.hidden = false;
        comp.collapsed = false;
        placeHolder.hidden = true;

        // Recalculate new arrangement of the Component being floated.
        toCompBox = shadowLayout.calculateChildBox(comp);
        placeHolder.hidden = false;

        // Component to appear just after the placeholder, whatever &quot;after&quot; means in the context of the shadow Box layout.
        if (comp.region == &#39;north&#39; || comp.region == &#39;west&#39;) {
            toCompBox[shadowLayout.parallelBefore] += placeHolderBox[shadowLayout.parallelPrefix] - 1;
        } else {
            toCompBox[shadowLayout.parallelBefore] -= (placeHolderBox[shadowLayout.parallelPrefix] - 1);
        }
        compEl.setStyle(&#39;visibility&#39;, &#39;hidden&#39;);
        compEl.setLeftTop(toCompBox.left, toCompBox.top);

        // Equalize the size of the expanding Component prior to animation
        // in case the layout area has changed size during the time it was collapsed.
        curSize = comp.getSize();
        if (curSize.height != toCompBox.height || curSize.width != toCompBox.width) {
            me.setItemSize(comp, toCompBox.width, toCompBox.height);
        }

        // This animation slides the collapsed Component&#39;s el out to just beyond its placeHolder
        compAnim = {
            listeners: {
                afteranimate: function() {
                    shadowContainer.suspendLayout = scsl;
                    delete me.layoutBusy;
                    delete me.owner.componentLayout.layoutBusy;

                    // Prime the Component with an Anim config object to slide it back out
                    compAnim.listeners = {
                        afterAnimate: function() {
                            compEl.show().removeCls(Ext.baseCSSPrefix + &#39;border-region-slide-in&#39;).setLeftTop(-10000, -10000);

                            // Reinstate the correct, current state after slide out animation finishes
                            comp.hidden = true;
                            comp.collapsed = true;
                            delete comp.slideOutAnim;
                            delete comp.panelMouseMon;
                            delete comp.placeHolderMouseMon;
                        }
                    };
                    comp.slideOutAnim = compAnim;
                }
            },
            duration: 500
        };

        // Give the element the correct class which places it at a high z-index
        compEl.addCls(Ext.baseCSSPrefix + &#39;border-region-slide-in&#39;);

        // Begin the slide in
        compEl.slideIn(me.slideDirection[comp.region], compAnim);

        // Monitor for mouseouting of the slid area. Hide it is they exit for half a second or more
        comp.panelMouseMon = compEl.monitorMouseLeave(500, onMouseLeaveFloated);
        comp.placeHolderMouseMon = placeHolderEl.monitorMouseLeave(500, onMouseLeaveFloated);

    },

    slideOutFloatedComponent: function(comp) {
        var compEl = comp.el,
            slideOutAnim;

        // Remove mouse leave monitors
        compEl.un(comp.panelMouseMon);
        comp.placeHolder.el.un(comp.placeHolderMouseMon);

        // Slide the Component out
        compEl.slideOut(this.slideDirection[comp.region], comp.slideOutAnim);

        delete comp.slideOutAnim;
        delete comp.panelMouseMon;
        delete comp.placeHolderMouseMon;
    },

    /*
     * @private
     * Ensure any collapsed placeHolder Component is destroyed along with its region.
     * Can&#39;t do this in onDestroy because they may remove a Component and use it elsewhere.
     */
    onRegionDestroy: function(comp) {
        var placeHolder = comp.placeHolder;
        if (placeHolder) {
            delete placeHolder.ownerCt;
            placeHolder.destroy();
        }
    },

    /*
     * @private
     * Ensure any shadow Containers are destroyed.
     * Ensure we don&#39;t keep references to Components.
     */
    onDestroy: function() {
        var me = this,
            shadowContainer = me.shadowContainer,
            embeddedContainer = me.embeddedContainer;

        if (shadowContainer) {
            delete shadowContainer.ownerCt;
            Ext.destroy(shadowContainer);
        }

        if (embeddedContainer) {
            delete embeddedContainer.ownerCt;
            Ext.destroy(embeddedContainer);
        }
        delete me.regions;
        delete me.splitters;
        delete me.shadowContainer;
        delete me.embeddedContainer;
        me.callParent(arguments);
    }
});
￿</pre></pre></body></html>