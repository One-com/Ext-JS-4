<!DOCTYPE html><html><head><title>Sencha Documentation Project</title><link rel="stylesheet" href="../reset.css" type="text/css"><link rel="stylesheet" href="../prettify.css" type="text/css"><link rel="stylesheet" href="../prettify_sa.css" type="text/css"><script type="text/javascript" src="../prettify.js"></script></head><body onload="prettyPrint()"><pre class="prettyprint"><pre>/**
 * @class Ext.core.Element
 */
(function(){
    Ext.core.Element.boxMarkup = &#39;&lt;div class=&quot;{0}-tl&quot;&gt;&lt;div class=&quot;{0}-tr&quot;&gt;&lt;div class=&quot;{0}-tc&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;{0}-ml&quot;&gt;&lt;div class=&quot;{0}-mr&quot;&gt;&lt;div class=&quot;{0}-mc&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;{0}-bl&quot;&gt;&lt;div class=&quot;{0}-br&quot;&gt;&lt;div class=&quot;{0}-bc&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&#39;;
    // local style camelizing for speed
    var supports = Ext.supports,
        view = document.defaultView,
        opacityRe = /alpha\(opacity=(.*)\)/i,
        trimRe = /^\s+|\s+$/g,
        spacesRe = /\s+/,
        wordsRe = /\w/g,
        INTERNAL = &#39;_internal&#39;,
        PADDING = &#39;padding&#39;,
        MARGIN = &#39;margin&#39;,
        BORDER = &#39;border&#39;,
        LEFT = &#39;-left&#39;,
        RIGHT = &#39;-right&#39;,
        TOP = &#39;-top&#39;,
        BOTTOM = &#39;-bottom&#39;,
        WIDTH = &#39;-width&#39;,
        MATH = Math,
        HIDDEN = &#39;hidden&#39;,
        ISCLIPPED = &#39;isClipped&#39;,
        OVERFLOW = &#39;overflow&#39;,
        OVERFLOWX = &#39;overflow-x&#39;,
        OVERFLOWY = &#39;overflow-y&#39;,
        ORIGINALCLIP = &#39;originalClip&#39;,
        // special markup used throughout Ext when box wrapping elements
        borders = {l: BORDER + LEFT + WIDTH, r: BORDER + RIGHT + WIDTH, t: BORDER + TOP + WIDTH, b: BORDER + BOTTOM + WIDTH},
        paddings = {l: PADDING + LEFT, r: PADDING + RIGHT, t: PADDING + TOP, b: PADDING + BOTTOM},
        margins = {l: MARGIN + LEFT, r: MARGIN + RIGHT, t: MARGIN + TOP, b: MARGIN + BOTTOM},
        data = Ext.core.Element.data;

    Ext.override(Ext.core.Element, {
        
        <a name="prop-Ext.core.Element-private"></a>/**
         * TODO: Look at this
         */
        // private  ==&gt; used by Fx
        adjustWidth : function(width) {
            var me = this,
                isNum = (typeof width == &#39;number&#39;);
                
            if(isNum &amp;&amp; me.autoBoxAdjust &amp;&amp; !me.isBorderBox()){
               width -= (me.getBorderWidth(&quot;lr&quot;) + me.getPadding(&quot;lr&quot;));
            }
            return (isNum &amp;&amp; width &lt; 0) ? 0 : width;
        },

        // private   ==&gt; used by Fx
        adjustHeight : function(height) {
            var me = this,
                isNum = (typeof height == &quot;number&quot;);
                
            if(isNum &amp;&amp; me.autoBoxAdjust &amp;&amp; !me.isBorderBox()){
               height -= (me.getBorderWidth(&quot;tb&quot;) + me.getPadding(&quot;tb&quot;));
            }
            return (isNum &amp;&amp; height &lt; 0) ? 0 : height;
        },


        <a name="method-Ext.core.Element-addCls"></a>/**
         * Adds one or more CSS classes to the element. Duplicate classes are automatically filtered out.
         * @param {String/Array} className The CSS classes to add separated by space, or an array of classes
         * @return {Ext.core.Element} this
         */
        addCls : function(className){
            var me = this,
                cls = [],
                space = ((me.dom.className.replace(trimRe, &#39;&#39;) == &#39;&#39;) ? &quot;&quot; : &quot; &quot;),
                i, len, v;
            if (!Ext.isDefined(className)) {
                return me;
            }
            // Separate case is for speed
            if (!Ext.isArray(className)) {
                if (typeof className === &#39;string&#39;) {
                    className = className.replace(trimRe, &#39;&#39;).split(spacesRe);
                    if (className.length === 1) {
                        className = className[0];
                        if (!me.hasCls(className)) {
                            me.dom.className += space + className;
                        }
                    } else {
                        this.addCls(className);
                    }
                }
            } else {
                for (i = 0, len = className.length; i &lt; len; i++) {
                    v = className[i];
                    if (typeof v == &#39;string&#39; &amp;&amp; (&#39; &#39; + me.dom.className + &#39; &#39;).indexOf(&#39; &#39; + v + &#39; &#39;) == -1) {
                        cls.push(v);
                    }
                }
                if (cls.length) {
                    me.dom.className += space + cls.join(&quot; &quot;);
                }
            }
            return me;
        },

        <a name="method-Ext.core.Element-removeCls"></a>/**
         * Removes one or more CSS classes from the element.
         * @param {String/Array} className The CSS classes to remove separated by space, or an array of classes
         * @return {Ext.core.Element} this
         */
        removeCls : function(className){
            var me = this,
                i, idx, len, cls, elClasses;
            if (!Ext.isDefined(className)) {
                return me;
            }
            if (!Ext.isArray(className)){
                className = className.replace(trimRe, &#39;&#39;).split(spacesRe);
            }
            if (me.dom &amp;&amp; me.dom.className) {
                elClasses = me.dom.className.replace(trimRe, &#39;&#39;).split(spacesRe);
                for (i = 0, len = className.length; i &lt; len; i++) {
                    cls = className[i];
                    if (typeof cls == &#39;string&#39;) {
                        cls = cls.replace(trimRe, &#39;&#39;);
                        idx = Ext.Array.indexOf(elClasses, cls);
                        if (idx != -1) {
                            elClasses.splice(idx, 1);
                        }
                    }
                }
                me.dom.className = elClasses.join(&quot; &quot;);
            }
            return me;
        },

        <a name="method-Ext.core.Element-radioCls"></a>/**
         * Adds one or more CSS classes to this element and removes the same class(es) from all siblings.
         * @param {String/Array} className The CSS class to add, or an array of classes
         * @return {Ext.core.Element} this
         */
        radioCls : function(className){
            var cn = this.dom.parentNode.childNodes,
                v, i, len;
            className = Ext.isArray(className) ? className : [className];
            for (i = 0, len = cn.length; i &lt; len; i++) {
                v = cn[i];
                if (v &amp;&amp; v.nodeType == 1) {
                    Ext.fly(v, &#39;_internal&#39;).removeCls(className);
                }
            }
            return this.addCls(className);
        },

        <a name="method-Ext.core.Element-toggleCls"></a>/**
         * Toggles the specified CSS class on this element (removes it if it already exists, otherwise adds it).
         * @param {String} className The CSS class to toggle
         * @return {Ext.core.Element} this
         */
        toggleCls : Ext.supports.ClassList ?
            function(className) {
                this.dom.classList.toggle(Ext.String.trim(className));
                return this;
            } :
            function(className) {
                return this.hasCls(className) ? this.removeCls(className) : this.addCls(className);
            },

        <a name="method-Ext.core.Element-hasCls"></a>/**
         * Checks if the specified CSS class exists on this element&#39;s DOM node.
         * @param {String} className The CSS class to check for
         * @return {Boolean} True if the class exists, else false
         */
        hasCls : Ext.supports.ClassList ?
            function(className) {
                if (!className) {
                    return false;
                }
                className = className.split(spacesRe);
                var ln = className.length,
                    i = 0;
                for (; i &lt; ln; i++) {
                    if (className[i] &amp;&amp; this.dom.classList.contains(className[i])) {
                        return true;
                    }
                }
                return false;
            } :
            function(className){
                return className &amp;&amp; (&#39; &#39; + this.dom.className + &#39; &#39;).indexOf(&#39; &#39; + className + &#39; &#39;) != -1;
            },

        <a name="method-Ext.core.Element-replaceCls"></a>/**
         * Replaces a CSS class on the element with another.  If the old name does not exist, the new name will simply be added.
         * @param {String} oldClassName The CSS class to replace
         * @param {String} newClassName The replacement CSS class
         * @return {Ext.core.Element} this
         */
        replaceCls : function(oldClassName, newClassName){
            return this.removeCls(oldClassName).addCls(newClassName);
        },

        isStyle : function(style, val) {
            return this.getStyle(style) == val;
        },

        <a name="method-Ext.core.Element-getStyle"></a>/**
         * Normalizes currentStyle and computedStyle.
         * @param {String} property The style property whose value is returned.
         * @return {String} The current value of the style property for this element.
         */
        getStyle : function(){
            return view &amp;&amp; view.getComputedStyle ?
                function(prop){
                    var el = this.dom,
                        v, cs, out, display;

                    if(el == document){
                        return null;
                    }
                    prop = Ext.core.Element.normalize(prop);
                    out = (v = el.style[prop]) ? v :
                           (cs = view.getComputedStyle(el, &quot;&quot;)) ? cs[prop] : null;
                           
                    // Ignore cases when the margin is correctly reported as 0, the bug only shows
                    // numbers larger.
                    if(prop == &#39;marginRight&#39; &amp;&amp; out != &#39;0px&#39; &amp;&amp; !supports.RightMargin){
                        display = this.getStyle(&#39;display&#39;);
                        el.style.display = &#39;inline-block&#39;;
                        out = view.getComputedStyle(el, &#39;&#39;).marginRight;
                        el.style.display = display;
                    }
                    
                    if(prop == &#39;backgroundColor&#39; &amp;&amp; out == &#39;rgba(0, 0, 0, 0)&#39; &amp;&amp; !supports.TransparentColor){
                        out = &#39;transparent&#39;;
                    }
                    return out;
                } :
                function(prop){
                    var el = this.dom,
                        m, cs;

                    if (el == document) {
                        return null;
                    }
                    
                    if (prop == &#39;opacity&#39;) {
                        if (el.style.filter.match) {
                            m = el.style.filter.match(opacityRe);
                            if(m){
                                var fv = parseFloat(m[1]);
                                if(!isNaN(fv)){
                                    return fv ? fv / 100 : 0;
                                }
                            }
                        }
                        return 1;
                    }
                    prop = Ext.core.Element.normalize(prop);
                    return el.style[prop] || ((cs = el.currentStyle) ? cs[prop] : null);
                };
        }(),

        <a name="method-Ext.core.Element-getColor"></a>/**
         * Return the CSS color for the specified CSS attribute. rgb, 3 digit (like #fff) and valid values
         * are convert to standard 6 digit hex color.
         * @param {String} attr The css attribute
         * @param {String} defaultValue The default value to use when a valid color isn&#39;t found
         * @param {String} prefix (optional) defaults to #. Use an empty string when working with
         * color anims.
         */
        getColor : function(attr, defaultValue, prefix){
            var v = this.getStyle(attr),
                color = prefix === &#39;undefined&#39; ? prefix : &#39;#&#39;,
                h;

            if(!v || (/transparent|inherit/.test(v))) {
                return defaultValue;
            }
            if(/^r/.test(v)){
                Ext.each(v.slice(4, v.length -1).split(&#39;,&#39;), function(s){
                    h = parseInt(s, 10);
                    color += (h &lt; 16 ? &#39;0&#39; : &#39;&#39;) + h.toString(16);
                });
            }else{
                v = v.replace(&#39;#&#39;, &#39;&#39;);
                color += v.length == 3 ? v.replace(/^(\w)(\w)(\w)$/, &#39;$1$1$2$2$3$3&#39;) : v;
            }
            return(color.length &gt; 5 ? color.toLowerCase() : defaultValue);
        },

        <a name="method-Ext.core.Element-setStyle"></a>/**
         * Wrapper for setting style properties, also takes single object parameter of multiple styles.
         * @param {String/Object} property The style property to be set, or an object of multiple styles.
         * @param {String} value (optional) The value to apply to the given property, or null if an object was passed.
         * @return {Ext.core.Element} this
         */
        setStyle : function(prop, value){
            var me = this,
                tmp, style;

            if (!me.dom) {
                return me;
            }

            if (!Ext.isObject(prop)) {
                tmp = {};
                tmp[prop] = value;
                prop = tmp;
            }
            for (style in prop) {
                if (prop.hasOwnProperty(style)) {
                    value = Ext.value(prop[style], &#39;&#39;);
                    if (style == &#39;opacity&#39;) {
                        me.setOpacity(value);
                    }
                    else {
                        me.dom.style[Ext.core.Element.normalize(style)] = value;
                    }
                }
            }
            return me;
        },

        <a name="method-Ext.core.Element-setOpacity"></a>/**
         * Set the opacity of the element
         * @param {Float} opacity The new opacity. 0 = transparent, .5 = 50% visibile, 1 = fully visible, etc
         * @param {Boolean/Object} animate (optional) a standard Element animation config object or &lt;tt&gt;true&lt;/tt&gt; for
         * the default animation (&lt;tt&gt;{duration: .35, easing: &#39;easeIn&#39;}&lt;/tt&gt;)
         * @return {Ext.core.Element} this
         */
         setOpacity : function(opacity, animate){
            var me = this,
                s = me.dom.style,
                val;

            if(!animate || !me.anim){
                if(!Ext.supports.Opacity){
                    opacity = opacity &lt; 1 ? &#39;alpha(opacity=&#39; + opacity * 100 + &#39;)&#39; : &#39;&#39;;
                    val = s.filter.replace(opacityRe, &#39;&#39;).replace(trimRe, &#39;&#39;);

                    s.zoom = 1;
                    s.filter = val + (val.length &gt; 0 ? &#39; &#39; : &#39;&#39;) + opacity;
                }else{
                    s.opacity = opacity;
                }
            }else{
                if (!Ext.isObject(animate)) {
                    animate = {
                        duration: 350,
                        easing: &#39;ease-in&#39;
                    };
                }
                me.animate(Ext.applyIf({
                    to: {
                        opacity: opacity
                    }
                }, animate));
            }
            return me;
        },

        <a name="method-Ext.core.Element-clearOpacity"></a>/**
         * Clears any opacity settings from this element. Required in some cases for IE.
         * @return {Ext.core.Element} this
         */
        clearOpacity : function(){
            var style = this.dom.style;
            if(!Ext.supports.Opacity){
                if(!Ext.isEmpty(style.filter)){
                    style.filter = style.filter.replace(opacityRe, &#39;&#39;).replace(trimRe, &#39;&#39;);
                }
            }else{
                style.opacity = style[&#39;-moz-opacity&#39;] = style[&#39;-khtml-opacity&#39;] = &#39;&#39;;
            }
            return this;
        },

        <a name="method-Ext.core.Element-getHeight"></a>/**
         * Returns the offset height of the element
         * @param {Boolean} contentHeight (optional) true to get the height minus borders and padding
         * @return {Number} The element&#39;s height
         */
        getHeight: function(contentHeight) {
            var me = this,
                dom = me.dom,
                hidden = Ext.isIE &amp;&amp; me.isStyle(&#39;display&#39;, &#39;none&#39;),
                height, overflow, style;

            // IE Quirks mode acts more like a max-size measurement unless overflow is hidden during measurement.
            // We will put the overflow back to it&#39;s original value when we are done measuring.
            if (Ext.isIEQuirks) {
                style = dom.style;
                overflow = style.overflow;
                me.setStyle({ overflow: &#39;hidden&#39;});
            }

            height = MATH.max(dom.offsetHeight, hidden ? 0 : dom.clientHeight) || 0;

            if (contentHeight) {
                height -= (me.getBorderWidth(&quot;tb&quot;) + me.getPadding(&quot;tb&quot;));
            }

            if (Ext.isIEQuirks) {
                me.setStyle({ overflow: overflow});
            }

            if (height &lt; 0) {
                height = 0;
            }
            return height;
        },

        <a name="method-Ext.core.Element-getWidth"></a>/**
         * Returns the offset width of the element
         * @param {Boolean} contentWidth (optional) true to get the width minus borders and padding
         * @return {Number} The element&#39;s width
         */
        getWidth: function(contentWidth) {
            var me = this,
                dom = me.dom,
                hidden = Ext.isIE &amp;&amp; me.isStyle(&#39;display&#39;, &#39;none&#39;),
                rect, width, overflow, style;

            // IE Quirks mode acts more like a max-size measurement unless overflow is hidden during measurement.
            // We will put the overflow back to it&#39;s original value when we are done measuring.
            if (Ext.isIEQuirks) {
                style = dom.style;
                overflow = style.overflow;
                me.setStyle({ overflow: &#39;hidden&#39;});
            }

            // Gecko will in some cases report an offsetWidth that is actually less than the width of the
            // text contents, because it measures fonts with sub-pixel precision but rounds the calculated
            // value down. Using getBoundingClientRect instead of offsetWidth allows us to get the precise
            // subpixel measurements so we can force them to always be rounded up. See
            // https://bugzilla.mozilla.org/show_bug.cgi?id=458617
            if (Ext.supports.BoundingClientRect) {
                rect = dom.getBoundingClientRect();
                width = Math.ceil(rect.right - rect.left);
            } else {
                width = dom.offsetWidth;
            }
            width = MATH.max(width, hidden ? 0 : dom.clientWidth) || 0;

            if (contentWidth) {
                width -= (me.getBorderWidth(&quot;lr&quot;) + me.getPadding(&quot;lr&quot;));
            }

            if (Ext.isIEQuirks) {
                me.setStyle({ overflow: overflow});
            }

            if (width &lt; 0) {
                width = 0;
            }
            return width;
        },

        <a name="method-Ext.core.Element-setWidth"></a>/**
         * Set the width of this Element.
         * @param {Mixed} width The new width. This may be one of:&lt;div class=&quot;mdetail-params&quot;&gt;&lt;ul&gt;
         * &lt;li&gt;A Number specifying the new width in this Element&#39;s {@link #defaultUnit}s (by default, pixels).&lt;/li&gt;
         * &lt;li&gt;A String used to set the CSS width style. Animation may &lt;b&gt;not&lt;/b&gt; be used.
         * &lt;/ul&gt;&lt;/div&gt;
         * @param {Boolean/Object} animate (optional) true for the default animation or a standard Element animation config object
         * @return {Ext.core.Element} this
         */
        setWidth : function(width, animate){
            var me = this;
            width = me.adjustWidth(width);
            if (!animate || !me.anim) {
                me.dom.style.width = me.addUnits(width);
            }
            else {
                if (!Ext.isObject(animate)) {
                    animate = {};
                }
                me.animate(Ext.applyIf({
                    to: {
                        width: width
                    }
                }, animate));
            }
            return me;
        },

        <a name="method-Ext.core.Element-setHeight"></a>/**
         * Set the height of this Element.
         * <br><span style="display: none">**/</span>// change the height to 200px and animate with default configuration
Ext.fly(&#39;elementId&#39;).setHeight(200, true);

// change the height to 150px and animate with a custom configuration
Ext.fly(&#39;elId&#39;).setHeight(150, {
    duration : .5, // animation will have a duration of .5 seconds
    // will change the content to &quot;finished&quot;
    callback: function(){ this.{@link #update}(&quot;finished&quot;); }
});
         * <br><span style="display: none">/**</span>         * @param {Mixed} height The new height. This may be one of:&lt;div class=&quot;mdetail-params&quot;&gt;&lt;ul&gt;
         * &lt;li&gt;A Number specifying the new height in this Element&#39;s {@link #defaultUnit}s (by default, pixels.)&lt;/li&gt;
         * &lt;li&gt;A String used to set the CSS height style. Animation may &lt;b&gt;not&lt;/b&gt; be used.&lt;/li&gt;
         * &lt;/ul&gt;&lt;/div&gt;
         * @param {Boolean/Object} animate (optional) true for the default animation or a standard Element animation config object
         * @return {Ext.core.Element} this
         */
         setHeight : function(height, animate){
            var me = this;
            height = me.adjustHeight(height);
            if (!animate || !me.anim) {
                me.dom.style.height = me.addUnits(height);
            }
            else {
                if (!Ext.isObject(animate)) {
                    animate = {};
                }
                me.animate(Ext.applyIf({
                    to: {
                        height: height
                    }
                }, animate));
            }
            return me;
        },

        <a name="method-Ext.core.Element-getBorderWidth"></a>/**
         * Gets the width of the border(s) for the specified side(s)
         * @param {String} side Can be t, l, r, b or any combination of those to add multiple values. For example,
         * passing &lt;tt&gt;&#39;lr&#39;&lt;/tt&gt; would get the border &lt;b&gt;&lt;u&gt;l&lt;/u&gt;&lt;/b&gt;eft width + the border &lt;b&gt;&lt;u&gt;r&lt;/u&gt;&lt;/b&gt;ight width.
         * @return {Number} The width of the sides passed added together
         */
        getBorderWidth : function(side){
            return this.addStyles(side, borders);
        },

        <a name="method-Ext.core.Element-getPadding"></a>/**
         * Gets the width of the padding(s) for the specified side(s)
         * @param {String} side Can be t, l, r, b or any combination of those to add multiple values. For example,
         * passing &lt;tt&gt;&#39;lr&#39;&lt;/tt&gt; would get the padding &lt;b&gt;&lt;u&gt;l&lt;/u&gt;&lt;/b&gt;eft + the padding &lt;b&gt;&lt;u&gt;r&lt;/u&gt;&lt;/b&gt;ight.
         * @return {Number} The padding of the sides passed added together
         */
        getPadding : function(side){
            return this.addStyles(side, paddings);
        },

        <a name="method-Ext.core.Element-clip"></a>/**
         *  Store the current overflow setting and clip overflow on the element - use &lt;tt&gt;{@link #unclip}&lt;/tt&gt; to remove
         * @return {Ext.core.Element} this
         */
        clip : function(){
            var me = this,
                dom = me.dom;

            if(!data(dom, ISCLIPPED)){
                data(dom, ISCLIPPED, true);
                data(dom, ORIGINALCLIP, {
                    o: me.getStyle(OVERFLOW),
                    x: me.getStyle(OVERFLOWX),
                    y: me.getStyle(OVERFLOWY)
                });
                me.setStyle(OVERFLOW, HIDDEN);
                me.setStyle(OVERFLOWX, HIDDEN);
                me.setStyle(OVERFLOWY, HIDDEN);
            }
            return me;
        },

        <a name="method-Ext.core.Element-unclip"></a>/**
         *  Return clipping (overflow) to original clipping before &lt;tt&gt;{@link #clip}&lt;/tt&gt; was called
         * @return {Ext.core.Element} this
         */
        unclip : function(){
            var me = this,
                dom = me.dom,
                clip;

            if(data(dom, ISCLIPPED)){
                data(dom, ISCLIPPED, false);
                clip = data(dom, ORIGINALCLIP);
                if(o.o){
                    me.setStyle(OVERFLOW, o.o);
                }
                if(o.x){
                    me.setStyle(OVERFLOWX, o.x);
                }
                if(o.y){
                    me.setStyle(OVERFLOWY, o.y);
                }
            }
            return me;
        },

        // private
        addStyles : function(sides, styles){
            var totalSize = 0,
                sidesArr = sides.match(wordsRe),
                i = 0,
                len = sidesArr.length,
                side, size;
            for (; i &lt; len; i++) {
                side = sidesArr[i];
                size = side &amp;&amp; parseInt(this.getStyle(styles[side]), 10);
                if (size) {
                    totalSize += MATH.abs(size);
                }
            }
            return totalSize;
        },

        margins : margins,
        
        <a name="method-Ext.core.Element-applyStyles"></a>/**
         * More flexible version of {@link #setStyle} for setting style properties.
         * @param {String/Object/Function} styles A style specification string, e.g. &quot;width:100px&quot;, or object in the form {width:&quot;100px&quot;}, or
         * a function which returns such a specification.
         * @return {Ext.core.Element} this
         */
        applyStyles : function(style){
            Ext.core.DomHelper.applyStyles(this.dom, style);
            return this;
        },

        <a name="method-Ext.core.Element-getStyles"></a>/**
         * Returns an object with properties matching the styles requested.
         * For example, el.getStyles(&#39;color&#39;, &#39;font-size&#39;, &#39;width&#39;) might return
         * {&#39;color&#39;: &#39;#FFFFFF&#39;, &#39;font-size&#39;: &#39;13px&#39;, &#39;width&#39;: &#39;100px&#39;}.
         * @param {String} style1 A style name
         * @param {String} style2 A style name
         * @param {String} etc.
         * @return {Object} The style object
         */
        getStyles : function(){
            var styles = {},
                len = arguments.length,
                i = 0, style;
                
            for(; i &lt; len; ++i) {
                style = arguments[i];
                styles[style] = this.getStyle(style);
            }
            return styles;
        },

       <a name="method-Ext.core.Element-boxWrap"></a>/**
        * &lt;p&gt;Wraps the specified element with a special 9 element markup/CSS block that renders by default as
        * a gray container with a gradient background, rounded corners and a 4-way shadow.&lt;/p&gt;
        * &lt;p&gt;This special markup is used throughout Ext when box wrapping elements ({@link Ext.button.Button},
        * {@link Ext.panel.Panel} when &lt;tt&gt;{@link Ext.panel.Panel#frame frame=true}&lt;/tt&gt;, {@link Ext.window.Window}).  The markup
        * is of this form:&lt;/p&gt;
        * <br><span style="display: none">**/</span>    Ext.core.Element.boxMarkup =
    &amp;#39;&amp;lt;div class=&quot;{0}-tl&quot;&gt;&amp;lt;div class=&quot;{0}-tr&quot;&gt;&amp;lt;div class=&quot;{0}-tc&quot;&gt;&amp;lt;/div&gt;&amp;lt;/div&gt;&amp;lt;/div&gt;
     &amp;lt;div class=&quot;{0}-ml&quot;&gt;&amp;lt;div class=&quot;{0}-mr&quot;&gt;&amp;lt;div class=&quot;{0}-mc&quot;&gt;&amp;lt;/div&gt;&amp;lt;/div&gt;&amp;lt;/div&gt;
     &amp;lt;div class=&quot;{0}-bl&quot;&gt;&amp;lt;div class=&quot;{0}-br&quot;&gt;&amp;lt;div class=&quot;{0}-bc&quot;&gt;&amp;lt;/div&gt;&amp;lt;/div&gt;&amp;lt;/div&gt;&amp;#39;;
        * <br><span style="display: none">/**</span>        * &lt;p&gt;Example usage:&lt;/p&gt;
        * <br><span style="display: none">**/</span>    // Basic box wrap
    Ext.get(&quot;foo&quot;).boxWrap();

    // You can also add a custom class and use CSS inheritance rules to customize the box look.
    // &#39;x-box-blue&#39; is a built-in alternative -- look at the related CSS definitions as an example
    // for how to create a custom box wrap style.
    Ext.get(&quot;foo&quot;).boxWrap().addCls(&quot;x-box-blue&quot;);
        * <br><span style="display: none">/**</span>        * @param {String} class (optional) A base CSS class to apply to the containing wrapper element
        * (defaults to &lt;tt&gt;&#39;x-box&#39;&lt;/tt&gt;). Note that there are a number of CSS rules that are dependent on
        * this name to make the overall effect work, so if you supply an alternate base class, make sure you
        * also supply all of the necessary rules.
        * @return {Ext.core.Element} The outermost wrapping element of the created box structure.
        */
        boxWrap : function(cls){
            cls = cls || Ext.baseCSSPrefix + &#39;box&#39;;
            var el = Ext.get(this.insertHtml(&quot;beforeBegin&quot;, &quot;&lt;div class=&#39;&quot; + cls + &quot;&#39;&gt;&quot; + Ext.String.format(Ext.core.Element.boxMarkup, cls) + &quot;&lt;/div&gt;&quot;));
            Ext.DomQuery.selectNode(&#39;.&#39; + cls + &#39;-mc&#39;, el.dom).appendChild(this.dom);
            return el;
        },

        <a name="method-Ext.core.Element-setSize"></a>/**
         * Set the size of this Element. If animation is true, both width and height will be animated concurrently.
         * @param {Mixed} width The new width. This may be one of:&lt;div class=&quot;mdetail-params&quot;&gt;&lt;ul&gt;
         * &lt;li&gt;A Number specifying the new width in this Element&#39;s {@link #defaultUnit}s (by default, pixels).&lt;/li&gt;
         * &lt;li&gt;A String used to set the CSS width style. Animation may &lt;b&gt;not&lt;/b&gt; be used.
         * &lt;li&gt;A size object in the format &lt;code&gt;{width: widthValue, height: heightValue}&lt;/code&gt;.&lt;/li&gt;
         * &lt;/ul&gt;&lt;/div&gt;
         * @param {Mixed} height The new height. This may be one of:&lt;div class=&quot;mdetail-params&quot;&gt;&lt;ul&gt;
         * &lt;li&gt;A Number specifying the new height in this Element&#39;s {@link #defaultUnit}s (by default, pixels).&lt;/li&gt;
         * &lt;li&gt;A String used to set the CSS height style. Animation may &lt;b&gt;not&lt;/b&gt; be used.&lt;/li&gt;
         * &lt;/ul&gt;&lt;/div&gt;
         * @param {Boolean/Object} animate (optional) true for the default animation or a standard Element animation config object
         * @return {Ext.core.Element} this
         */
        setSize : function(width, height, animate){
            var me = this;
            if (Ext.isObject(width)){ // in case of object from getSize()
                height = width.height;
                width = width.width;
            }
            width = me.adjustWidth(width);
            height = me.adjustHeight(height);
            if(!animate || !me.anim){
                me.dom.style.width = me.addUnits(width);
                me.dom.style.height = me.addUnits(height);
            }
            else {
                if (!Ext.isObject(animate)) {
                    animate = {};
                }
                me.animate(Ext.applyIf({
                    to: {
                        width: width,
                        height: height
                    }
                }, animate));
            }
            return me;
        },

        <a name="method-Ext.core.Element-getComputedHeight"></a>/**
         * Returns either the offsetHeight or the height of this element based on CSS height adjusted by padding or borders
         * when needed to simulate offsetHeight when offsets aren&#39;t available. This may not work on display:none elements
         * if a height has not been set using CSS.
         * @return {Number}
         */
        getComputedHeight : function(){
            var me = this,
                h = Math.max(me.dom.offsetHeight, me.dom.clientHeight);
            if(!h){
                h = parseFloat(me.getStyle(&#39;height&#39;)) || 0;
                if(!me.isBorderBox()){
                    h += me.getFrameWidth(&#39;tb&#39;);
                }
            }
            return h;
        },

        <a name="method-Ext.core.Element-getComputedWidth"></a>/**
         * Returns either the offsetWidth or the width of this element based on CSS width adjusted by padding or borders
         * when needed to simulate offsetWidth when offsets aren&#39;t available. This may not work on display:none elements
         * if a width has not been set using CSS.
         * @return {Number}
         */
        getComputedWidth : function(){
            var me = this,
                w = Math.max(me.dom.offsetWidth, me.dom.clientWidth);
                
            if(!w){
                w = parseFloat(me.getStyle(&#39;width&#39;)) || 0;
                if(!me.isBorderBox()){
                    w += me.getFrameWidth(&#39;lr&#39;);
                }
            }
            return w;
        },

        <a name="method-Ext.core.Element-getFrameWidth"></a>/**
         * Returns the sum width of the padding and borders for the passed &quot;sides&quot;. See getBorderWidth()
         for more information about the sides.
         * @param {String} sides
         * @return {Number}
         */
        getFrameWidth : function(sides, onlyContentBox){
            return onlyContentBox &amp;&amp; this.isBorderBox() ? 0 : (this.getPadding(sides) + this.getBorderWidth(sides));
        },

        <a name="method-Ext.core.Element-addClsOnOver"></a>/**
         * Sets up event handlers to add and remove a css class when the mouse is over this element
         * @param {String} className
         * @return {Ext.core.Element} this
         */
        addClsOnOver : function(className){
            var dom = this.dom;
            this.hover(
                function(){
                    Ext.fly(dom, INTERNAL).addCls(className);
                },
                function(){
                    Ext.fly(dom, INTERNAL).removeCls(className);
                }
            );
            return this;
        },

        <a name="method-Ext.core.Element-addClsOnFocus"></a>/**
         * Sets up event handlers to add and remove a css class when this element has the focus
         * @param {String} className
         * @return {Ext.core.Element} this
         */
        addClsOnFocus : function(className){
            var me = this,
                dom = me.dom;
            me.on(&quot;focus&quot;, function(){
                Ext.fly(dom, INTERNAL).addCls(className);
            });
            me.on(&quot;blur&quot;, function(){
                Ext.fly(dom, INTERNAL).removeCls(className);
            });
            return me;
        },

        <a name="method-Ext.core.Element-addClsOnClick"></a>/**
         * Sets up event handlers to add and remove a css class when the mouse is down and then up on this element (a click effect)
         * @param {String} className
         * @return {Ext.core.Element} this
         */
        addClsOnClick : function(className){
            var dom = this.dom;
            this.on(&quot;mousedown&quot;, function(){
                Ext.fly(dom, INTERNAL).addCls(className);
                var d = Ext.getDoc(),
                    fn = function(){
                        Ext.fly(dom, INTERNAL).removeCls(className);
                        d.removeListener(&quot;mouseup&quot;, fn);
                    };
                d.on(&quot;mouseup&quot;, fn);
            });
            return this;
        },

        <a name="method-Ext.core.Element-getViewSize"></a>/**
         * &lt;p&gt;Returns the dimensions of the element available to lay content out in.&lt;p&gt;
         * &lt;p&gt;If the element (or any ancestor element) has CSS style &lt;code&gt;display : none&lt;/code&gt;, the dimensions will be zero.&lt;/p&gt;
         * example:<br><span style="display: none">**/</span>        var vpSize = Ext.getBody().getViewSize();

        // all Windows created afterwards will have a default value of 90% height and 95% width
        Ext.Window.override({
            width: vpSize.width * 0.9,
            height: vpSize.height * 0.95
        });
        // To handle window resizing you would have to hook onto onWindowResize.
        * <br><span style="display: none">/**</span>        *
        * getViewSize utilizes clientHeight/clientWidth which excludes sizing of scrollbars.
        * To obtain the size including scrollbars, use getStyleSize
        *
        * Sizing of the document body is handled at the adapter level which handles special cases for IE and strict modes, etc.
        */

        getViewSize : function(){
            var me = this,
                dom = me.dom,
                isDoc = (dom == Ext.getDoc().dom || dom == Ext.getBody().dom),
                style, overflow, ret;

            // If the body, use static methods
            if (isDoc) {
                ret = {
                    width : Ext.core.Element.getViewWidth(),
                    height : Ext.core.Element.getViewHeight()
                };

            // Else use clientHeight/clientWidth
            }
            else {
                // IE Quirks mode acts more like a max-size measurement unless overflow is hidden during measurement.
                // We will put the overflow back to it&#39;s original value when we are done measuring.
                if (Ext.isIEQuirks) {
                    style = dom.style;
                    overflow = style.overflow;
                    me.setStyle({ overflow: &#39;hidden&#39;});
                }
                ret = {
                    width : dom.clientWidth,
                    height : dom.clientHeight
                };
                if (Ext.isIEQuirks) {
                    me.setStyle({ overflow: overflow });
                }
            }
            return ret;
        },

        <a name="method-Ext.core.Element-getStyleSize"></a>/**
        * &lt;p&gt;Returns the dimensions of the element available to lay content out in.&lt;p&gt;
        *
        * getStyleSize utilizes prefers style sizing if present, otherwise it chooses the larger of offsetHeight/clientHeight and offsetWidth/clientWidth.
        * To obtain the size excluding scrollbars, use getViewSize
        *
        * Sizing of the document body is handled at the adapter level which handles special cases for IE and strict modes, etc.
        */

        getStyleSize : function(){
            var me = this,
                doc = document,
                d = this.dom,
                isDoc = (d == doc || d == doc.body),
                s = d.style,
                w, h;

            // If the body, use static methods
            if (isDoc) {
                return {
                    width : Ext.core.Element.getViewWidth(),
                    height : Ext.core.Element.getViewHeight()
                };
            }
            // Use Styles if they are set
            if(s.width &amp;&amp; s.width != &#39;auto&#39;){
                w = parseFloat(s.width);
                if(me.isBorderBox()){
                   w -= me.getFrameWidth(&#39;lr&#39;);
                }
            }
            // Use Styles if they are set
            if(s.height &amp;&amp; s.height != &#39;auto&#39;){
                h = parseFloat(s.height);
                if(me.isBorderBox()){
                   h -= me.getFrameWidth(&#39;tb&#39;);
                }
            }
            // Use getWidth/getHeight if style not set.
            return {width: w || me.getWidth(true), height: h || me.getHeight(true)};
        },

        <a name="method-Ext.core.Element-getSize"></a>/**
         * Returns the size of the element.
         * @param {Boolean} contentSize (optional) true to get the width/size minus borders and padding
         * @return {Object} An object containing the element&#39;s size {width: (element width), height: (element height)}
         */
        getSize : function(contentSize){
            return {width: this.getWidth(contentSize), height: this.getHeight(contentSize)};
        },

        <a name="method-Ext.core.Element-repaint"></a>/**
         * Forces the browser to repaint this element
         * @return {Ext.core.Element} this
         */
        repaint : function(){
            var dom = this.dom;
            this.addCls(Ext.baseCSSPrefix + &#39;repaint&#39;);
            setTimeout(function(){
                Ext.fly(dom).removeCls(Ext.baseCSSPrefix + &#39;repaint&#39;);
            }, 1);
            return this;
        },

        <a name="method-Ext.core.Element-unselectable"></a>/**
         * Disables text selection for this element (normalized across browsers)
         * @return {Ext.core.Element} this
         */
        unselectable : function(){
            this.dom.unselectable = &quot;on&quot;;
            return this.swallowEvent(&quot;selectstart&quot;, true).
                        applyStyles(&quot;-moz-user-select:none;-khtml-user-select:none;&quot;).
                        addCls(Ext.baseCSSPrefix + &#39;unselectable&#39;);
        },

        <a name="method-Ext.core.Element-getMargin"></a>/**
         * Returns an object with properties top, left, right and bottom representing the margins of this element unless sides is passed,
         * then it returns the calculated width of the sides (see getPadding)
         * @param {String} sides (optional) Any combination of l, r, t, b to get the sum of those sides
         * @return {Object/Number}
         */
        getMargin : function(side){
            var me = this,
                hash = {t:&quot;top&quot;, l:&quot;left&quot;, r:&quot;right&quot;, b: &quot;bottom&quot;},
                o = {},
                key;

            if (!side) {
                for (key in me.margins){
                    o[hash[key]] = parseFloat(me.getStyle(me.margins[key])) || 0;
                }
                return o;
            } else {
                return me.addStyles.call(me, side, me.margins);
            }
        }
    });
})();￿</pre></pre></body></html>