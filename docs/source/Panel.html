<!DOCTYPE html><html><head><title>Sencha Documentation Project</title><link rel="stylesheet" href="../reset.css" type="text/css"><link rel="stylesheet" href="../prettify.css" type="text/css"><link rel="stylesheet" href="../prettify_sa.css" type="text/css"><script type="text/javascript" src="../prettify.js"></script></head><body onload="prettyPrint()"><pre class="prettyprint"><pre><a name="cls-Ext.panel.Panel"></a>/**
 * @class Ext.panel.Panel
 * @extends Ext.AbstractPanel
 * &lt;p&gt;Panel is a container that has specific functionality and structural components that make
 * it the perfect building block for application-oriented user interfaces.&lt;/p&gt;
 * &lt;p&gt;Panels are, by virtue of their inheritance from {@link Ext.container.Container}, capable
 * of being configured with a {@link Ext.container.Container#layout layout}, and containing child Components.&lt;/p&gt;
 * &lt;p&gt;When either specifying child {@link Ext.Component#items items} of a Panel, or dynamically {@link Ext.container.Container#add adding} Components
 * to a Panel, remember to consider how you wish the Panel to arrange those child elements, and whether
 * those child elements need to be sized using one of Ext&amp;#39;s built-in &lt;code&gt;&lt;b&gt;{@link Ext.container.Container#layout layout}&lt;/b&gt;&lt;/code&gt; schemes. By
 * default, Panels use the {@link Ext.layout.container.Auto Auto} scheme. This simply renders
 * child components, appending them one after the other inside the Container, and &lt;b&gt;does not apply any sizing&lt;/b&gt;
 * at all.&lt;/p&gt;
 * {@img Ext.panel.Panel/panel.png Panel components}
 * &lt;p&gt;A Panel may also contain {@link #bbar bottom} and {@link #tbar top} toolbars, along with separate
 * {@link #header}, {@link #footer} and {@link #body} sections (see {@link #frame} for additional
 * information).&lt;/p&gt;
 * &lt;p&gt;Panel also provides built-in {@link #collapsible collapsible, expandable} and {@link #closable} behavior.  
 * Panels can be easily dropped into any {@link Ext.container.Container Container} or layout, and the
 * layout and rendering pipeline is {@link Ext.container.Container#add completely managed by the framework}.&lt;/p&gt;
 * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; By default, the &lt;code&gt;{@link #closable close}&lt;/code&gt; header tool &lt;i&gt;destroys&lt;/i&gt; the Panel resulting in removal of the Panel
 * and the destruction of any descendant Components. This makes the Panel object, and all its descendants &lt;b&gt;unusable&lt;/b&gt;. To enable the close
 * tool to simply &lt;i&gt;hide&lt;/i&gt; a Panel for later re-use, configure the Panel with &lt;b&gt;&lt;code&gt;{@link #closeAction closeAction: &#39;hide&#39;}&lt;/code&gt;&lt;/b&gt;.&lt;/p&gt;
 * &lt;p&gt;Usually, Panels are used as constituents within an application, in which case, they would be used as child items of Containers,
 * and would themselves use Ext.Components as child {@link #items}. However to illustrate simply rendering a Panel into the document,
 * here&amp;#39;s how to do it:<br><span style="display: none">**/</span>Ext.create(&#39;Ext.panel.Panel&#39;, {
    title: &#39;Hello&#39;,
    width: 200,
    html: &#39;&amp;lt;p&amp;gt;World!&amp;lt;/p&amp;gt;&#39;,
    renderTo: document.body
});
<br><span style="display: none">/**</span>&lt;/p&gt;
 * &lt;p&gt;A more realistic scenario is a Panel created to house input fields which will not be rendered, but used as a constituent part of a Container:<br><span style="display: none">**/</span>var filterPanel = Ext.create(&#39;Ext.panel.Panel&#39;, {
    bodyPadding: 5,  // Don&amp;#39;t want content to crunch against the borders
    title: &#39;Filters&#39;,
    items: [{
        xtype: &#39;datefield&#39;,
        fieldLabel: &#39;Start date&#39;
    }, {
        xtype: &#39;datefield&#39;,
        fieldLabel: &#39;End date&#39;
    }]
});
<br><span style="display: none">/**</span>&lt;/p&gt;
 * &lt;p&gt;Note that the Panel above is not configured to render into the document, nor is it configured with a size or position. In a real world scenario,
 * the Container into which the Panel is added will use a {@link #layout} to render, size and position its child Components.&lt;/p&gt;
 * &lt;p&gt;Panels will often use specific {@link #layout}s to provide an application with shape and structure by containing and arranging child
 * Components: <br><span style="display: none">**/</span>var resultsPanel = Ext.create(&#39;Ext.panel.Panel&#39;, {
    layout: {
        type: &#39;vbox&#39;,       // Arrange child items vertically
        align: &#39;stretch&#39;    // Each takes up full width
    },
    items: [{               // Results grid specified as a config object with an xtype of &#39;grid&#39;
        xtype: &#39;grid&#39;,
        border: false,
        headers: [{header: &#39;World&#39;}]                  // One header just for show. There&amp;#39;s no data,
        store: Ext.create(&#39;Ext.data.ArrayStore&#39;, {}), // A dummy empty data store
        flex: 1                                       // Use 1/3 of Container&amp;#39;s height (hint to Box layout)
    }, {
        xtype: &#39;splitter&#39;,       // A splitter between the two child items
        collapseTarget: &#39;prev&#39;   // It has a mini-collapse tool: collapse the grid
    }, {                    // Details Panel specified as a config object (no xtype defaults to &#39;panel&#39;).
        bodyPadding: 5,
        items: fieldsArray, // An array of form fields
        flex: 2             // Use 2/3 of Container&amp;#39;s height (hint to Box layout)
    }]
});
<br><span style="display: none">/**</span> * The example illustrates one possible method of displaying search results. The Panel contains a grid with the resulting data arranged
 * in rows. Each selected row may be displayed in detail in the Panel below. The {@link Ext.layout.container.VBox vbox} layout is used
 * to arrange the two vertically. It is configured to stretch child items horizontally to full width. Child items may either be configured 
 * with a numeric height, or with a &lt;code&gt;flex&lt;/code&gt; value to distribute available space proportionately.&lt;/p&gt;
 * &lt;p&gt;This Panel itself may be a child item of, for exaple, a {@link Ext.tab.TabPanel} which will size its child items to fit within its
 * content area.&lt;/p&gt;
 * &lt;p&gt;Using these techniques, as long as the &lt;b&gt;layout&lt;/b&gt; is chosen and configured correctly, an application may have any level of
 * nested containment, all dynamically sized according to configuration, the user&amp;#39;s preference and available browser size.&lt;/p&gt;
 * @constructor
 * @param {Object} config The config object
 * @xtype panel
 */
Ext.define(&#39;Ext.panel.Panel&#39;, {
    extend: &#39;Ext.AbstractPanel&#39;,
    requires: [
        &#39;Ext.panel.Header&#39;,
        &#39;Ext.fx.Anim&#39;,
        &#39;Ext.util.KeyMap&#39;,
        &#39;Ext.panel.DD&#39;,
        &#39;Ext.XTemplate&#39;,
        &#39;Ext.layout.component.Dock&#39;
    ],
    alias: &#39;widget.panel&#39;,
    alternateClassName: &#39;Ext.Panel&#39;,

    <a name="cfg-Ext.panel.Panel-collapsedCls"></a>/**
     * @cfg {String} collapsedCls
     * A CSS class to add to the panel&amp;#39;s element after it has been collapsed (defaults to
     * &lt;code&gt;&#39;x-panel-collapsed&#39;&lt;/code&gt;).
     */

    <a name="cfg-Ext.panel.Panel-animCollapse"></a>/**
     * @cfg {Boolean} animCollapse
     * &lt;code&gt;true&lt;/code&gt; to animate the transition when the panel is collapsed, &lt;code&gt;false&lt;/code&gt; to skip the
     * animation (defaults to &lt;code&gt;true&lt;/code&gt; if the {@link Ext.fx.Anim} class is available, otherwise &lt;code&gt;false&lt;/code&gt;).
     * May also be specified as the animation duration in milliseconds.
     */
    animCollapse: Ext.enableFx,
    
    <a name="cfg-Ext.panel.Panel-minButtonWidth"></a>/**
     * @cfg {Number} minButtonWidth
     * Minimum width of all footer toolbar buttons in pixels (defaults to &lt;tt&gt;undefined&lt;/tt&gt;). If set, this will
     * be used as the default value for the &lt;tt&gt;{@link Ext.button.Button#minWidth}&lt;/tt&gt; config of
     * each Button added to the &lt;b&gt;footer toolbar&lt;/b&gt;. Will be ignored for buttons that have this value configured some
     * other way, e.g. in their own config object or via the {@link Ext.container.Container#config-defaults defaults} of
     * their parent container.
     */

    <a name="cfg-Ext.panel.Panel-collapsed"></a>/**
     * @cfg {Boolean} collapsed
     * &lt;code&gt;true&lt;/code&gt; to render the panel collapsed, &lt;code&gt;false&lt;/code&gt; to render it expanded (defaults to
     * &lt;code&gt;false&lt;/code&gt;).
     */
    collapsed: false,

    <a name="cfg-Ext.panel.Panel-collapseFirst"></a>/**
     * @cfg {Boolean} collapseFirst
     * &lt;code&gt;true&lt;/code&gt; to make sure the collapse/expand toggle button always renders first (to the left of)
     * any other tools in the panel&amp;#39;s title bar, &lt;code&gt;false&lt;/code&gt; to render it last (defaults to &lt;code&gt;true&lt;/code&gt;).
     */
    collapseFirst: true,

    <a name="cfg-Ext.panel.Panel-hideCollapseTool"></a>/**
     * @cfg {Boolean} hideCollapseTool
     * &lt;code&gt;true&lt;/code&gt; to hide the expand/collapse toggle button when &lt;code&gt;{@link #collapsible} == true&lt;/code&gt;,
     * &lt;code&gt;false&lt;/code&gt; to display it (defaults to &lt;code&gt;false&lt;/code&gt;).
     */
    hideCollapseTool: false,

    <a name="cfg-Ext.panel.Panel-titleCollapse"></a>/**
     * @cfg {Boolean} titleCollapse
     * &lt;code&gt;true&lt;/code&gt; to allow expanding and collapsing the panel (when &lt;code&gt;{@link #collapsible} = true&lt;/code&gt;)
     * by clicking anywhere in the header bar, &lt;code&gt;false&lt;/code&gt;) to allow it only by clicking to tool button
     * (defaults to &lt;code&gt;false&lt;/code&gt;)).
     */
    titleCollapse: false,

    <a name="cfg-Ext.panel.Panel-collapseMode"></a>/**
     * @cfg {String} collapseMode
     * &lt;p&gt;&lt;b&gt;Important: this config is only effective for {@link #collapsible} Panels which are direct child items of a {@link Ext.layout.container.Border border layout}.&lt;/b&gt;&lt;/p&gt;
     * &lt;p&gt;When &lt;i&gt;not&lt;/i&gt; a direct child item of a {@link Ext.layout.container.Border border layout}, then the Panel&amp;#39;s header remains visible, and the body is collapsed to zero dimensions.
     * If the Panel has no header, then a new header (orientated correctly depending on the {@link #collapseDirection}) will be inserted to show a the title and a re-expand tool.&lt;/p&gt;
     * &lt;p&gt;When a child item of a {@link Ext.layout.container.Border border layout}, this config has two options:
     * &lt;div class=&quot;mdetail-params&quot;&gt;&lt;ul&gt;
     * &lt;li&gt;&lt;b&gt;&lt;code&gt;undefined/omitted&lt;/code&gt;&lt;/b&gt;&lt;div class=&quot;sub-desc&quot;&gt;When collapsed, a placeholder {@link Ext.panel.Header Header} is injected into the layout to represent the Panel
     * and to provide a UI with a Tool to allow the user to re-expand the Panel.&lt;/div&gt;&lt;/li&gt;
     * &lt;li&gt;&lt;b&gt;&lt;code&gt;header&lt;/code&gt;&lt;/b&gt; : &lt;div class=&quot;sub-desc&quot;&gt;The Panel collapses to leave its header visible as when not inside a {@link Ext.layout.container.Border border layout}.&lt;/div&gt;&lt;/li&gt;
     * &lt;/ul&gt;&lt;/div&gt;&lt;/p&gt;
     */

    <a name="cfg-Ext.panel.Panel-placeHolder"></a>/**
     * @cfg {Mixed} placeHolder
     * &lt;p&gt;&lt;b&gt;Important: This config is only effective for {@link #collapsible} Panels which are direct child items of a {@link Ext.layout.container.Border border layout}
     * when not using the &lt;code&gt;&#39;header&#39;&lt;/code&gt; {@link #collapseMode}.&lt;/b&gt;&lt;/p&gt;
     * &lt;p&gt;&lt;b&gt;Optional.&lt;/b&gt; A Component (or config object for a Component) to show in place of this Panel when this Panel is collapsed by a
     * {@link Ext.layout.container.Border border layout}. Defaults to a generated {@link Ext.panel.Header Header}
     * containing a {@link Ext.panel.Tool Tool} to re-expand the Panel.&lt;/p&gt;
     */

    <a name="cfg-Ext.panel.Panel-floatable"></a>/**
     * @cfg {Boolean} floatable
     * &lt;p&gt;&lt;b&gt;Important: This config is only effective for {@link #collapsible} Panels which are direct child items of a {@link Ext.layout.container.Border border layout}.&lt;/b&gt;&lt;/p&gt;
     * &lt;tt&gt;true&lt;/tt&gt; to allow clicking a collapsed Panel&amp;#39;s {@link #placeHolder} to display the Panel floated
     * above the layout, &lt;tt&gt;false&lt;/tt&gt; to force the user to fully expand a collapsed region by
     * clicking the expand button to see it again (defaults to &lt;tt&gt;true&lt;/tt&gt;).
     */
    floatable: true,

    <a name="cfg-Ext.panel.Panel-collapsible"></a>/**
     * @cfg {Boolean} collapsible
     * &lt;p&gt;True to make the panel collapsible and have an expand/collapse toggle Tool added into
     * the header tool button area. False to keep the panel sized either statically, or by an owning layout manager, with no toggle Tool (defaults to false).&lt;/p&gt;
     * See {@link #collapseMode} and {@link #collapseDirection}
     */
    collapsible: false,

    <a name="cfg-Ext.panel.Panel-collapseDirection"></a>/**
     * @cfg {Boolean} collapseDirection
     * &lt;p&gt;The direction to collapse the Panel when the toggle button is clicked.&lt;/p&gt;
     * &lt;p&gt;Defaults to the {@link #headerPosition}&lt;/p&gt;
     * &lt;p&gt;&lt;b&gt;Important: This config is &lt;u&gt;ignored&lt;/u&gt; for {@link #collapsible} Panels which are direct child items of a {@link Ext.layout.container.Border border layout}.&lt;/b&gt;&lt;/p&gt;
     * &lt;p&gt;Specify as &lt;code&gt;&#39;top&#39;&lt;/code&gt;, &lt;code&gt;&#39;bottom&#39;&lt;/code&gt;, &lt;code&gt;&#39;left&#39;&lt;/code&gt; or &lt;code&gt;&#39;right&#39;&lt;/code&gt;.&lt;/p&gt;
     */

    <a name="cfg-Ext.panel.Panel-closable"></a>/**
     * @cfg {Boolean} closable
     * &lt;p&gt;True to display the &#39;close&#39; tool button and allow the user to close the window, false to
     * hide the button and disallow closing the window (defaults to &lt;code&gt;false&lt;/code&gt;).&lt;/p&gt;
     * &lt;p&gt;By default, when close is requested by clicking the close button in the header, the {@link #close}
     * method will be called. This will &lt;i&gt;{@link Ext.Component#destroy destroy}&lt;/i&gt; the Panel and its content
     * meaning that it may not be reused.&lt;/p&gt;
     * &lt;p&gt;To make closing a Panel &lt;i&gt;hide&lt;/i&gt; the Panel so that it may be reused, set
     * {@link #closeAction} to &#39;hide&#39;.&lt;/p&gt;
     */
    closable: false,

    <a name="cfg-Ext.panel.Panel-closeAction"></a>/**
     * @cfg {String} closeAction
     * &lt;p&gt;The action to take when the close header tool is clicked:
     * &lt;div class=&quot;mdetail-params&quot;&gt;&lt;ul&gt;
     * &lt;li&gt;&lt;b&gt;&lt;code&gt;&#39;{@link #destroy}&#39;&lt;/code&gt;&lt;/b&gt; : &lt;b&gt;Default&lt;/b&gt;&lt;div class=&quot;sub-desc&quot;&gt;
     * {@link #destroy remove} the window from the DOM and {@link Ext.Component#destroy destroy}
     * it and all descendant Components. The window will &lt;b&gt;not&lt;/b&gt; be available to be
     * redisplayed via the {@link #show} method.
     * &lt;/div&gt;&lt;/li&gt;
     * &lt;li&gt;&lt;b&gt;&lt;code&gt;&#39;{@link #hide}&#39;&lt;/code&gt;&lt;/b&gt; : &lt;div class=&quot;sub-desc&quot;&gt;
     * {@link #hide} the window by setting visibility to hidden and applying negative offsets.
     * The window will be available to be redisplayed via the {@link #show} method.
     * &lt;/div&gt;&lt;/li&gt;
     * &lt;/ul&gt;&lt;/div&gt;
     * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; This behavior has changed! setting *does* affect the {@link #close} method
     * which will invoke the approriate closeAction.
     */
    closeAction: &#39;destroy&#39;,

    <a name="cfg-Ext.panel.Panel-dockedItems"></a>/**
     * @cfg {Object/Array} dockedItems
     * A component or series of components to be added as docked items to this panel.
     * The docked items can be docked to either the top, right, left or bottom of a panel.
     * This is typically used for things like toolbars or tab bars:
     * <br><span style="display: none">**/</span>var panel = new Ext.panel.Panel({
    dockedItems: [{
        xtype: &#39;toolbar&#39;,
        dock: &#39;top&#39;,
        items: [{
            text: &#39;Docked to the top&#39;
        }]
    }]
});&lt;/pre&gt;&lt;/code&gt;
     */

    <a name="cfg-Ext.panel.Panel-preventHeader"></a>/**
      * @cfg {Boolean} preventHeader Prevent a Header from being created and shown. Defaults to false.
      */
    preventHeader: false,
         
     <a name="cfg-Ext.panel.Panel-headerPosition"></a>/**
      * @cfg {String} headerPosition Specify as &lt;code&gt;&#39;top&#39;&lt;/code&gt;, &lt;code&gt;&#39;bottom&#39;&lt;/code&gt;, &lt;code&gt;&#39;left&#39;&lt;/code&gt; or &lt;code&gt;&#39;right&#39;&lt;/code&gt;. Defaults to &lt;code&gt;&#39;top&#39;&lt;/code&gt;.
      */
    headerPosition: &#39;top&#39;,

     <a name="cfg-Ext.panel.Panel-frame"></a>/**
     * @cfg {Boolean} frame
     * True to apply a frame to the panel.
     */
    frame: false,

    <a name="cfg-Ext.panel.Panel-frameHeader"></a>/**
     * @cfg {Boolean} frameHeader
     * True to apply a frame to the panel panels header (if &#39;frame&#39; is true).
     */
    frameHeader: true,

    renderTpl: [
        &#39;&lt;div class=&quot;{baseCls}-body&lt;tpl if=&quot;bodyCls&quot;&gt; {bodyCls}&lt;/tpl&gt;&lt;tpl if=&quot;frame&quot;&gt; {baseCls}-body-framed&lt;/tpl&gt;&lt;tpl if=&quot;ui&quot;&gt; {baseCls}-body-{ui}&lt;/tpl&gt;&quot;&lt;tpl if=&quot;bodyStyle&quot;&gt; style=&quot;{bodyStyle}&quot;&lt;/tpl&gt;&gt;&lt;/div&gt;&#39;
    ],

    initComponent: function() {
        var me = this,
            cls;

        me.callParent();
        if (me.unstyled) {
            me.baseCls = me.baseCSSPrefix + &#39;plain&#39;;
        }

        if (me.frame) {
            me.ui = &#39;framed&#39;;
        }

        me.collapsedCls = me.collapsedCls || me.baseCls + &#39;-collapsed&#39;;
        me.collapseDirection = me.collapseDirection || me.headerPosition || Ext.Component.DIRECTION_TOP;

        // CSC class name to add to Header Component upon Panel collapse
        me.collapsedHeaderCls = Ext.baseCSSPrefix + &#39;panel-&#39; + (me.border === false ? &#39;noborder-&#39; : &#39;&#39;) + &#39;collapsed-header&#39;;

        // Backwards compatibility
        me.bridgeToolbars();
    },

    hideBorders : function() {
        var me = this,
            cls = me.baseCls + &#39;-noborder&#39;;

        me.addCls(cls);
        if (me.rendered) {
            me.body.addCls(cls + &#39;-body&#39;);
        }
        else {
            me.renderData.bodyCls = me.renderData.bodyCls || &#39;&#39; + (&#39; &#39; + cls + &#39;-body&#39;);
        }
    },

    showBorders : function() {
        var me = this,
            cls = me.baseCls + &#39;-noborder&#39;;

        me.removeCls(cls);
        if (me.rendered) {
            me.body.removeCls(cls + &#39;-body&#39;);
        }
        else {
            me.renderData.bodyCls = me.renderData.bodyCls.replace(cls + &#39;-body&#39;, &#39;&#39;);
        }
    },

    beforeDestroy: function() {
        Ext.destroy(
            this.ghostPanel,
            this.dd
        );
        this.callParent();
    },

    initAria: function() {
        this.callParent();
        this.initHeaderAria();
    },

    initHeaderAria: function() {
        var me = this,
            el = me.el,
            header = me.header;
        if (el &amp;&amp; header) {
            el.dom.setAttribute(&#39;aria-labelledby&#39;, header.titleCmp.id);
        }
    },

    <a name="method-Ext.panel.Panel-setTitle"></a>/**
     * Set a title for the panel&amp;#39;s header. See {@link Ext.panel.Header#title}.
     * @param {String} title
     */
    setTitle: function(title) {
        var me = this;
        me.title = title;
        if (me.header) {
            me.header.setTitle(title);
        } else {
            me.updateHeader();
        }
        
        if (me.reExpander) {
            me.reExpander.setTitle(title);
        }
    },

    <a name="method-Ext.panel.Panel-setIconClass"></a>/**
     * Set the iconCls for the panel&amp;#39;s header. See {@link Ext.panel.Header#iconCls}.
     * @param cls
     */
    setIconClass: function(cls) {
        this.iconCls = cls;
        var header = this.header;
        if (header) {
            header.setIconClass(cls);
        }
    },

    initItems: function() {
        // Catch addition of descendant fields
        this.on(&#39;add&#39;, this.onSubCmpAdded, this);
        this.callParent(arguments);
    },

    onSubCmpAdded: function(parent, cmp) {
        var minButtonWidth = this.minButtonWidth;

        if (minButtonWidth &amp;&amp; cmp.isButton/* &amp;&amp; parent &amp;&amp; parent.ui == &#39;footer&#39;*/) {
            if (!cmp.hasOwnProperty(&#39;minWidth&#39;)) {
                cmp.minWidth = minButtonWidth;
            }
        }
    },

    bridgeToolbars: function() {
        var me = this,
            fbar,
            buttons = me.buttons,
            minButtonWidth = me.minButtonWidth,
            initToolbar = function(toolbar, pos) {
                if (Ext.isArray(toolbar)) {
                    toolbar = {
                        xtype: &#39;toolbar&#39;,
                        items: toolbar
                    };
                }
                else if (!toolbar.xtype) {
                    toolbar.xtype = &#39;toolbar&#39;;
                }
                toolbar.dock = pos;
            return toolbar;
        };
        
        // Apply the minButtonWidth config to the items in the &#39;buttons&#39; toolbar config
        if (buttons &amp;&amp; minButtonWidth) {
            Ext.each(buttons, function(button) {
                if (Ext.isObject(button) &amp;&amp; !(&#39;minWidth&#39; in button)) {
                    button.minWidth = minButtonWidth;
                }
            });
        }

        // Backwards compatibility
        
        <a name="cfg-Ext.panel.Panel-tbar"></a>/**
         * @cfg {Object/Array} tbar

Convenience method. Short for &#39;Top Bar&#39;.

    tbar: [
      { xtype: &#39;button&#39;, text: &#39;Button 1&#39; }
    ]
    
is equivalent to 
    
    dockedItems: [{
        xtype: &#39;toolbar&#39;,
        dock: &#39;top&#39;,
        items: [
            { xtype: &#39;button&#39;, text: &#39;Button 1&#39; }
        ]
    }]

         * @markdown
         */
        if (me.tbar) {
            me.addDocked(initToolbar(me.tbar, &#39;top&#39;));
            me.tbar = null;
        }

        <a name="cfg-Ext.panel.Panel-bbar"></a>/**
         * @cfg {Object/Array} bbar

Convenience method. Short for &#39;Bottom Bar&#39;.

    bbar: [
      { xtype: &#39;button&#39;, text: &#39;Button 1&#39; }
    ]
    
is equivalent to 
    
    dockedItems: [{
        xtype: &#39;toolbar&#39;,
        dock: &#39;bottom&#39;,
        items: [
            { xtype: &#39;button&#39;, text: &#39;Button 1&#39; }
        ]
    }]

         * @markdown
         */
        if (me.bbar) {
            me.addDocked(initToolbar(me.bbar, &#39;bottom&#39;));
            me.bbar = null;
        }

        <a name="cfg-Ext.panel.Panel-buttons"></a>/**
         * @cfg {Object/Array} buttons

Convenience method used for adding buttons docked to the bottom right of the panel.

    buttons: [
      { text: &#39;Button 1&#39; }
    ]
    
is equivalent to 
    
    dockedItems: [{
        xtype: &#39;toolbar&#39;,
        dock: &#39;bottom&#39;,
        items: [
            { xtype: &#39;component&#39;, flex: 1 },
            { xtype: &#39;button&#39;, text: &#39;Button 1&#39; }
        ]
    }]

         * @markdown
         */
        if (me.buttons) {
            me.fbar = me.buttons;
            me.buttons = null;
        }

        <a name="cfg-Ext.panel.Panel-fbar"></a>/**
         * @cfg {Object/Array} fbar

Convenience method used for adding items to the bottom right of the panel. Short for Footer Bar.

    fbar: [
      { type: &#39;button&#39;, text: &#39;Button 1&#39; }
    ]
    
is equivalent to 
    
    dockedItems: [{
        xtype: &#39;toolbar&#39;,
        dock: &#39;bottom&#39;,
        items: [
            { xtype: &#39;component&#39;, flex: 1 },
            { xtype: &#39;button&#39;, text: &#39;Button 1&#39; }
        ]
    }]

         * @markdown
         */
        if (me.fbar) {
            fbar = initToolbar(me.fbar, &#39;bottom&#39;);
            fbar.ui = &#39;footer&#39;;

            fbar = me.addDocked(fbar)[0];
            fbar.insert(0, {
                flex: 1,
                xtype: &#39;component&#39;,
                focusable: false
            });
            me.fbar = null;
        }
    },

    /**
     * @private
     * Tools are a Panel-specific capabilty.
     * Panel uses initTools. Subclasses may contribute tools by implementing addTools.
     */
    initTools: function() {
        var me = this;

        me.tools = me.tools || [];

        // Add a collapse tool unless configured to not show a collapse tool
        // or to not even show a header.
        if (me.collapsible &amp;&amp; !(me.hideCollapseTool || me.header === false)) {
            me.collapseDirection = me.collapseDirection || me.headerPosition || &#39;top&#39;;
            me.collapseTool = me.expandTool = me.createComponent({
                xtype: &#39;tool&#39;,
                type: &#39;collapse-&#39; + me.collapseDirection,
                expandType: me.getOppositeDirection(me.collapseDirection),
                handler: me.toggleCollapse,
                scope: me
            });

            // Prepend collapse tool is configured to do so.
            if (me.collapseFirst) {
                me.tools.unshift(me.collapseTool);
            }
        }

        // Add subclass-specific tools.
        this.addTools();

        // Make Panel closable.
        if (this.closable) {
            this.addCls(this.baseCls + &#39;-closable&#39;);
            this.addTool({
                type: &#39;close&#39;,
                handler: Ext.Function.bind(this.close, this, [])
            });
        }

        // Append collapse tool if needed.
        if (me.collapseTool &amp;&amp; !me.collapseFirst) {
            me.tools.push(me.collapseTool);
        }
    },

    /**
     * @private
     * Template method to be implemented in subclasses to add their tools after the collapsible tool.
     */
    addTools: Ext.emptyFn,

    <a name="method-Ext.panel.Panel-close"></a>/**
     * &lt;p&gt;Closes the Panel. By default, this method, removes it from the DOM, {@link Ext.Component#destroy destroy}s
     * the Panel object and all its descendant Components. The {@link #beforeclose beforeclose}
     * event is fired before the close happens and will cancel the close action if it returns false.&lt;p&gt;
     * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; This method is not affected by the {@link #closeAction} setting which
     * only affects the action triggered when clicking the {@link #closable &#39;close&#39; tool in the header}.
     * To hide the Panel without destroying it, call {@link #hide}.&lt;/p&gt;
     */
    close: function() {
        if (this.fireEvent(&#39;beforeclose&#39;, this) !== false) {
            this.doClose();
        }
    },

    // private
    doClose: function() {
        this.fireEvent(&#39;close&#39;, this);
        this[this.closeAction]();
    },

    onRender: function(ct, position) {
        var me = this,
            topContainer;

        // Correct border visibility just before render.
        if (me.border === false) {
            me.hideBorders();
        }

        // Add class-specific header tools.
        // Panel adds collapsible and closable.
        me.initTools();

        // Dock the header/title
        me.updateHeader();

        // Call to super after adding the header, to prevent an unnecessary re-layout
        me.callParent(arguments);

        // If initially collapsed, collapsed flag must indicate true current state at this point.
        // Do collapse after the first time the Panel&amp;#39;s structure has been laid out.
        if (me.collapsed) {
            me.collapsed = false;
            topContainer = me.findLayoutController();
            if (topContainer) {
                topContainer.on({
                    afterlayout: function() {
                        me.collapse(null, false, true);
                    },
                    single: true
                });
            } else {
                me.getComponentLayout().afterLayout = function() {
                    delete me.componentLayout.afterLayout;
                    this.constructor.prototype.afterLayout.apply(this, arguments);
                    me.collapse(null, false, true);
                };
            }
        }
    },

    /**
     * Create, hide, or show the header component as appropriate based on the current config.
     * @private
     * @param {Boolean} force True to force the the header to be created
     */
    updateHeader: function(force) {
        var me = this,
            header = me.header,
            title = me.title,
            tools = me.tools;

        if (!me.preventHeader &amp;&amp; (force || title || (tools &amp;&amp; tools.length))) {
            if (!header) {
                header = me.header = new Ext.panel.Header({
                    title       : title,
                    orientation : (me.headerPosition == &#39;left&#39; || me.headerPosition == &#39;right&#39;) ? &#39;vertical&#39; : &#39;horizontal&#39;,
                    dock        : me.headerPosition || &#39;top&#39;,
                    textCls     : me.headerTextCls,
                    iconCls     : me.iconCls,
                    baseCls     : me.baseCls + &#39;-header&#39;,
                    tools       : tools,
                    ui          : me.ui,
                    indicateDrag: me.draggable,
                    frame       : me.frame &amp;&amp; me.frameHeader,
                    ignoreParentFrame : me.frame || me.overlapHeader,
                    listeners   : me.collapsible &amp;&amp; me.titleCollapse ? {
                        click: me.toggleCollapse,
                        scope: me
                    } : null
                });
                me.addDocked(header, 0);

                // Reference the Header&#39;s tool array.
                // Header injects named references.
                me.tools = header.tools;
            }
            header.show();
            me.initHeaderAria();
        } else if (header) {
            header.hide();
        }
    },

    // private
    getContentTarget: function() {
        return this.body;
    },

    getTargetEl: function() {
        return this.body || this.frameBody || this.el;
    },

    addTool: function(tool) {
        this.tools.push(tool);
        var header = this.header;
        if (header) {
            header.addTool(tool);
        }
        this.updateHeader();
    },

    getOppositeDirection: function(d) {
        var c = Ext.Component;
        switch (d) {
            case c.DIRECTION_TOP:
                return c.DIRECTION_BOTTOM;
            case c.DIRECTION_RIGHT:
                return c.DIRECTION_LEFT;
            case c.DIRECTION_BOTTOM:
                return c.DIRECTION_TOP;
            case c.DIRECTION_LEFT:
                return c.DIRECTION_RIGHT;
        }
    },

    <a name="method-Ext.panel.Panel-collapse"></a>/**
     * Collapses the panel body so that the body becomes hidden. Docked Components parallel to the
     * border towards which the collapse takes place will remain visible.  Fires the {@link #beforecollapse} event which will
     * cancel the collapse action if it returns false.
     * @param {Number} direction. The direction to collapse towards. Must be one of&lt;ul&gt;
     * &lt;li&gt;Ext.Component.DIRECTION_TOP&lt;/li&gt;
     * &lt;li&gt;Ext.Component.DIRECTION_RIGHT&lt;/li&gt;
     * &lt;li&gt;Ext.Component.DIRECTION_BOTTOM&lt;/li&gt;
     * &lt;li&gt;Ext.Component.DIRECTION_LEFT&lt;/li&gt;&lt;/ul&gt;
     * @param {Boolean} animate True to animate the transition, else false (defaults to the value of the
     * {@link #animCollapse} panel config)
     * @return {Ext.panel.Panel} this
     */
    collapse: function(direction, animate, /* private - passed if called at render time */ internal) {
        var me = this,
            c = Ext.Component,
            height = me.getHeight(),
            width = me.getWidth(),
            newSize = 0,
            dockedItems = me.dockedItems.items,
            dockedItemCount = dockedItems.length,
            i = 0,
            comp,
            pos,
            anim = {
                from: {
                    height: height,
                    width: width
                },
                to: {
                    height: height,
                    width: width
                },
                listeners: {
                    afteranimate: me.afterCollapse,
                    scope: me
                },
                duration: Ext.num(animate, Ext.fx.Anim.prototype.duration)
            },
            reExpander,
            reExpanderOrientation,
            reExpanderDock,
            getDimension,
            setDimension,
            collapseDimension;

        if (!direction) {
            direction = me.collapseDirection;
        }

        // If internal (Called because of initial collapsed state), then no animation, and no events.
        if (internal) {
            animate = false;
        } else if (me.collapsed || me.fireEvent(&#39;beforecollapse&#39;, me, direction, animate) === false) {
            return false;
        }

        reExpanderDock = direction;
        me.expandDirection = me.getOppositeDirection(direction);

        // Track docked items which we hide during collapsed state
        me.hiddenDocked = [];

        switch (direction) {
            case c.DIRECTION_TOP:
            case c.DIRECTION_BOTTOM:
                me.expandedSize = me.getHeight();
                reExpanderOrientation = &#39;horizontal&#39;;
                collapseDimension = &#39;height&#39;;
                getDimension = &#39;getHeight&#39;;
                setDimension = &#39;setHeight&#39;;

                // Collect the height of the visible header.
                // Hide all docked items except the header.
                // Hide *ALL* docked items if we&#39;re going to end up hiding the whole Panel anyway
                for (; i &lt; dockedItemCount; i++) {
                    comp = dockedItems[i];
                    if (comp.isVisible()) {
                        if (comp.isHeader &amp;&amp; (!comp.dock || comp.dock == &#39;top&#39; || comp.dock == &#39;bottom&#39;)) {
                            reExpander = comp;
                        } else {
                            me.hiddenDocked.push(comp);
                        }
                    }
                }

                if (direction == Ext.Component.DIRECTION_BOTTOM) {
                    pos = me.getPosition()[1] - Ext.fly(me.el.dom.offsetParent).getRegion().top;
                    anim.from.top = pos;
                }
                break;

            case c.DIRECTION_LEFT:
            case c.DIRECTION_RIGHT:
                me.expandedSize = me.getWidth();
                reExpanderOrientation = &#39;vertical&#39;;
                collapseDimension = &#39;width&#39;;
                getDimension = &#39;getWidth&#39;;
                setDimension = &#39;setWidth&#39;;

                // Collect the height of the visible header.
                // Hide all docked items except the header.
                // Hide *ALL* docked items if we&#39;re going to end up hiding the whole Panel anyway
                for (; i &lt; dockedItemCount; i++) {
                    comp = dockedItems[i];
                    if (comp.isVisible()) {
                        if (comp.isHeader &amp;&amp; (comp.dock == &#39;left&#39; || comp.dock == &#39;right&#39;)) {
                            reExpander = comp;
                        } else {
                            me.hiddenDocked.push(comp);
                        }
                    }
                }

                if (direction == Ext.Component.DIRECTION_RIGHT) {
                    pos = me.getPosition()[0] - Ext.fly(me.el.dom.offsetParent).getRegion().left;
                    anim.from.left = pos;
                }
                break;

            default:
                throw(&#39;Panel collapse must be passed a valid Component collapse direction&#39;);
        }

        // No scrollbars when we shrink this Panel
        // And no laying out of any children... we&#39;re effectively *hiding* the body
        me.setAutoScroll(false);
        me.suspendLayout = true;
        me.body.setVisibilityMode(Ext.core.Element.DISPLAY);

        // Disable toggle tool during animated collapse
        if (animate &amp;&amp; me.collapseTool) {
            me.collapseTool.disable();
        }

        // Add the collapsed class now, so that collapsed CSS rules are applied before measurements are taken.
        me.el.addCls(me.collapsedCls);

        // We found a header: Measure it to find the collapse-to size.
        if (reExpander) {
            reExpander.addCls(me.collapsedHeaderCls);
            newSize = reExpander[getDimension]();
        }
        // No header: Render and insert a temporary one, and then measure it.
        else {
            reExpander = {
                hideMode: &#39;offsets&#39;,
                temporary: true,
                title: me.title,
                orientation: reExpanderOrientation,
                dock: reExpanderDock,
                textCls: me.headerTextCls,
                iconCls: me.iconCls,
                baseCls: me.baseCls + &#39;-header&#39;,
                ui: me.ui,
                indicateDrag: me.draggable,
                cls: me.baseCls + &#39;-collapsed-placeholder &#39; + me.collapsedHeaderCls,
                renderTo: me.el
            };
            reExpander[(reExpander.orientation == &#39;horizontal&#39;) ? &#39;tools&#39; : &#39;items&#39;] = [{
                xtype: &#39;tool&#39;,
                type: &#39;expand-&#39; + me.expandDirection,
                handler: me.toggleCollapse,
                scope: me
            }];

            // Capture the size of the re-expander.
            // For vertical headers in IE6 and IE7, this will be sized by a CSS rule in _panel.scss
            reExpander = me.reExpander = Ext.create(&#39;Ext.panel.Header&#39;, reExpander);
            newSize = reExpander[getDimension]();
            reExpander.hide();

            // Insert the new docked item
            me.insertDocked(0, reExpander);
        }

        me.reExpander = reExpander;

        // If collapsing right or down, we&#39;ll be also animating the left or top.
        if (direction == Ext.Component.DIRECTION_RIGHT) {
            anim.to.left = pos + (width - newSize);
        } else if (direction == Ext.Component.DIRECTION_BOTTOM) {
            anim.to.top = pos + (height - newSize);
        }

        // Animate to the new size
        anim.to[collapseDimension] = newSize;

        // Remove any flex config before we attempt to collapse.
        me.savedFlex = me.flex;
        me.savedMinWidth = me.minWidth;
        me.savedMinHeight = me.minHeight;
        me.minWidth = 0;
        me.minHeight = 0;
        delete me.flex;

        if (animate) {
            me.animate(anim);
        } else {
            me.setSize(anim.to.width, anim.to.height);
            if (Ext.isDefined(anim.to.left) || Ext.isDefined(anim.to.top)) {
                me.setPosition(anim.to.left, anim.to.top);
            }
            me.afterCollapse(false, internal);
        }
        return me;
    },

    afterCollapse: function(animated, internal) {
        var me = this,
            i = 0,
            l = me.hiddenDocked.length;

        me.minWidth = me.savedMinWidth;
        me.minHeight = me.savedMinHeight;

        me.body.hide();
        for (; i &lt; l; i++) {
            me.hiddenDocked[i].hide();
        }
        if (me.reExpander) {
            me.reExpander.show();
        }
        me.collapsed = true;

        if (!internal) {
            me.doComponentLayout();
        }

        // If me Panel was configured with a collapse tool in its header, flip it&#39;s type
        if (me.collapseTool) {
            me.collapseTool.setType(&#39;expand-&#39; + me.expandDirection);
        }
        if (!internal) {
            me.fireEvent(&#39;collapse&#39;, me);
        }

        // Re-enable the toggle tool after an animated collapse
        if (animated &amp;&amp; me.collapseTool) {
            me.collapseTool.enable();
        }
    },

    <a name="method-Ext.panel.Panel-expand"></a>/**
     * Expands the panel body so that it becomes visible.  Fires the {@link #beforeexpand} event which will
     * cancel the expand action if it returns false.
     * @param {Boolean} animate True to animate the transition, else false (defaults to the value of the
     * {@link #animCollapse} panel config)
     * @return {Ext.panel.Panel} this
     */
    expand: function(animate) {
        if (!this.collapsed || this.fireEvent(&#39;beforeexpand&#39;, this, animate) === false) {
            return false;
        }
        var me = this,
            i = 0,
            l = me.hiddenDocked.length,
            direction = me.expandDirection,
            height = me.getHeight(),
            width = me.getWidth(),
            pos, anim, satisfyJSLint;

        // Disable toggle tool during animated expand
        if (animate &amp;&amp; me.collapseTool) {
            me.collapseTool.disable();
        }

        // Show any docked items that we hid on collapse
        // And hide the injected reExpander Header
        for (; i &lt; l; i++) {
            me.hiddenDocked[i].hidden = false;
            me.hiddenDocked[i].el.show();
        }
        if (me.reExpander) {
            if (me.reExpander.temporary) {
                me.reExpander.hide();
            } else {
                me.reExpander.removeCls(me.collapsedHeaderCls);
            }
        }

        // If me Panel was configured with a collapse tool in its header, flip it&#39;s type
        if (me.collapseTool) {
            me.collapseTool.setType(&#39;collapse-&#39; + me.collapseDirection);
        }

        // Unset the flag before the potential call to calculateChildBox to calculate our newly flexed size
        me.collapsed = false;

        // Collapsed means body element was hidden
        me.body.show();

        // Remove any collapsed styling before any animation begins
        me.el.removeCls(me.collapsedCls);

        anim = {
            to: {
            },
            from: {
                height: height,
                width: width
            },
            listeners: {
                afteranimate: me.afterExpand,
                scope: me
            }
        };

        if ((direction == Ext.Component.DIRECTION_TOP) || (direction == Ext.Component.DIRECTION_BOTTOM)) {

            // If autoHeight, measure the height now we have shown the body element.
            if (me.autoHeight) {
                me.setCalculatedSize(me.width, null);
                anim.to.height = me.getHeight();

                // Must size back down to collapsed for the animation.
                me.setCalculatedSize(me.width, anim.from.height);
            }
            // If we were flexed, then we can&#39;t just restore to the saved size.
            // We must restore to the currently correct, flexed size, so we much ask the Box layout what that is.
            else if (me.savedFlex) {
                me.flex = me.savedFlex;
                anim.to.height = me.ownerCt.layout.calculateChildBox(me).height;
                delete me.flex;
            }
            // Else, restore to saved height
            else {
                anim.to.height = me.expandedSize;
            }

            // top needs animating upwards
            if (direction == Ext.Component.DIRECTION_TOP) {
                pos = me.getPosition()[1] - Ext.fly(me.el.dom.offsetParent).getRegion().top;
                anim.from.top = pos;
                anim.to.top = pos - (anim.to.height - height);
            }
        } else if ((direction == Ext.Component.DIRECTION_LEFT) || (direction == Ext.Component.DIRECTION_RIGHT)) {

            // If autoWidth, measure the width now we have shown the body element.
            if (me.autoWidth) {
                me.setCalculatedSize(null, me.height);
                anim.to.width = me.getWidth();

                // Must size back down to collapsed for the animation.
                me.setCalculatedSize(anim.from.width, me.height);
            }
            // If we were flexed, then we can&#39;t just restore to the saved size.
            // We must restore to the currently correct, flexed size, so we much ask the Box layout what that is.
            else if (me.savedFlex) {
                me.flex = me.savedFlex;
                anim.to.width = me.ownerCt.layout.calculateChildBox(me).width;
                delete me.flex;
            }
            // Else, restore to saved width
            else {
                anim.to.width = me.expandedSize;
            }

            // left needs animating leftwards
            if (direction == Ext.Component.DIRECTION_LEFT) {
                pos = me.getPosition()[0] - Ext.fly(me.el.dom.offsetParent).getRegion().left;
                anim.from.left = pos;
                anim.to.left = pos - (anim.to.width - width);
            }
        }

        if (animate) {
            me.animate(anim);
        } else {
            me.setSize(anim.to.width, anim.to.height);
            if (anim.to.x) {
                me.setLeft(anim.to.x);
            }
            if (anim.to.y) {
                me.setTop(anim.to.y);
            }
            me.afterExpand(false);
        }

        return me;
    },

    afterExpand: function(animated) {
        var me = this;
        me.setAutoScroll(me.initialConfig.autoScroll);

        // Restored to a calculated flex. Delete the set width and height properties so that flex works from now on.
        if (me.savedFlex) {
            me.flex = me.savedFlex;
            delete me.savedFlex;
            delete me.width;
            delete me.height;
        }

        // Reinstate layout out after Panel has re-expanded
        delete me.suspendLayout;
        delete me.layout.onLayout;
        if (animated &amp;&amp; me.ownerCt) {
            me.ownerCt.doLayout();
        }

        me.fireEvent(&#39;expand&#39;, me);

        // Re-enable the toggle tool after an animated expand
        if (animated &amp;&amp; me.collapseTool) {
            me.collapseTool.enable();
        }
    },

    <a name="method-Ext.panel.Panel-toggleCollapse"></a>/**
     * Shortcut for performing an {@link #expand} or {@link #collapse} based on the current state of the panel.
     * @return {Ext.panel.Panel} this
     */
    toggleCollapse: function() {
        if (this.collapsed) {
            this.expand(this.animCollapse);
        } else {
            this.collapse(this.collapseDirection, this.animCollapse);
        }
        return this;
    },

    // private
    getKeyMap : function(){
        if(!this.keyMap){
            this.keyMap = new Ext.util.KeyMap(this.el, this.keys);
        }
        return this.keyMap;
    },

    // private
    initDraggable : function(){
        <a name="prop-Ext.panel.Panel-dd"></a>/**
         * &lt;p&gt;If this Panel is configured {@link #draggable}, this property will contain
         * an instance of {@link Ext.dd.DragSource} which handles dragging the Panel.&lt;/p&gt;
         * The developer must provide implementations of the abstract methods of {@link Ext.dd.DragSource}
         * in order to supply behaviour for each stage of the drag/drop process. See {@link #draggable}.
         * @type Ext.dd.DragSource.
         * @property dd
         */
        this.dd = new Ext.panel.DD(this, Ext.isBoolean(this.draggable) ? null : this.draggable);
    },

    // private - used for dragging
    ghost: function(cls) {
        var me = this,
            box = me.getBox();

        if (!me.ghostPanel) {
            me.ghostPanel = new Ext.panel.Panel({
                renderTo: document.body,
                floating: {
                    shadow: false
                },
                frame: Ext.supports.CSS3BorderRadius ? me.frame : false,
                title: me.title,
                overlapHeader: me.overlapHeader,
                headerPosition: me.headerPosition,
                width: me.getWidth(),
                height: me.getHeight(),
                iconCls: me.iconCls,
                baseCls: me.baseCls,
                tools: me.initialConfig.tools || [{
                    type: &#39;placeholder&#39;
                }],
                cls: me.baseCls + &#39;-ghost &#39; + (cls ||&#39;&#39;)
            });
        }
        me.ghostPanel.floatParent = me.floatParent;
        me.ghostPanel.setZIndex(Ext.num(me.el.getStyle(&#39;zIndex&#39;), 0));
        me.ghostPanel.el.show();
        me.ghostPanel.setPosition(box.x, box.y);
        me.ghostPanel.setSize(box.width, box.height);
        me.el.hide();
        if (me.floatingItems) {
            me.floatingItems.hide();
        }
        return me.ghostPanel;
    },

    // private
    unghost: function(show, matchPosition) {
        var me = this;
        if (!me.ghostPanel) {
            return;
        }
        if (show !== false) {
            me.el.show();
            if (matchPosition !== false) {
                me.setPosition(me.ghostPanel.getPosition());
            }
            if (me.floatingItems) {
                me.floatingItems.show();
            }
            Ext.defer(me.focus, 10, me);
        }
        me.ghostPanel.el.hide();
    },

    // should update body&#39;s el.
    doAutoLoad: function() {

    }
});
￿</pre></pre></body></html>