<!DOCTYPE html><html><head><title>Sencha Documentation Project</title><link rel="stylesheet" href="../reset.css" type="text/css"><link rel="stylesheet" href="../prettify.css" type="text/css"><link rel="stylesheet" href="../prettify_sa.css" type="text/css"><script type="text/javascript" src="../prettify.js"></script></head><body onload="prettyPrint()"><pre class="prettyprint"><pre>Ext.define(&#39;Ext.data.BufferStore&#39;, {
    extend: &#39;Ext.data.Store&#39;,
    alias: &#39;store.buffer&#39;,
    purgePageCount: 4,
    
    constructor: function() {
        // key is by index rather than internalId
        this.prefetchData = new Ext.util.MixedCollection(false, function(record) {
            return record.index;
        });
        this.pendingRequests = [];
        this.pagesRequested = [];

        this.callParent(arguments);
    },
    
    <a name="method-Ext.data.BelongsToAssociation-prefetch"></a>/**
     * Loads the Store using its configured {@link #proxy}.
     * @param {Object} options Optional config object. This is passed into the {@link Ext.data.Operation Operation}
     * object that is created and then sent to the proxy&#39;s {@link Ext.data.Proxy#read} function
     */
    prefetch: function(options) {
        var me = this,
            operation,
            requestId = this.getRequestId();

        options = options || {};

        Ext.applyIf(options, {
            action : &#39;read&#39;,
            filters: me.filters.items,
            sorters: me.sorters.items,
            requestId: requestId
        });
        this.pendingRequests.push(requestId);

        operation = Ext.create(&#39;Ext.data.Operation&#39;, options);

        // HACK to implement loadMask support.
        //if (operation.blocking) {
        //    me.fireEvent(&#39;beforeload&#39;, me, operation);
        //}
        if (me.fireEvent(&#39;beforeprefetch&#39;, me, operation) !== false) {
            me.loading = true;
            me.proxy.read(operation, me.onProxyPrefetch, me);
        }
        
        return me;
    },
    
    prefetchPage: function(page, opts) {
        var me = this,
            pageSize = me.pageSize,
            start = (page - 1) * me.pageSize,
            end = start + pageSize;
        
        // Currently not requesting this page and range isn&#39;t already satisified 
        if (Ext.Array.indexOf(this.pagesRequested, page) === -1 &amp;&amp; !this.rangeSatisfied(start, end)) {
            //console.log(&#39;----&gt; Issuing request to prefetch page: &#39;, page);
            opts = opts || {};
            this.pagesRequested.push(page);
            Ext.applyIf(opts, {
                page : page,
                start: start,
                limit: pageSize,
                callback: me.onWaitForGuarantee,
                scope: me
            });
            
            me.prefetch(opts);
        }
        
    },
    
    /**
     * Returns a unique requestId to track requests.
     * @private
     */
    getRequestId: function() {
        this.requestSeed = this.requestSeed || 1;
        return this.requestSeed++;
    },
    
    onProxyPrefetch: function(operation) {
        var me         = this,
            resultSet  = operation.getResultSet(),
            records    = operation.getRecords(),
            
            successful = operation.wasSuccessful();
        
        if (resultSet) {
            me.totalCount = resultSet.total;
        }
        
        if (successful) {
            me.cacheRecords(records, operation);
        }
        Ext.Array.remove(this.pendingRequests, operation.requestId);
        if (operation.page) {
            Ext.Array.remove(this.pagesRequested, operation.page);
        }
        
        me.loading = false;
        me.fireEvent(&#39;prefetch&#39;, me, records, successful, operation);
        
        // HACK to support loadMask
        if (operation.blocking) {
            me.fireEvent(&#39;load&#39;, me, records, successful);
        }

        //this is a callback that would have been passed to the &#39;read&#39; function and is optional
        Ext.callback(operation.callback, operation.scope || me, [records, operation, successful]);
    },
    
    /**
     * Caches the records in the prefetch and stripes them with their server-side
     * index.
     * @private
     */
    cacheRecords: function(records, operation) {
        var me     = this,
            i      = 0,
            length = records.length;
        
        for (; i &lt; length; i++) {
            // this is the true index, not the viewIndex
            records[i].index = operation.start + i;
        }
        
        me.prefetchData.addAll(records);
        this.purgeRecords();
    },
    
    
    /**
     * Purge the least recently used records in the prefetch if the purgeCount
     * has been exceeded.
     * @private
     */
    purgeRecords: function() {
        var me = this,
            prefetchCount = me.prefetchData.getCount(),
            purgeCount = me.purgePageCount * me.pageSize,
            numRecordsToPurge = prefetchCount - purgeCount - 1,
            i = 0;

        for (; i &lt;= numRecordsToPurge; i++) {
            this.prefetchData.removeAt(0);
        }
    },
    
    /**
     * Determines if the range has already been satisified in the prefetchData.
     * @private
     */
    rangeSatisfied: function(start, end) {
        var me = this,
            i = start,
            satisfied = true;

        for (; i &lt; end; i++) {
            if (!me.prefetchData.getByKey(i)) {
                satisfied = false;
                if (end - i &gt; this.pageSize) {
                    throw &quot;BufferStore: a single page prefetch could never satisfy this request.&quot;;
                }
                break;
            }
        }
        return satisfied;
    },
    
    <a name="method-Ext.data.BelongsToAssociation-getPageFromRecordIndex"></a>/**
     * Determines the page from a record index
     */
    getPageFromRecordIndex: function(index) {
        return Math.floor(index / this.pageSize) + 1;
    },
    
    onGuaranteedRange: function() {
        var me = this,
            totalCount = me.getTotalCount(),
            start = me.requestStart,
            end = ((totalCount - 1) &lt; me.requestEnd) ? totalCount - 1 : me.requestEnd,
            range = [],
            record,
            i = start;
            
        if (start !== me.guaranteedStart &amp;&amp; end !== me.guaranteedEnd) {
            me.guaranteedStart = start;
            me.guaranteedEnd = end;
            
            for (; i &lt;= end; i++) {
                record = me.prefetchData.getByKey(i);
                if (!record) {
                    throw &quot;Record was not found and store said it was guaranteed&quot;;
                }
                range.push(record);
            }
            me.removeAll();
            me.add(range);
            //me.loadRecords(range);
            if (me.cb) {
                me.cb.call(me.scope || me, range);
            }
        }
        
        this.unmask();
    },
    
    // hack to support loadmask
    mask: function() {
        this.masked = true;
        this.fireEvent(&#39;beforeload&#39;);
    },
    
    // hack to support loadmask
    unmask: function() {
        if (this.masked) {
            this.fireEvent(&#39;load&#39;);
        }
    },
    
    <a name="method-Ext.data.BelongsToAssociation-hasPendingRequests"></a>/**
     * Returns the number of pending requests out.
     */
    hasPendingRequests: function() {
        return this.pendingRequests.length;
    },
    
    
    // wait until all requests finish, until guaranteeing the range.
    onWaitForGuarantee: function() {
        //console.log(&#39;Waiting for a guarantee; has pending requests: &#39;, this.hasPendingRequests())
        if (!this.hasPendingRequests()) {
            this.onGuaranteedRange();
        }
    },
    
    <a name="method-Ext.data.BelongsToAssociation-guaranteeRange"></a>/**
     * Guarantee a specific range, this will load the store with a range (that
     * must be the pageSize or smaller) and take care of any loading that may
     * be necessary.
     */
    guaranteeRange: function(start, end, cb, scope) {
        //console.log(&quot; --- Attempting to guaranteeRange: &quot;, start, end, &quot; ---- &quot;);
        if (start &amp;&amp; end) {
            if (end - start &gt; this.pageSize) {
                throw &quot;BufferStore: requested a bigger range than the pageSize&quot;;
            }
        }
        
        var me = this,
            i = start,
            prefetchData = me.prefetchData,
            range = [],
            startLoaded = !!prefetchData.getByKey(start),
            endLoaded = !!prefetchData.getByKey(end),
            startPage = this.getPageFromRecordIndex(start),
            endPage = this.getPageFromRecordIndex(end);
            
        me.cb = cb;
        me.scope = scope;
        me.requestStart = start;
        me.requestEnd = end;
        // neither beginning or end are loaded
        if (!startLoaded || !endLoaded) {
            // same page, lets load it
            if (startPage === endPage) {
                this.mask();
                this.prefetchPage(startPage, {
                    //blocking: true,
                    callback: this.onWaitForGuarantee,
                    scope: this
                });
            // need to load two pages
            } else {
                this.mask();
                this.prefetchPage(startPage, {
                    //blocking: true,
                    callback: this.onWaitForGuarantee,
                    scope: this
                });
                this.prefetchPage(endPage, {
                    //blocking: true,
                    callback: this.onWaitForGuarantee,
                    scope: this
                });
            }
        // Request was already satisified via the prefetch
        } else {
            this.onGuaranteedRange();
        }
    },
    
    // because prefetchData is stored by index
    // this invalidates all of the prefetchedData
    sort: function() {
        this.prefetchData.clear();
        this.callParent(arguments);
    }
});￿</pre></pre></body></html>