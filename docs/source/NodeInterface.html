<!DOCTYPE html><html><head><title>Sencha Documentation Project</title><link rel="stylesheet" href="../reset.css" type="text/css"><link rel="stylesheet" href="../prettify.css" type="text/css"><link rel="stylesheet" href="../prettify_sa.css" type="text/css"><script type="text/javascript" src="../prettify.js"></script></head><body onload="prettyPrint()"><pre class="prettyprint"><pre><a name="cls-Ext.data.NodeInterface"></a>/**
 * @class Ext.data.NodeInterface
 * @extends Object
 * This class is meant to be used as a set of methods that are applied to the prototype of a
 * Record to decorate it with a Node API.
 */
Ext.define(&#39;Ext.data.NodeInterface&#39;, {
    requires: [&#39;Ext.data.Field&#39;],
    
    statics: {
        <a name="method-Ext.data.NodeInterface-Ext.data.NodeInterface.decorate"></a>/**
         * This method allows you to decorate a Record&#39;s prototype to implement the NodeInterface.
         * This adds a set of methods, new events, new properties and new fields on every Record
         * with the same Model as the passed Record.
         * @param {Ext.data.Record} record The Record you want to decorate the prototype of.
         * @static
         */
        decorate: function(record) {
            if (!record.isNode) {
                // Apply the methods and fields to the prototype
                // @TODO: clean this up to use proper class system stuff
                var mgr = Ext.ModelMgr,
                    modelName = record.modelName,
                    modelClass = mgr.getModel(modelName),
                    modelPrototype = modelClass.prototype,
                    fields = modelPrototype.fields,
                    keys = fields.keys,
                    instances = Ext.Array.filter(mgr.all.getArray(), function(item) {
                        return item.modelName == modelName;
                    }),
                    iln = instances.length,
                    newFields = [],
                    i, instance, jln, j, newField;

                // Start by adding the NodeInterface methods to the Model&#39;s prototype
                modelClass.override(this.getPrototypeBody());

                if (!keys[&#39;id&#39;]) {
                    newFields.push(fields.add(Ext.create(&#39;data.field&#39;, {name: &#39;id&#39;, type: &#39;string&#39;, defaultValue: null})));
                }
                if (!keys[&#39;depth&#39;]) {
                    newFields.push(fields.add(Ext.create(&#39;data.field&#39;, {name: &#39;depth&#39;, type: &#39;int&#39;, defaultValue: 0})));
                }
                if (!keys[&#39;expanded&#39;]) {
                    newFields.push(fields.add(Ext.create(&#39;data.field&#39;, {name: &#39;expanded&#39;, type: &#39;bool&#39;, defaultValue: false})));
                }
                if (!keys[&#39;checked&#39;]) {
                    newFields.push(fields.add(Ext.create(&#39;data.field&#39;, {name: &#39;checked&#39;, defaultValue: null})));
                }
                if (!keys[&#39;leaf&#39;]) {
                    newFields.push(fields.add(Ext.create(&#39;data.field&#39;, {name: &#39;leaf&#39;, type: &#39;bool&#39;, defaultValue: false})));
                }
                if (!keys[&#39;cls&#39;]) {
                    newFields.push(fields.add(Ext.create(&#39;data.field&#39;, {name: &#39;cls&#39;, type: &#39;string&#39;, defaultValue: null})));
                }
                if (!keys[&#39;iconCls&#39;]) {
                    newFields.push(fields.add(Ext.create(&#39;data.field&#39;, {name: &#39;iconCls&#39;, type: &#39;string&#39;, defaultValue: null})));
                }
                if (!keys[&#39;root&#39;]) {
                    newFields.push(fields.add(Ext.create(&#39;data.field&#39;, {name: &#39;root&#39;, type: &#39;boolean&#39;, defaultValue: false})));
                }
                if (!keys[&#39;isLast&#39;]) {
                    newFields.push(fields.add(Ext.create(&#39;data.field&#39;, {name: &#39;isLast&#39;, type: &#39;boolean&#39;, defaultValue: false})));
                }
                if (!keys[&#39;isFirst&#39;]) {
                    newFields.push(fields.add(Ext.create(&#39;data.field&#39;, {name: &#39;isFirst&#39;, type: &#39;boolean&#39;, defaultValue: false})));
                }
                if (!keys[&#39;allowDrop&#39;]) {
                    newFields.push(fields.add(Ext.create(&#39;data.field&#39;, {name: &#39;allowDrop&#39;, type: &#39;boolean&#39;, defaultValue: true})));
                }
                if (!keys[&#39;allowDrag&#39;]) {
                    newFields.push(fields.add(Ext.create(&#39;data.field&#39;, {name: &#39;allowDrag&#39;, type: &#39;boolean&#39;, defaultValue: true})));
                }
                if (!keys[&#39;loaded&#39;]) {
                    newFields.push(fields.add(Ext.create(&#39;data.field&#39;, {name: &#39;loaded&#39;, type: &#39;boolean&#39;, defaultValue: false})));
                }  
                                                                    
                jln = newFields.length;
                // Set default values to all instances already out there
                for (i = 0; i &lt; iln; i++) {
                    instance = instances[i];
                    for (j = 0; j &lt; jln; j++) {
                        newField = newFields[j];
                        if (instance.get(newField.name) === undefined) {
                            instance.data[newField.name] = newField.defaultValue;
                        }
                    }
                }
            }
            
            Ext.applyIf(record, {
                firstChild: null,
                lastChild: null,
                parentNode: null,
                previousSibling: null,
                nextSibling: null,
                childNodes: []
            });
            
            record.enableBubble([
                <a name="event-Ext.data.NodeInterface-append"></a>/**
                 * @event append
                 * Fires when a new child node is appended
                 * @param {Node} this This node
                 * @param {Node} node The newly appended node
                 * @param {Number} index The index of the newly appended node
                 */
                &quot;append&quot;,

                <a name="event-Ext.data.NodeInterface-remove"></a>/**
                 * @event remove
                 * Fires when a child node is removed
                 * @param {Node} this This node
                 * @param {Node} node The removed node
                 */
                &quot;remove&quot;,

                <a name="event-Ext.data.NodeInterface-move"></a>/**
                 * @event move
                 * Fires when this node is moved to a new location in the tree
                 * @param {Node} this This node
                 * @param {Node} oldParent The old parent of this node
                 * @param {Node} newParent The new parent of this node
                 * @param {Number} index The index it was moved to
                 */
                &quot;move&quot;,

                <a name="event-Ext.data.NodeInterface-insert"></a>/**
                 * @event insert
                 * Fires when a new child node is inserted.
                 * @param {Node} this This node
                 * @param {Node} node The child node inserted
                 * @param {Node} refNode The child node the node was inserted before
                 */
                &quot;insert&quot;,

                <a name="event-Ext.data.NodeInterface-beforeappend"></a>/**
                 * @event beforeappend
                 * Fires before a new child is appended, return false to cancel the append.
                 * @param {Node} this This node
                 * @param {Node} node The child node to be appended
                 */
                &quot;beforeappend&quot;,

                <a name="event-Ext.data.NodeInterface-beforeremove"></a>/**
                 * @event beforeremove
                 * Fires before a child is removed, return false to cancel the remove.
                 * @param {Node} this This node
                 * @param {Node} node The child node to be removed
                 */
                &quot;beforeremove&quot;,

                <a name="event-Ext.data.NodeInterface-beforemove"></a>/**
                 * @event beforemove
                 * Fires before this node is moved to a new location in the tree. Return false to cancel the move.
                 * @param {Node} this This node
                 * @param {Node} oldParent The parent of this node
                 * @param {Node} newParent The new parent this node is moving to
                 * @param {Number} index The index it is being moved to
                 */
                &quot;beforemove&quot;,

                 <a name="event-Ext.data.NodeInterface-beforeinsert"></a>/**
                  * @event beforeinsert
                  * Fires before a new child is inserted, return false to cancel the insert.
                  * @param {Node} this This node
                  * @param {Node} node The child node to be inserted
                  * @param {Node} refNode The child node the node is being inserted before
                  */
                &quot;beforeinsert&quot;,
                
                <a name="event-Ext.data.NodeInterface-expand"></a>/**
                 * @event expand
                 * Fires when this node is expanded.
                 * @param {Node} this The expanding node
                 */
                &quot;expand&quot;,
                
                <a name="event-Ext.data.NodeInterface-collapse"></a>/**
                 * @event collapse
                 * Fires when this node is collapsed.
                 * @param {Node} this The collapsing node
                 */
                &quot;collapse&quot;,
                
                <a name="event-Ext.data.NodeInterface-beforeexpand"></a>/**
                 * @event beforeexpand
                 * Fires before this node is expanded.
                 * @param {Node} this The expanding node
                 */
                &quot;beforeexpand&quot;,
                
                <a name="event-Ext.data.NodeInterface-beforecollapse"></a>/**
                 * @event beforecollapse
                 * Fires before this node is collapsed.
                 * @param {Node} this The collapsing node
                 */
                &quot;beforecollapse&quot;,
                
                <a name="event-Ext.data.NodeInterface-beforecollapse"></a>/**
                 * @event beforecollapse
                 * Fires before this node is collapsed.
                 * @param {Node} this The collapsing node
                 */
                &quot;sort&quot;
            ]);
            
            return record;
        },
        
        getPrototypeBody: function() {
            return {
                isNode: true,

                <a name="method-Ext.data.NodeInterface-createNode"></a>/**
                 * Ensures that the passed object is an instance of a Record with the NodeInterface applied
                 * @return {Boolean}
                 */
                createNode: function(node) {
                    if (Ext.isObject(node) &amp;&amp; !node.isModel) {
                        node = Ext.ModelMgr.create(node, this.modelName);
                    }
                    // Make sure the node implements the node interface
                    return Ext.data.NodeInterface.decorate(node);
                },
                
                <a name="method-Ext.data.NodeInterface-isLeaf"></a>/**
                 * Returns true if this node is a leaf
                 * @return {Boolean}
                 */
                isLeaf : function() {
                    return this.get(&#39;leaf&#39;) === true;
                },

                // private
                setFirstChild : function(node) {
                    this.firstChild = node;
                },

                //private
                setLastChild : function(node) {
                    this.lastChild = node;
                },

                <a name="method-Ext.data.NodeInterface-updateInfo"></a>/**
                 * Updates general data of this node like isFirst, isLast, depth. This
                 * method is internally called after a node is moved. This shouldn&#39;t
                 * have to be called by the developer unless they are creating custom
                 * Tree plugins.
                 * @return {Boolean}
                 */
                updateInfo: function() {
                    var me = this,
                        isRoot = me.isRoot(),
                        isFirst = (!me.parentNode ? true : me.parentNode.firstChild == this),
                        isLast = (!me.parentNode ? true : me.parentNode.lastChild == this),
                        depth = 0,
                        parent = me,
                        children = me.childNodes,
                        ln = children.length,
                        i;

                    while (parent.parentNode) {
                        ++depth;
                        parent = parent.parentNode;
                    }                                            
                    
                    me.set({
                        isFirst: isFirst,
                        isLast: isLast,
                        depth: depth
                    });
                    
                    if (ln) {
                        for (i = 0; i &lt; ln; i++) {
                            children[i].updateInfo();
                        }
                    }
                },

                <a name="method-Ext.data.NodeInterface-isLast"></a>/**
                 * Returns true if this node is the last child of its parent
                 * @return {Boolean}
                 */
                isLast : function() {
                   return this.get(&#39;isLast&#39;);
                },

                <a name="method-Ext.data.NodeInterface-isFirst"></a>/**
                 * Returns true if this node is the first child of its parent
                 * @return {Boolean}
                 */
                isFirst : function() {
                   return this.get(&#39;isFirst&#39;);
                },

                <a name="method-Ext.data.NodeInterface-hasChildNodes"></a>/**
                 * Returns true if this node has one or more child nodes, else false.
                 * @return {Boolean}
                 */
                hasChildNodes : function() {
                    return !this.isLeaf() &amp;&amp; this.childNodes.length &gt; 0;
                },

                <a name="method-Ext.data.NodeInterface-isExpandable"></a>/**
                 * Returns true if this node has one or more child nodes, or if the &lt;tt&gt;expandable&lt;/tt&gt;
                 * node attribute is explicitly specified as true (see {@link #attributes}), otherwise returns false.
                 * @return {Boolean}
                 */
                isExpandable : function() {
                    return this.get(&#39;expandable&#39;) || this.hasChildNodes();
                },

                <a name="method-Ext.data.NodeInterface-appendChild"></a>/**
                 * &lt;p&gt;Insert node(s) as the last child node of this node.&lt;/p&gt;
                 * &lt;p&gt;If the node was previously a child node of another parent node, it will be removed from that node first.&lt;/p&gt;
                 * @param {Node/Array} node The node or Array of nodes to append
                 * @return {Node} The appended node if single append, or null if an array was passed
                 */
                appendChild : function(node, suppressEvents) {
                    var me = this,
                        i, ln;

                    // if passed an array or multiple args do them one by one
                    if (Ext.isArray(node)) {
                        for (i = 0, ln = node.length; i &lt; ln; i++) {
                            me.appendChild(node[i]);
                        }
                    } else {
                        // Make sure it is a record
                        node = me.createNode(node);
                        
                        if (suppressEvents !== true &amp;&amp; me.fireEvent(&quot;beforeappend&quot;, me, node) === false) {
                            return false;                         
                        }

                        var index = me.childNodes.length;
                        var oldParent = node.parentNode;

                        // it&#39;s a move, make sure we move it cleanly
                        if (oldParent) {
                            if (suppressEvents !== true &amp;&amp; node.fireEvent(&quot;beforemove&quot;, node, oldParent, me, index) === false) {
                                return false;
                            }
                            oldParent.removeChild(node);
                        }

                        index = me.childNodes.length;
                        if (index === 0) {
                            me.setFirstChild(node);
                        }

                        me.childNodes.push(node);
                        node.parentNode = me;
                        node.nextSibling = null;

                        me.setLastChild(node);
                                                
                        var ps = me.childNodes[index - 1];
                        if (ps) {
                            node.previousSibling = ps;
                            ps.nextSibling = node;
                            ps.updateInfo();
                        } else {
                            node.previousSibling = null;
                        }

                        node.updateInfo();
                        
                        // As soon as we append a child to this node, we are loaded
                        if (!me.isLoaded()) {
                            me.set(&#39;loaded&#39;, true);                            
                        }
                        
                        if (suppressEvents !== true) {
                            me.fireEvent(&quot;append&quot;, me, node, index);

                            if (oldParent) {
                                node.fireEvent(&quot;move&quot;, node, oldParent, me, index);
                            }                            
                        }

                        return node;
                    }
                },
                
                getBubbleTarget: function() {
                    return this.parentNode;
                },

                <a name="method-Ext.data.NodeInterface-removeChild"></a>/**
                 * Removes a child node from this node.
                 * @param {Node} node The node to remove
                 * @param {Boolean} destroy &lt;tt&gt;true&lt;/tt&gt; to destroy the node upon removal. Defaults to &lt;tt&gt;false&lt;/tt&gt;.
                 * @return {Node} The removed node
                 */
                removeChild : function(node, destroy, suppressEvents) {
                    var me = this,
                        index = me.indexOf(node);
                    
                    if (index == -1 || (suppressEvents !== true &amp;&amp; me.fireEvent(&quot;beforeremove&quot;, me, node) === false)) {
                        return false;
                    }

                    // remove it from childNodes collection
                    me.childNodes.splice(index, 1);

                    // update child refs
                    if (me.firstChild == node) {
                        me.setFirstChild(node.nextSibling);
                    }
                    if (me.lastChild == node) {
                        me.setLastChild(node.previousSibling);
                    }
                    
                    // update siblings
                    if (node.previousSibling) {
                        node.previousSibling.nextSibling = node.nextSibling;
                        node.previousSibling.updateInfo();
                    }
                    if (node.nextSibling) {
                        node.nextSibling.previousSibling = node.previousSibling;
                        node.nextSibling.updateInfo();
                    }

                    if (suppressEvents !== true) {
                        me.fireEvent(&quot;remove&quot;, me, node);
                    }
                    
                    if (destroy) {
                        node.destroy(true);
                    } else {
                        node.clear();
                    }

                    return node;
                },

                <a name="method-Ext.data.NodeInterface-copy"></a>/**
                 * Creates a copy (clone) of this Node.
                 * @param {String} id (optional) A new id, defaults to this Node&#39;s id. See &lt;code&gt;{@link #id}&lt;/code&gt;.
                 * @param {Boolean} deep (optional) &lt;p&gt;If passed as &lt;code&gt;true&lt;/code&gt;, all child Nodes are recursively copied into the new Node.&lt;/p&gt;
                 * &lt;p&gt;If omitted or false, the copy will have no child Nodes.&lt;/p&gt;
                 * @return {Node} A copy of this Node.
                 */
                copy: function(newId, deep) {
                    var me = this,
                        result = me.callOverridden(arguments),
                        len = me.childNodes ? me.childNodes.length : 0,
                        i;

                    // Move child nodes across to the copy if required
                    if (deep) {
                        for (i = 0; i &lt; len; i++) {
                            result.appendChild(me.childNodes[i].copy(true));
                        }
                    }
                    return result;
                },

                // private
                clear : function(destroy) {
                    // clear any references from the node
                    this.parentNode = this.previousSibling = this.nextSibling = null;
                    if (destroy) {
                        this.firstChild = this.lastChild = null;
                    }
                },

                <a name="method-Ext.data.NodeInterface-destroy"></a>/**
                 * Destroys the node.
                 */
                destroy : function(silent) {
                    /*
                     * Silent is to be used in a number of cases
                     * 1) When setRoot is called.
                     * 2) When destroy on the tree is called
                     * 3) For destroying child nodes on a node
                     */
                    if (silent === true) {
                        this.clear(true);
                        Ext.each(this.childNodes, function(n) {
                            n.destroy(true);
                        });
                        this.childNodes = null;
                    } else {
                        this.remove(true);
                    }

                    this.callOverridden();
                },

                <a name="method-Ext.data.NodeInterface-insertBefore"></a>/**
                 * Inserts the first node before the second node in this nodes childNodes collection.
                 * @param {Node} node The node to insert
                 * @param {Node} refNode The node to insert before (if null the node is appended)
                 * @return {Node} The inserted node
                 */
                insertBefore : function(node, refNode, suppressEvents) {
                    var me = this,
                        index     = me.indexOf(refNode),
                        oldParent = node.parentNode,
                        refIndex  = index;
                    
                    if (!refNode) { // like standard Dom, refNode can be null for append
                        return me.appendChild(node);
                    }
                    
                    // nothing to do
                    if (node == refNode) {
                        return false;
                    }

                    // Make sure it is a record with the NodeInterface
                    node = me.createNode(node);
                    
                    if (suppressEvents !== true &amp;&amp; me.fireEvent(&quot;beforeinsert&quot;, me, node, refNode) === false) {
                        return false;
                    }
                    
                    // when moving internally, indexes will change after remove
                    if (oldParent == me &amp;&amp; me.indexOf(node) &lt; index) {
                        refIndex--;
                    }

                    // it&#39;s a move, make sure we move it cleanly
                    if (oldParent) {
                        if (suppressEvents !== true &amp;&amp; node.fireEvent(&quot;beforemove&quot;, node, oldParent, me, index, refNode) === false) {
                            return false;
                        }
                        oldParent.removeChild(node);
                    }

                    if (refIndex === 0) {
                        me.setFirstChild(node);
                    }

                    me.childNodes.splice(refIndex, 0, node);
                    node.parentNode = me;
                    
                    node.nextSibling = refNode;
                    refNode.previousSibling = node;
                    
                    var ps = me.childNodes[refIndex - 1];
                    if (ps) {
                        node.previousSibling = ps;
                        ps.nextSibling = node;
                        ps.updateInfo();
                    } else {
                        node.previousSibling = null;
                    }
                    
                    node.updateInfo();
                    if (!me.isLoaded()) {
                        me.set(&#39;loaded&#39;, true);                            
                    }

                    if (suppressEvents !== true) {
                        me.fireEvent(&quot;insert&quot;, me, node, refNode);

                        if (oldParent) {
                            node.fireEvent(&quot;move&quot;, node, oldParent, me, refIndex, refNode);
                        }                        
                    }

                    return node;
                },

                <a name="method-Ext.data.NodeInterface-remove"></a>/**
                 * Removes this node from its parent
                 * @param {Boolean} destroy &lt;tt&gt;true&lt;/tt&gt; to destroy the node upon removal. Defaults to &lt;tt&gt;false&lt;/tt&gt;.
                 * @return {Node} this
                 */
                remove : function(destroy, suppressEvents) {
                    var parentNode = this.parentNode;

                    if (parentNode) {
                        parentNode.removeChild(this, destroy, suppressEvents);
                    }
                    return this;
                },

                <a name="method-Ext.data.NodeInterface-removeAll"></a>/**
                 * Removes all child nodes from this node.
                 * @param {Boolean} destroy &lt;tt&gt;true&lt;/tt&gt; to destroy the node upon removal. Defaults to &lt;tt&gt;false&lt;/tt&gt;.
                 * @return {Node} this
                 */
                removeAll : function(destroy, suppressEvents) {
                    var cn = this.childNodes,
                        n;

                    while ((n = cn[0])) {
                        this.removeChild(n, destroy, suppressEvents);
                    }
                    return this;
                },

                <a name="method-Ext.data.NodeInterface-getChildAt"></a>/**
                 * Returns the child node at the specified index.
                 * @param {Number} index
                 * @return {Node}
                 */
                getChildAt : function(index) {
                    return this.childNodes[index];
                },

                <a name="method-Ext.data.NodeInterface-replaceChild"></a>/**
                 * Replaces one child node in this node with another.
                 * @param {Node} newChild The replacement node
                 * @param {Node} oldChild The node to replace
                 * @return {Node} The replaced node
                 */
                replaceChild : function(newChild, oldChild, suppressEvents) {
                    var s = oldChild ? oldChild.nextSibling : null;

                    this.removeChild(oldChild, suppressEvents);
                    this.insertBefore(newChild, s, suppressEvents);
                    return oldChild;
                },

                <a name="method-Ext.data.NodeInterface-indexOf"></a>/**
                 * Returns the index of a child node
                 * @param {Node} node
                 * @return {Number} The index of the node or -1 if it was not found
                 */
                indexOf : function(child) {
                    return Ext.Array.indexOf(this.childNodes, child);
                },

                <a name="method-Ext.data.NodeInterface-getDepth"></a>/**
                 * Returns depth of this node (the root node has a depth of 0)
                 * @return {Number}
                 */
                getDepth : function() {
                    return this.get(&#39;depth&#39;);
                },

                <a name="method-Ext.data.NodeInterface-bubble"></a>/**
                 * Bubbles up the tree from this node, calling the specified function with each node. The arguments to the function
                 * will be the args provided or the current node. If the function returns false at any point,
                 * the bubble is stopped.
                 * @param {Function} fn The function to call
                 * @param {Object} scope (optional) The scope (&lt;code&gt;this&lt;/code&gt; reference) in which the function is executed. Defaults to the current Node.
                 * @param {Array} args (optional) The args to call the function with (default to passing the current Node)
                 */
                bubble : function(fn, scope, args) {
                    var p = this;
                    while (p) {
                        if (fn.apply(scope || p, args || [p]) === false) {
                            break;
                        }
                        p = p.parentNode;
                    }
                },

                //&lt;deprecated since=0.99&gt;
                cascade: function() {
                    throw &quot;Ext.data.Node: cascade method renamed to cascadeBy.&quot;;
                },
                //&lt;/deprecated&gt;

                <a name="method-Ext.data.NodeInterface-cascadeBy"></a>/**
                 * Cascades down the tree from this node, calling the specified function with each node. The arguments to the function
                 * will be the args provided or the current node. If the function returns false at any point,
                 * the cascade is stopped on that branch.
                 * @param {Function} fn The function to call
                 * @param {Object} scope (optional) The scope (&lt;code&gt;this&lt;/code&gt; reference) in which the function is executed. Defaults to the current Node.
                 * @param {Array} args (optional) The args to call the function with (default to passing the current Node)
                 */
                cascadeBy : function(fn, scope, args) {
                    if (fn.apply(scope || this, args || [this]) !== false) {
                        var childNodes = this.childNodes,
                            length     = childNodes.length,
                            i;

                        for (i = 0; i &lt; length; i++) {
                            childNodes[i].cascadeBy(fn, scope, args);
                        }
                    }
                },

                <a name="method-Ext.data.NodeInterface-eachChild"></a>/**
                 * Interates the child nodes of this node, calling the specified function with each node. The arguments to the function
                 * will be the args provided or the current node. If the function returns false at any point,
                 * the iteration stops.
                 * @param {Function} fn The function to call
                 * @param {Object} scope (optional) The scope (&lt;code&gt;this&lt;/code&gt; reference) in which the function is executed. Defaults to the current Node in the iteration.
                 * @param {Array} args (optional) The args to call the function with (default to passing the current Node)
                 */
                eachChild : function(fn, scope, args) {
                    var childNodes = this.childNodes,
                        length     = childNodes.length,
                        i;

                    for (i = 0; i &lt; length; i++) {
                        if (fn.apply(scope || this, args || [childNodes[i]]) === false) {
                            break;
                        }
                    }
                },

                <a name="method-Ext.data.NodeInterface-findChild"></a>/**
                 * Finds the first child that has the attribute with the specified value.
                 * @param {String} attribute The attribute name
                 * @param {Mixed} value The value to search for
                 * @param {Boolean} deep (Optional) True to search through nodes deeper than the immediate children
                 * @return {Node} The found child or null if none was found
                 */
                findChild : function(attribute, value, deep) {
                    return this.findChildBy(function() {
                        return this.get(attribute) == value;
                    }, null, deep);
                },

                <a name="method-Ext.data.NodeInterface-findChildBy"></a>/**
                 * Finds the first child by a custom function. The child matches if the function passed returns &lt;code&gt;true&lt;/code&gt;.
                 * @param {Function} fn A function which must return &lt;code&gt;true&lt;/code&gt; if the passed Node is the required Node.
                 * @param {Object} scope (optional) The scope (&lt;code&gt;this&lt;/code&gt; reference) in which the function is executed. Defaults to the Node being tested.
                 * @param {Boolean} deep (Optional) True to search through nodes deeper than the immediate children
                 * @return {Node} The found child or null if none was found
                 */
                findChildBy : function(fn, scope, deep) {
                    var cs = this.childNodes,
                        len = cs.length,
                        i = 0, n, res;

                    for (; i &lt; len; i++) {
                        n = cs[i];
                        if (fn.call(scope || n, n) === true) {
                            return n;
                        }
                        else if (deep) {
                            res = n.findChildBy(fn, scope, deep);
                            if (res !== null) {
                                return res;
                            }
                        }
                    }

                    return null;
                },

                <a name="method-Ext.data.NodeInterface-contains"></a>/**
                 * Returns true if this node is an ancestor (at any point) of the passed node.
                 * @param {Node} node
                 * @return {Boolean}
                 */
                contains : function(node) {
                    return node.isAncestor(this);
                },

                <a name="method-Ext.data.NodeInterface-isAncestor"></a>/**
                 * Returns true if the passed node is an ancestor (at any point) of this node.
                 * @param {Node} node
                 * @return {Boolean}
                 */
                isAncestor : function(node) {
                    var p = this.parentNode;
                    while (p) {
                        if (p == node) {
                            return true;
                        }
                        p = p.parentNode;
                    }
                    return false;
                },

                <a name="method-Ext.data.NodeInterface-sort"></a>/**
                 * Sorts this nodes children using the supplied sort function.
                 * @param {Function} fn A function which, when passed two Nodes, returns -1, 0 or 1 depending upon required sort order.
                 * @param {Boolean} recursive Whether or not to apply this sort recursively
                 * @param {Boolean} suppressEvent Set to true to not fire a sort event.
                 */
                sort : function(sortFn, recursive, suppressEvent) {
                    var cs  = this.childNodes,
                        ln = cs.length,
                        i, n;
                    
                    if (ln &gt; 0) {
                        Ext.Array.sort(cs, sortFn);
                        for (i = 0; i &lt; ln; i++) {
                            n = cs[i];
                            n.previousSibling = cs[i-1];
                            n.nextSibling = cs[i+1];
                        
                            if (i === 0) {
                                this.setFirstChild(n);
                                n.updateInfo();
                            }
                            if (i == ln - 1) {
                                this.setLastChild(n);
                                n.updateInfo();
                            }
                            if (recursive &amp;&amp; !n.isLeaf()) {
                                n.sort(sortFn, true, true);
                            }
                        }
                        
                        if (suppressEvent !== true) {
                            this.fireEvent(&#39;sort&#39;, this, cs);
                        }
                    }
                },
                                
                isExpanded: function() {
                    return this.get(&#39;expanded&#39;);
                },
                
                isLoaded: function() {
                    return this.get(&#39;loaded&#39;);
                },
                
                isRoot: function() {
                    return !this.parentNode;
                },
                
                isVisible: function() {
                    var parent = this.parentNode;
                    while (parent) {
                        if (!parent.isExpanded()) {
                            return false;
                        }
                        parent = parent.parentNode;
                    }
                    return true;
                },
                
                expand: function(callback, scope) {
                    if (!this.isLeaf() &amp;&amp; !this.expanding &amp;&amp; !this.isExpanded()) {
                        this.expanding = true;
                        this.fireEvent(&#39;beforeexpand&#39;, this, function(records) {
                            delete this.expanding;
                            this.set(&#39;expanded&#39;, true); 
                            this.fireEvent(&#39;expand&#39;, this, records, false);
                            if (callback) {
                                callback.call(scope || this, records);
                            }
                        }, this);
                    }
                },

                collapse: function(callback, scope) {
                    if (!this.isLeaf() &amp;&amp; !this.collapsing &amp;&amp; this.isExpanded()) {
                        this.collapsing = true;
                        this.fireEvent(&#39;beforecollapse&#39;, this, function(records) {
                            var ln = records.length,
                                record, i;
                            delete this.collapsing;
                            this.set(&#39;expanded&#39;, false);
                            this.fireEvent(&#39;collapse&#39;, this, records, false);   
                            if (callback) {
                                callback.call(scope || this, records);
                            }                         
                        }, this);
                    }
                }
            };
        }
    }
});
￿</pre></pre></body></html>