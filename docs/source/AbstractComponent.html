<!DOCTYPE html><html><head><title>Sencha Documentation Project</title><link rel="stylesheet" href="../reset.css" type="text/css"><link rel="stylesheet" href="../prettify.css" type="text/css"><link rel="stylesheet" href="../prettify_sa.css" type="text/css"><script type="text/javascript" src="../prettify.js"></script></head><body onload="prettyPrint()"><pre class="prettyprint"><pre><a name="cls-Ext.AbstractComponent"></a>/**
 * @class Ext.AbstractComponent
 * &lt;p&gt;An abstract base class which provides shared methods for Components across the Sencha product line.&lt;/p&gt;
 * &lt;p&gt;Please refer to sub class&#39;s documentation&lt;/p&gt;
 * @constructor
 */

Ext.define(&#39;Ext.AbstractComponent&#39;, {

    /* Begin Definitions */

    mixins: {
        observable: &#39;Ext.util.Observable&#39;,
        animate: &#39;Ext.util.Animate&#39;,
        state: &#39;Ext.state.Stateful&#39;
    },

    requires: [
        &#39;Ext.PluginMgr&#39;,
        &#39;Ext.ComponentMgr&#39;,
        &#39;Ext.core.Element&#39;,
        &#39;Ext.core.DomHelper&#39;,
        &#39;Ext.XTemplate&#39;,
        &#39;Ext.ComponentQuery&#39;,
        &#39;Ext.LoadMask&#39;,
        &#39;Ext.ComponentLoader&#39;,
        &#39;Ext.EventManager&#39;,
        &#39;Ext.layout.Manager&#39;,
        &#39;Ext.layout.component.Auto&#39;
    ],

    // Please remember to add dependencies whenever you use it
    // I had to fix these many times already
    uses: [
        &#39;Ext.ZIndexManager&#39;
    ],

    statics: {
        AUTO_ID: 1000
    },

    /* End Definitions */

    isComponent: true,

    getAutoId: function() {
        return ++Ext.AbstractComponent.AUTO_ID;
    },

    <a name="cfg-Ext.AbstractComponent-id"></a>/**
     * @cfg {String} id
     * &lt;p&gt;The &lt;b&gt;&lt;u&gt;unique id of this component instance&lt;/u&gt;&lt;/b&gt; (defaults to an {@link #getId auto-assigned id}).&lt;/p&gt;
     * &lt;p&gt;It should not be necessary to use this configuration except for singleton objects in your application.
     * Components created with an id may be accessed globally using {@link Ext#getCmp Ext.getCmp}.&lt;/p&gt;
     * &lt;p&gt;Instead of using assigned ids, use the {@link #itemId} config, and {@link Ext.ComponentQuery ComponentQuery} which
     * provides selector-based searching for Sencha Components analogous to DOM querying. The {@link Ext.container.Container Container}
     * class contains {@link Ext.container.Container#down shortcut methods} to query its descendant Components by selector.&lt;/p&gt;
     * &lt;p&gt;Note that this id will also be used as the element id for the containing HTML element
     * that is rendered to the page for this component. This allows you to write id-based CSS
     * rules to style the specific instance of this component uniquely, and also to select
     * sub-elements using this component&#39;s id as the parent.&lt;/p&gt;
     * &lt;p&gt;&lt;b&gt;Note&lt;/b&gt;: to avoid complications imposed by a unique &lt;tt&gt;id&lt;/tt&gt; also see &lt;code&gt;{@link #itemId}&lt;/code&gt;.&lt;/p&gt;
     * &lt;p&gt;&lt;b&gt;Note&lt;/b&gt;: to access the container of a Component see &lt;code&gt;{@link #ownerCt}&lt;/code&gt;.&lt;/p&gt;
     */

    <a name="cfg-Ext.AbstractComponent-itemId"></a>/**
     * @cfg {String} itemId
     * &lt;p&gt;An &lt;tt&gt;itemId&lt;/tt&gt; can be used as an alternative way to get a reference to a component
     * when no object reference is available.  Instead of using an &lt;code&gt;{@link #id}&lt;/code&gt; with
     * {@link Ext}.{@link Ext#getCmp getCmp}, use &lt;code&gt;itemId&lt;/code&gt; with
     * {@link Ext.container.Container}.{@link Ext.container.Container#getComponent getComponent} which will retrieve
     * &lt;code&gt;itemId&lt;/code&gt;&#39;s or &lt;tt&gt;{@link #id}&lt;/tt&gt;&#39;s. Since &lt;code&gt;itemId&lt;/code&gt;&#39;s are an index to the
     * container&#39;s internal MixedCollection, the &lt;code&gt;itemId&lt;/code&gt; is scoped locally to the container --
     * avoiding potential conflicts with {@link Ext.ComponentMgr} which requires a &lt;b&gt;unique&lt;/b&gt;
     * &lt;code&gt;{@link #id}&lt;/code&gt;.&lt;/p&gt;
     * <br><span style="display: none">**/</span>var c = new Ext.panel.Panel({ //
    {@link Ext.Component#height height}: 300,
    {@link #renderTo}: document.body,
    {@link Ext.container.Container#layout layout}: &#39;auto&#39;,
    {@link Ext.container.Container#items items}: [
        {
            itemId: &#39;p1&#39;,
            {@link Ext.panel.Panel#title title}: &#39;Panel 1&#39;,
            {@link Ext.Component#height height}: 150
        },
        {
            itemId: &#39;p2&#39;,
            {@link Ext.panel.Panel#title title}: &#39;Panel 2&#39;,
            {@link Ext.Component#height height}: 150
        }
    ]
})
p1 = c.{@link Ext.container.Container#getComponent getComponent}(&#39;p1&#39;); // not the same as {@link Ext#getCmp Ext.getCmp()}
p2 = p1.{@link #ownerCt}.{@link Ext.container.Container#getComponent getComponent}(&#39;p2&#39;); // reference via a sibling
     * <br><span style="display: none">/**</span>     * &lt;p&gt;Also see &lt;tt&gt;{@link #id}&lt;/tt&gt;, &lt;code&gt;{@link #query}&lt;/code&gt;, &lt;code&gt;{@link #down}&lt;/code&gt; and &lt;code&gt;{@link #child}&lt;/code&gt;.&lt;/p&gt;
     * &lt;p&gt;&lt;b&gt;Note&lt;/b&gt;: to access the container of an item see &lt;tt&gt;{@link #ownerCt}&lt;/tt&gt;.&lt;/p&gt;
     */

    <a name="prop-Ext.AbstractComponent-ownerCt"></a>/**
     * This Component&#39;s owner {@link Ext.container.Container Container} (defaults to undefined, and is set automatically when
     * this Component is added to a Container).  Read-only.
     * &lt;p&gt;&lt;b&gt;Note&lt;/b&gt;: to access items within the Container see &lt;tt&gt;{@link #itemId}&lt;/tt&gt;.&lt;/p&gt;
     * @type Ext.Container
     * @property ownerCt
     */

    <a name="cfg-Ext.AbstractComponent-autoEl"></a>/**
     * @cfg {Mixed} autoEl
     * &lt;p&gt;A tag name or {@link Ext.core.DomHelper DomHelper} spec used to create the {@link #getEl Element} which will
     * encapsulate this Component.&lt;/p&gt;
     * &lt;p&gt;You do not normally need to specify this. For the base classes {@link Ext.Component} and {@link Ext.container.Container},
     * this defaults to &lt;b&gt;&lt;tt&gt;&#39;div&#39;&lt;/tt&gt;&lt;/b&gt;. The more complex Sencha classes use a more complex
     * DOM structure specified by their own {@link #renderTpl}s.&lt;/p&gt;
     * &lt;p&gt;This is intended to allow the developer to create application-specific utility Components encapsulated by
     * different DOM elements. Example usage:&lt;/p&gt;<br><span style="display: none">**/</span>{
    xtype: &#39;component&#39;,
    autoEl: {
        tag: &#39;img&#39;,
        src: &#39;http://www.example.com/example.jpg&#39;
    }
}, {
    xtype: &#39;component&#39;,
    autoEl: {
        tag: &#39;blockquote&#39;,
        html: &#39;autoEl is cool!&#39;
    }
}, {
    xtype: &#39;container&#39;,
    autoEl: &#39;ul&#39;,
    cls: &#39;ux-unordered-list&#39;,
    items: {
        xtype: &#39;component&#39;,
        autoEl: &#39;li&#39;,
        html: &#39;First list item&#39;
    }
}
<br><span style="display: none">/**</span>     */

    <a name="cfg-Ext.AbstractComponent-renderTpl"></a>/**
     * @cfg {Mixed} renderTpl
     * &lt;p&gt;An {@link Ext.XTemplate XTemplate} used to create the internal structure inside this Component&#39;s
     * encapsulating {@link #getEl Element}.&lt;/p&gt;
     * &lt;p&gt;You do not normally need to specify this. For the base classes {@link Ext.Component}
     * and {@link Ext.container.Container}, this defaults to &lt;b&gt;&lt;code&gt;null&lt;/code&gt;&lt;/b&gt; which means that they will be initially rendered
     * with no internal structure; they render their {@link #getEl Element} empty. The more specialized ExtJS and Touch classes
     * which use a more complex DOM structure, provide their own template definitions.&lt;/p&gt;
     * &lt;p&gt;This is intended to allow the developer to create application-specific utility Components with customized
     * internal structure.&lt;/p&gt;
     * &lt;p&gt;Upon rendering, any created child elements may be automatically imported into object properties using the
     * {@link #renderSelectors} option.&lt;/p&gt;
     */
    renderTpl: null,

    <a name="cfg-Ext.AbstractComponent-renderSelectors"></a>/**
     * @cfg {Object} renderSelectors
     
An object containing properties specifying {@link Ext.DomQuery DomQuery} selectors which identify child elements
created by the render process.

After the Component&#39;s internal structure is rendered according to the {@link #renderTpl}, this object is iterated through,
and the found Elements are added as properties to the Component using the `renderSelector` property name.

For example, a Component which rendered an image, and description into its element might use the following properties
coded into its prototype:

    renderTpl: &#39;&amp;lt;img src=&quot;{imageUrl}&quot; class=&quot;x-image-component-img&quot;&gt;&amp;lt;div class=&quot;x-image-component-desc&quot;&gt;{description}&amp;gt;/div&amp;lt;&#39;,

    renderSelectors: {
        image: &#39;img.x-image-component-img&#39;,
        descEl: &#39;div.x-image-component-desc&#39;
    }

After rendering, the Component would have a property &lt;code&gt;image&lt;/code&gt; referencing its child `img` Element,
and a property `descEl` referencing the `div` Element which contains the description.

     * @markdown
     */

    <a name="cfg-Ext.AbstractComponent-renderTo"></a>/**
     * @cfg {Mixed} renderTo
     * &lt;p&gt;Specify the id of the element, a DOM element or an existing Element that this component
     * will be rendered into.&lt;/p&gt;&lt;div&gt;&lt;ul&gt;
     * &lt;li&gt;&lt;b&gt;Notes&lt;/b&gt; : &lt;ul&gt;
     * &lt;div class=&quot;sub-desc&quot;&gt;Do &lt;u&gt;not&lt;/u&gt; use this option if the Component is to be a child item of
     * a {@link Ext.container.Container Container}. It is the responsibility of the
     * {@link Ext.container.Container Container}&#39;s {@link Ext.container.Container#layout layout manager}
     * to render and manage its child items.&lt;/div&gt;
     * &lt;div class=&quot;sub-desc&quot;&gt;When using this config, a call to render() is not required.&lt;/div&gt;
     * &lt;/ul&gt;&lt;/li&gt;
     * &lt;/ul&gt;&lt;/div&gt;
     * &lt;p&gt;See &lt;code&gt;{@link #render}&lt;/code&gt; also.&lt;/p&gt;
     */

    <a name="cfg-Ext.AbstractComponent-frame"></a>/**
     * @cfg {Boolean} frame
     * &lt;p&gt;Specify as &lt;code&gt;true&lt;/code&gt; to have the Component inject framing elements within the Component at render time to
     * provide a graphical rounded frame around the Component content.&lt;/p&gt;
     * &lt;p&gt;This is only necessary when running on outdated, or non standard-compliant browsers such as Microsoft&#39;s Internet Explorer
     * prior to version 9 which do not support rounded corners natively.&lt;/p&gt;
     * &lt;p&gt;The extra space taken up by this framing is available from the read only property {@link #frameSize}.&lt;/p&gt;
     */

    <a name="prop-Ext.AbstractComponent-frameSize"></a>/**
     * &lt;p&gt;Read-only property indicating the width of any framing elements which were added within the encapsulating element
     * to provide graphical, rounded borders. See the {@link #frame} config.&lt;/p&gt;
     * &lt;p&gt; This is an object containing the frame width in pixels for all four sides of the Component containing
     * the following properties:&lt;/p&gt;&lt;div class=&quot;mdetail-params&quot;&gt;&lt;ul&gt;
     * &lt;li&gt;&lt;code&gt;top&lt;/code&gt; The width of the top framing element in pixels.&lt;/li&gt;
     * &lt;li&gt;&lt;code&gt;right&lt;/code&gt; The width of the right framing element in pixels.&lt;/li&gt;
     * &lt;li&gt;&lt;code&gt;bottom&lt;/code&gt; The width of the bottom framing element in pixels.&lt;/li&gt;
     * &lt;li&gt;&lt;code&gt;left&lt;/code&gt; The width of the left framing element in pixels.&lt;/li&gt;
     * &lt;/ul&gt;&lt;/div&gt;
     * @property frameSize
     * @type {Object}
     */

    <a name="cfg-Ext.AbstractComponent-componentLayout"></a>/**
     * @cfg {String/Object} componentLayout
     * &lt;p&gt;The sizing and positioning of a Component&#39;s internal Elements is the responsibility of
     * the Component&#39;s layout manager which sizes a Component&#39;s internal structure in response to the Component being sized.&lt;/p&gt;
     * &lt;p&gt;Generally, developers will not use this configuration as all provided Components which need their internal
     * elements sizing (Such as {@link Ext.form.Field input fields}) come with their own componentLayout managers.&lt;/p&gt;
     * &lt;p&gt;The {@link Ext.layout.container.Auto default layout manager} will be used on instances of the base Ext.Component class
     * which simply sizes the Component&#39;s encapsulating element to the height and width specified in the {@link #setSize} method.&lt;/p&gt;
     */

    <a name="cfg-Ext.AbstractComponent-tpl"></a>/**
     * @cfg {Mixed} tpl
     * An &lt;bold&gt;{@link Ext.Template}&lt;/bold&gt;, &lt;bold&gt;{@link Ext.XTemplate}&lt;/bold&gt;
     * or an array of strings to form an Ext.XTemplate.
     * Used in conjunction with the &lt;code&gt;{@link #data}&lt;/code&gt; and
     * &lt;code&gt;{@link #tplWriteMode}&lt;/code&gt; configurations.
     */

    <a name="cfg-Ext.AbstractComponent-data"></a>/**
     * @cfg {Mixed} data
     * The initial set of data to apply to the &lt;code&gt;{@link #tpl}&lt;/code&gt; to
     * update the content area of the Component.
     */

    <a name="cfg-Ext.AbstractComponent-tplWriteMode"></a>/**
     * @cfg {String} tplWriteMode The Ext.(X)Template method to use when
     * updating the content area of the Component. Defaults to &lt;code&gt;&#39;overwrite&#39;&lt;/code&gt;
     * (see &lt;code&gt;{@link Ext.XTemplate#overwrite}&lt;/code&gt;).
     */
    tplWriteMode: &#39;overwrite&#39;,

    <a name="cfg-Ext.AbstractComponent-baseCls"></a>/**
     * @cfg {String} baseCls
     * The base CSS class to apply to this components&#39;s element. This will also be prepended to
     * elements within this component like Panel&#39;s body will get a class x-panel-body. This means
     * that if you create a subclass of Panel, and you want it to get all the Panels styling for the
     * element and the body, you leave the baseCls x-panel and use componentCls to add specific styling for this
     * component.
     */
    baseCls: Ext.baseCSSPrefix + &#39;component&#39;,

    <a name="cfg-Ext.AbstractComponent-componentCls"></a>/**
     * @cfg {String} componentCls
     * CSS Class to be added to a components root level element to give distinction to it
     * via styling.
     */

    <a name="cfg-Ext.AbstractComponent-cls"></a>/**
     * @cfg {String} cls
     * An optional extra CSS class that will be added to this component&#39;s Element (defaults to &#39;&#39;).  This can be
     * useful for adding customized styles to the component or any of its children using standard CSS rules.
     */

    <a name="cfg-Ext.AbstractComponent-overCls"></a>/**
     * @cfg {String} overCls
     * An optional extra CSS class that will be added to this component&#39;s Element when the mouse moves
     * over the Element, and removed when the mouse moves out. (defaults to &#39;&#39;).  This can be
     * useful for adding customized &#39;active&#39; or &#39;hover&#39; styles to the component or any of its children using standard CSS rules.
     */

    <a name="cfg-Ext.AbstractComponent-disabledCls"></a>/**
     * @cfg {String} disabledCls
     * CSS class to add when the Component is disabled. Defaults to &#39;x-item-disabled&#39;.
     */
    disabledCls: Ext.baseCSSPrefix + &#39;item-disabled&#39;,

    <a name="cfg-Ext.AbstractComponent-ui"></a>/**
     * @cfg {String} ui
     * A set of predefined ui styles for individual components.
     *
     * Most components support &#39;light&#39; and &#39;dark&#39;.
     *
     * Extra string added to the baseCls with an extra &#39;-&#39;.
     * <br><span style="display: none">**/</span>      new Ext.panel.Panel({
          title: &#39;Some Title&#39;,
          baseCls: &#39;x-component&#39;
          ui: &#39;green&#39;
      });
       <br><span style="display: none">/**</span>     * &lt;p&gt;The ui configuration in this example would add &#39;x-component-green&#39; as an additional class.&lt;/p&gt;
     */

   <a name="cfg-Ext.AbstractComponent-style"></a>/**
     * @cfg {String} style
     * A custom style specification to be applied to this component&#39;s Element.  Should be a valid argument to
     * {@link Ext.core.Element#applyStyles}.
     * <br><span style="display: none">**/</span>        new Ext.panel.Panel({
            title: &#39;Some Title&#39;,
            renderTo: Ext.getBody(),
            width: 400, height: 300,
            layout: &#39;form&#39;,
            items: [{
                xtype: &#39;textarea&#39;,
                style: {
                    width: &#39;95%&#39;,
                    marginBottom: &#39;10px&#39;
                }
            },
            new Ext.button.Button({
                text: &#39;Send&#39;,
                minWidth: &#39;100&#39;,
                style: {
                    marginBottom: &#39;10px&#39;
                }
            })
            ]
        });
     <br><span style="display: none">/**</span>     */

    <a name="cfg-Ext.AbstractComponent-width"></a>/**
     * @cfg {Number} width
     * The width of this component in pixels.
     */

    <a name="cfg-Ext.AbstractComponent-height"></a>/**
     * @cfg {Number} height
     * The height of this component in pixels.
     */

    <a name="cfg-Ext.AbstractComponent-border"></a>/**
     * @cfg {Number/String} border
     * Specifies the border for this component. The border can be a single numeric value to apply to all sides or
     * it can be a CSS style specification for each style, for example: &#39;10 5 3 10&#39;.
     */

    <a name="cfg-Ext.AbstractComponent-padding"></a>/**
     * @cfg {Number/String} padding
     * Specifies the padding for this component. The padding can be a single numeric value to apply to all sides or
     * it can be a CSS style specification for each style, for example: &#39;10 5 3 10&#39;.
     */

    <a name="cfg-Ext.AbstractComponent-margin"></a>/**
     * @cfg {Number/String} margin
     * Specifies the margin for this component. The margin can be a single numeric value to apply to all sides or
     * it can be a CSS style specification for each style, for example: &#39;10 5 3 10&#39;.
     */

    <a name="cfg-Ext.AbstractComponent-hidden"></a>/**
     * @cfg {Boolean} hidden
     * Defaults to false.
     */
    hidden: false,

    <a name="cfg-Ext.AbstractComponent-disabled"></a>/**
     * @cfg {Boolean} disabled
     * Defaults to false.
     */
    disabled: false,

    <a name="cfg-Ext.AbstractComponent-draggable"></a>/**
     * @cfg {Boolean} draggable
     * Allows the component to be dragged.
     */

    <a name="prop-Ext.AbstractComponent-draggable"></a>/**
     * Read-only property indicating whether or not the component can be dragged
     * @property draggable
     * @type {Boolean}
     */
    draggable: false,

    <a name="cfg-Ext.AbstractComponent-floating"></a>/**
     * @cfg {Boolean} floating
     * Create the Component as a floating and use absolute positioning.
     * Defaults to false.
     */
    floating: false,

    <a name="cfg-Ext.AbstractComponent-hideMode"></a>/**
     * @cfg {String} hideMode
     * A String which specifies how this Component&#39;s encapsulating DOM element will be hidden.
     * Values may be&lt;div class=&quot;mdetail-params&quot;&gt;&lt;ul&gt;
     * &lt;li&gt;&lt;code&gt;&#39;display&#39;&lt;/code&gt; : The Component will be hidden using the &lt;code&gt;display: none&lt;/code&gt; style.&lt;/li&gt;
     * &lt;li&gt;&lt;code&gt;&#39;visibility&#39;&lt;/code&gt; : The Component will be hidden using the &lt;code&gt;visibility: hidden&lt;/code&gt; style.&lt;/li&gt;
     * &lt;li&gt;&lt;code&gt;&#39;offsets&#39;&lt;/code&gt; : The Component will be hidden by absolutely positioning it out of the visible area of the document. This
     * is useful when a hidden Component must maintain measurable dimensions. Hiding using &lt;code&gt;display&lt;/code&gt; results
     * in a Component having zero dimensions.&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;
     * Defaults to &lt;code&gt;&#39;display&#39;&lt;/code&gt;.
     */
    hideMode: &#39;display&#39;,

    <a name="cfg-Ext.AbstractComponent-contentEl"></a>/**
     * @cfg {String} contentEl
     * &lt;p&gt;Optional. Specify an existing HTML element, or the &lt;code&gt;id&lt;/code&gt; of an existing HTML element to use as the content
     * for this component.&lt;/p&gt;
     * &lt;ul&gt;
     * &lt;li&gt;&lt;b&gt;Description&lt;/b&gt; :
     * &lt;div class=&quot;sub-desc&quot;&gt;This config option is used to take an existing HTML element and place it in the layout element
     * of a new component (it simply moves the specified DOM element &lt;i&gt;after the Component is rendered&lt;/i&gt; to use as the content.&lt;/div&gt;&lt;/li&gt;
     * &lt;li&gt;&lt;b&gt;Notes&lt;/b&gt; :
     * &lt;div class=&quot;sub-desc&quot;&gt;The specified HTML element is appended to the layout element of the component &lt;i&gt;after any configured
     * {@link #html HTML} has been inserted&lt;/i&gt;, and so the document will not contain this element at the time the {@link #render} event is fired.&lt;/div&gt;
     * &lt;div class=&quot;sub-desc&quot;&gt;The specified HTML element used will not participate in any &lt;code&gt;&lt;b&gt;{@link Ext.container.Container#layout layout}&lt;/b&gt;&lt;/code&gt;
     * scheme that the Component may use. It is just HTML. Layouts operate on child &lt;code&gt;&lt;b&gt;{@link Ext.container.Container#items items}&lt;/b&gt;&lt;/code&gt;.&lt;/div&gt;
     * &lt;div class=&quot;sub-desc&quot;&gt;Add either the &lt;code&gt;x-hidden&lt;/code&gt; or the &lt;code&gt;x-hide-display&lt;/code&gt; CSS class to
     * prevent a brief flicker of the content before it is rendered to the panel.&lt;/div&gt;&lt;/li&gt;
     * &lt;/ul&gt;
     */

    <a name="cfg-Ext.AbstractComponent-html"></a>/**
     * @cfg {String/Object} html
     * An HTML fragment, or a {@link Ext.core.DomHelper DomHelper} specification to use as the layout element
     * content (defaults to &#39;&#39;). The HTML content is added after the component is rendered,
     * so the document will not contain this HTML at the time the {@link #render} event is fired.
     * This content is inserted into the body &lt;i&gt;before&lt;/i&gt; any configured {@link #contentEl} is appended.
     */

    <a name="cfg-Ext.AbstractComponent-styleHtmlContent"></a>/**
     * @cfg {String} styleHtmlContent
     * True to automatically style the html inside the content target of this component (body for panels).
     * Defaults to false.
     */
    styleHtmlContent: false,

    <a name="cfg-Ext.AbstractComponent-styleHtmlCls"></a>/**
     * @cfg {String} styleHtmlCls
     * The class that is added to the content target when you set styleHtmlContent to true.
     * Defaults to &#39;x-html&#39;
     */
    styleHtmlCls: Ext.baseCSSPrefix + &#39;html&#39;,

    <a name="cfg-Ext.AbstractComponent-minHeight"></a>/**
     * @cfg {Number} minHeight
     * &lt;p&gt;The minimum value in pixels which this Component will set its height to.&lt;/p&gt;
     * &lt;p&gt;&lt;b&gt;Warning:&lt;/b&gt; This will override any size management applied by layout managers.&lt;/p&gt;
     */
    <a name="cfg-Ext.AbstractComponent-minWidth"></a>/**
     * @cfg {Number} minWidth
     * &lt;p&gt;The minimum value in pixels which this Component will set its width to.&lt;/p&gt;
     * &lt;p&gt;&lt;b&gt;Warning:&lt;/b&gt; This will override any size management applied by layout managers.&lt;/p&gt;
     */
    <a name="cfg-Ext.AbstractComponent-maxHeight"></a>/**
     * @cfg {Number} maxHeight
     * &lt;p&gt;The maximum value in pixels which this Component will set its height to.&lt;/p&gt;
     * &lt;p&gt;&lt;b&gt;Warning:&lt;/b&gt; This will override any size management applied by layout managers.&lt;/p&gt;
     */
    <a name="cfg-Ext.AbstractComponent-maxWidth"></a>/**
     * @cfg {Number} maxWidth
     * &lt;p&gt;The maximum value in pixels which this Component will set its width to.&lt;/p&gt;
     * &lt;p&gt;&lt;b&gt;Warning:&lt;/b&gt; This will override any size management applied by layout managers.&lt;/p&gt;
     */

    <a name="cfg-Ext.AbstractComponent-loader"></a>/**
     * @cfg {Ext.ComponentLoader/Object} loader
     * A configuration object or an instance of a {@link Ext.ComponentLoader} to load remote
     * content for this Component.
     */

     // @private
     allowDomMove: true,

     autoShow: false,

    <a name="cfg-Ext.AbstractComponent-autoRender"></a>/**
     * @cfg {Mixed} autoRender
     * &lt;p&gt;This config is intended mainly for {@link #floating} Components which may or may not be shown. Instead
     * of using {@link #renderTo} in the configuration, and rendering upon construction, this allows a Component
     * to render itself upon first &lt;i&gt;{@link #show}&lt;/i&gt;.&lt;/p&gt;
     * &lt;p&gt;Specify as &lt;code&gt;true&lt;/code&gt; to have this Component render to the document body upon first show.&lt;/p&gt;
     * &lt;p&gt;Specify as an element, or the ID of an element to have this Component render to a specific element upon first show.&lt;/p&gt;
     * &lt;p&gt;&lt;b&gt;This defaults to &lt;code&gt;true&lt;/code&gt; for the {@link Ext.window.Window Window} class.&lt;/b&gt;&lt;/p&gt;
     */
     autoRender: false,

     needsLayout: false,

    <a name="cfg-Ext.AbstractComponent-plugins"></a>/**
     * @cfg {Object/Array} plugins
     * An object or array of objects that will provide custom functionality for this component.  The only
     * requirement for a valid plugin is that it contain an init method that accepts a reference of type Ext.Component.
     * When a component is created, if any plugins are available, the component will call the init method on each
     * plugin, passing a reference to itself.  Each plugin can then call methods or respond to events on the
     * component as needed to provide its functionality.
     */

    <a name="prop-Ext.AbstractComponent-rendered"></a>/**
     * Read-only property indicating whether or not the component has been rendered.
     * @property rendered
     * @type {Boolean}
     */
    rendered: false,
    
    weight: 0,

    constructor : function(config) {
        var me = this,
            i, len;

        config = config || {};
        me.initialConfig = config;
        Ext.apply(me, config);
                
        me.addEvents(
            <a name="event-Ext.AbstractComponent-beforeactivate"></a>/**
             * @event beforeactivate
             * Fires before a Component has been visually activated.
             * Returning false from an event listener can prevent the activate
             * from occurring.
             * @param {Ext.Component} this
             */
             &#39;beforeactivate&#39;,
            <a name="event-Ext.AbstractComponent-activate"></a>/**
             * @event activate
             * Fires after a Component has been visually activated.
             * @param {Ext.Component} this
             */
             &#39;activate&#39;,
            <a name="event-Ext.AbstractComponent-beforedeactivate"></a>/**
             * @event beforedeactivate
             * Fires before a Component has been visually deactivated.
             * Returning false from an event listener can prevent the deactivate
             * from occurring.
             * @param {Ext.Component} this
             */
             &#39;beforedeactivate&#39;,
            <a name="event-Ext.AbstractComponent-deactivate"></a>/**
             * @event deactivate
             * Fires after a Component has been visually deactivated.
             * @param {Ext.Component} this
             */
             &#39;deactivate&#39;,
            <a name="event-Ext.AbstractComponent-added"></a>/**
             * @event added
             * Fires after a Component had been added to a Container.
             * @param {Ext.Component} this
             * @param {Ext.container.Container} container Parent Container
             * @param {Number} pos position of Component
             */
             &#39;added&#39;,
            <a name="event-Ext.AbstractComponent-disable"></a>/**
             * @event disable
             * Fires after the component is disabled.
             * @param {Ext.Component} this
             */
             &#39;disable&#39;,
            <a name="event-Ext.AbstractComponent-enable"></a>/**
             * @event enable
             * Fires after the component is enabled.
             * @param {Ext.Component} this
             */
             &#39;enable&#39;,
            <a name="event-Ext.AbstractComponent-beforeshow"></a>/**
             * @event beforeshow
             * Fires before the component is shown when calling the {@link #show} method.
             * Return false from an event handler to stop the show.
             * @param {Ext.Component} this
             */
             &#39;beforeshow&#39;,
            <a name="event-Ext.AbstractComponent-show"></a>/**
             * @event show
             * Fires after the component is shown when calling the {@link #show} method.
             * @param {Ext.Component} this
             */
             &#39;show&#39;,
            <a name="event-Ext.AbstractComponent-beforehide"></a>/**
             * @event beforehide
             * Fires before the component is hidden when calling the {@link #hide} method.
             * Return false from an event handler to stop the hide.
             * @param {Ext.Component} this
             */
             &#39;beforehide&#39;,
            <a name="event-Ext.AbstractComponent-hide"></a>/**
             * @event hide
             * Fires after the component is hidden.
             * Fires after the component is hidden when calling the {@link #hide} method.
             * @param {Ext.Component} this
             */
             &#39;hide&#39;,
            <a name="event-Ext.AbstractComponent-removed"></a>/**
             * @event removed
             * Fires when a component is removed from an Ext.container.Container
             * @param {Ext.Component} this
             * @param {Ext.container.Container} ownerCt Container which holds the component
             */
             &#39;removed&#39;,
            <a name="event-Ext.AbstractComponent-beforerender"></a>/**
             * @event beforerender
             * Fires before the component is {@link #rendered}. Return false from an
             * event handler to stop the {@link #render}.
             * @param {Ext.Component} this
             */
             &#39;beforerender&#39;,
            <a name="event-Ext.AbstractComponent-render"></a>/**
             * @event render
             * Fires after the component markup is {@link #rendered}.
             * @param {Ext.Component} this
             */
             &#39;render&#39;,
            <a name="event-Ext.AbstractComponent-afterrender"></a>/**
             * @event afterrender
             * &lt;p&gt;Fires after the component rendering is finished.&lt;/p&gt;
             * &lt;p&gt;The afterrender event is fired after this Component has been {@link #rendered}, been postprocesed
             * by any afterRender method defined for the Component.&lt;/p&gt;
             * @param {Ext.Component} this
             */
             &#39;afterrender&#39;,
            <a name="event-Ext.AbstractComponent-beforedestroy"></a>/**
             * @event beforedestroy
             * Fires before the component is {@link #destroy}ed. Return false from an event handler to stop the {@link #destroy}.
             * @param {Ext.Component} this
             */
             &#39;beforedestroy&#39;,
            <a name="event-Ext.AbstractComponent-destroy"></a>/**
             * @event destroy
             * Fires after the component is {@link #destroy}ed.
             * @param {Ext.Component} this
             */
             &#39;destroy&#39;,
            <a name="event-Ext.AbstractComponent-resize"></a>/**
             * @event resize
             * Fires after the component is resized.
             * @param {Ext.Component} this
             * @param {Number} adjWidth The box-adjusted width that was set
             * @param {Number} adjHeight The box-adjusted height that was set
             */
             &#39;resize&#39;,
            <a name="event-Ext.AbstractComponent-move"></a>/**
             * @event move
             * Fires after the component is moved.
             * @param {Ext.Component} this
             * @param {Number} x The new x position
             * @param {Number} y The new y position
             */
             &#39;move&#39;
        );

        me.getId();

        me.mons = [];
        me.additionalCls = [];
        me.renderData = me.renderData || {};
        me.renderSelectors = me.renderSelectors || {};

        if (me.plugins) {
            me.plugins = [].concat(me.plugins);
            for (i = 0, len = me.plugins.length; i &lt; len; i++) {
                me.plugins[i] = me.constructPlugin(me.plugins[i]);
            }
        }

        me.initComponent();

        // ititComponent gets a chance to change the id property before registering
        Ext.ComponentMgr.register(me);

        // Dont pass the config so that it is not applied to &#39;this&#39; again
        me.mixins.observable.constructor.call(me);
        me.mixins.state.constructor.call(me, config);

        // Move this into Observable?
        if (me.plugins) {
            me.plugins = [].concat(me.plugins);
            for (i = 0, len = me.plugins.length; i &lt; len; i++) {
                me.plugins[i] = me.initPlugin(me.plugins[i]);
            }
        }

        me.loader = me.getLoader();

        if (me.renderTo) {
            me.render(me.renderTo);
        }

        //&lt;debug&gt;
        if (Ext.isDefined(me.disabledClass)) {
            throw &quot;Component: disabledClass has been deprecated. Please use disabledCls.&quot;;
        }
        //&lt;/debug&gt;
    },

    initComponent: Ext.emptyFn,

    show: Ext.emptyFn,

    animate: function(animObj) {
        var me = this,
            to;

        animObj = animObj || {};
        to = animObj.to || {};

        if (Ext.fx.Manager.hasFxBlock(me.id)) {
            return me;
        }
        // Special processing for animating Component dimensions.
        if (!animObj.dynamic &amp;&amp; (to.height || to.width)) {
            var curWidth = me.getWidth(),
                w = curWidth,
                curHeight = me.getHeight(),
                h = curHeight,
                needsResize = false;

            if (to.height &amp;&amp; to.height &gt; curHeight) {
                h = to.height;
                needsResize = true;
            }
            if (to.width &amp;&amp; to.width &gt; curWidth) {
                w = to.width;
                needsResize = true;
            }

            // If any dimensions are being increased, we must resize the internal structure
            // of the Component, but then clip it by sizing its encapsulating element back to original dimensions.
            // The animation will then progressively reveal the larger content.
            if (needsResize) {
                var clearWidth = !Ext.isNumber(me.width),
                    clearHeight = !Ext.isNumber(me.height);

                me.componentLayout.childrenChanged = true;
                me.setSize(w, h, me.ownerCt);
                me.el.setSize(curWidth, curHeight);
                if (clearWidth) {
                    delete me.width;
                }
                if (clearHeight) {
                    delete me.height;
                }
            }
        }
        return me.mixins.animate.animate.apply(me, arguments);
    },

    <a name="method-Ext.AbstractComponent-findLayoutController"></a>/**
     * &lt;p&gt;This method finds the topmost active layout who&#39;s processing will eventually determine the size and position of this
     * Component.&lt;p&gt;
     * &lt;p&gt;This method is useful when dynamically adding Components into Containers, and some processing must take place after the
     * final sizing and positioning of the Component has been performed.&lt;/p&gt;
     * @returns
     */
    findLayoutController: function() {
        return this.findParentBy(function(c) {
            // Return true if we are at the root of the Container tree
            // or this Container&#39;s layout is busy but the next one up is not.
            return !c.ownerCt || (c.layout.layoutBusy &amp;&amp; !c.ownerCt.layout.layoutBusy);
        });
    },

    onShow : function() {
        // Layout if needed
        var needsLayout = this.needsLayout;
        if (Ext.isObject(needsLayout)) {
            this.doComponentLayout(needsLayout.width, needsLayout.height, needsLayout.isSetSize, needsLayout.ownerCt);
        }
    },

    constructPlugin: function(plugin) {
        if (plugin.ptype &amp;&amp; typeof plugin.init != &#39;function&#39;) {
            plugin.cmp = this;
            plugin = Ext.PluginMgr.create(plugin);
        }
        else if (typeof plugin == &#39;string&#39;) {
            plugin = Ext.PluginMgr.create({
                ptype: plugin,
                cmp: this
            });
        }
        return plugin;
    },


    // @private
    initPlugin : function(plugin) {
        plugin.init(this);

        return plugin;
    },

    <a name="method-Ext.AbstractComponent-doAutoRender"></a>/**
     * Handles autoRender.
     * Floating Components may have an ownerCt. If they are asking to be constrained, constrain them within that
     * ownerCt, and have their z-index managed locally. Floating Components are always rendered to document.body
     */
    doAutoRender: function() {
        var me = this;
        if (me.floating) {
            me.render(document.body);
        } else {
            me.render(Ext.isBoolean(me.autoRender) ? Ext.getBody() : me.autoRender);
        }
    },

    /**
     * @private
     * &lt;p&gt;Finds the ancestor Container responsible for allocating zIndexes for the passed Component.&lt;/p&gt;
     * &lt;p&gt;That will be the outermost floating Container (a Container which has no ownerCt and has floating:true).&lt;/p&gt;
     * &lt;p&gt;If we have no ancestors, or we walk all the way up to the document body, there&#39;s no zIndexParent,
     * and the global Ext.WindowMgr will be used.&lt;/p&gt;
     */
    getZIndexParent: function() {
        var p = this.ownerCt,
            c;

        if (p) {
            while (p) {
                c = p;
                p = p.ownerCt;
            }
            if (c.floating) {
                return c;
            }
        }
    },

    // @private
    render : function(container, position) {
        var me = this;

        if (!me.rendered &amp;&amp; me.fireEvent(&#39;beforerender&#39;, me) !== false) {
            // If this.el is defined, we want to make sure we are dealing with
            // an Ext Element.
            if (me.el) {
                me.el = Ext.get(me.el);
            }

            // Floaters must register with a ZIndexManager at render time when the ownerCt chain is complete
            if (me.floating) {
                me.zIndexParent = me.getZIndexParent();
                me.floatParent = me.ownerCt;
                delete me.ownerCt;

                // If a floating Component is configured to be constrained, but has no configured
                // constrainTo setting, set its constrainTo to be it&#39;s ownerCt before rendering.
                if ((me.constrain || me.constrainHeader) &amp;&amp; !me.constrainTo) {
                    me.constrainTo = me.floatParent ? me.floatParent.getTargetEl() : me.container;
                }
                if (me.zIndexParent) {
                    me.zIndexParent.registerFloatingItem(me);
                } else {
                    Ext.WindowMgr.register(me);
                }
            }

            container = me.initContainer(container);

            me.onRender(container, position);

            // Tell the encapsulating element to hide itself in the way the Component is configured to hide
            // This means DISPLAY, VISIBILITY or OFFSETS.
            me.el.setVisibilityMode(Ext.core.Element[me.hideMode.toUpperCase()]);

            if (me.overCls) {
                me.el.hover(me.addOverCls, me.removeOverCls, me);
            }
            
            me.fireEvent(&#39;render&#39;, me);

            me.initContent();

            me.afterRender(container);
            me.fireEvent(&#39;afterrender&#39;, me);

            me.initEvents();

            if (me.autoShow) {
                me.show();
            }

            if (me.hidden) {
                // Hiding during the render process should not perform any ancillary
                // actions that the full hide process does; It is not hiding, it begins in a hidden state.&#39;
                // So just make the element hidden according to the configured hideMode
                me.el.hide();
            }

            if (me.disabled) {
                // pass silent so the event doesn&#39;t fire the first time.
                me.disable(true);
            }
        }
        return me;
    },

    // @private
    onRender : function(container, position) {
        var me = this,
            el = me.el,
            cls = me.initCls(),
            styles = me.initStyles(),
            renderTpl,
            renderData;

        position = me.getInsertPosition(position);

        if (!el) {
            if (position) {
                el = Ext.core.DomHelper.insertBefore(position, me.getElConfig(), true);
            }
            else {
                el = Ext.core.DomHelper.append(container, me.getElConfig(), true);
            }
        }
        else if (me.allowDomMove !== false) {
            if (position) {
                container.dom.insertBefore(el.dom, position);
            } else {
                container.dom.appendChild(el.dom);
            }
        }

        if (Ext.scopeResetCSS &amp;&amp; !me.ownerCt) {
            // If this component&#39;s el is the body element, we add the reset class to the html tag
            if (el.dom == Ext.getBody().dom) {
                el.parent().addCls(Ext.baseCSSPrefix + &#39;reset&#39;);
            }
            else {
                // Else we wrap this element in an element that adds the reset class.
                me.resetEl = el.wrap({
                    cls: Ext.baseCSSPrefix + &#39;reset&#39;
                });                
            }
        }
                
        el.addCls(cls);
        el.setStyle(styles);

        // Here we check if the component has a height set through style or css.
        // If it does then we set the this.height to that value and it won&#39;t be
        // considered an auto height component
        // if (this.height === undefined) {
        //     var height = el.getHeight();
        //     // This hopefully means that the panel has an explicit height set in style or css
        //     if (height - el.getPadding(&#39;tb&#39;) - el.getBorderWidth(&#39;tb&#39;) &gt; 0) {
        //         this.height = height;
        //     }
        // }

        me.el = el;

        if (!Ext.supports.CSS3BorderRadius) {
            me.initFrame(cls, styles);
        }

        renderTpl = me.initRenderTpl();
        if (renderTpl) {
            renderData = me.initRenderData();
            renderTpl.append(me.getTargetEl(), renderData);
        }

        me.applyRenderSelectors();
        me.rendered = true;
    },

    // @private
    afterRender : function() {
        var me = this,
            pos,
            xy;

        me.getComponentLayout();

        // Set the size if a size is configured, or if this is the outermost Container
        if (!me.ownerCt || (me.height || me.width)) {
            me.setSize(me.width, me.height);
        }

        // For floaters, calculate x and y if they aren&#39;t defined by aligning
        // the sized element to the center of either the the container or the ownerCt
        if (me.floating &amp;&amp; (me.x === undefined || me.y === undefined)) {
            if (me.floatParent) {
                xy = me.el.getAlignToXY(me.floatParent.getTargetEl(), &#39;c-c&#39;);
                pos = me.floatParent.getTargetEl().translatePoints(xy[0], xy[1]);
            } else {
                xy = me.el.getAlignToXY(me.container, &#39;c-c&#39;);
                pos = me.container.translatePoints(xy[0], xy[1]);
            }
            me.x = me.x === undefined ? pos.left: me.x;
            me.y = me.y === undefined ? pos.top: me.y;
        }

        if (Ext.isDefined(me.x) || Ext.isDefined(me.y)) {
            me.setPosition(me.x, me.y);
        }

        if (me.styleHtmlContent) {
            me.getTargetEl().addCls(me.styleHtmlCls);
        }
    },

    frameCls: Ext.baseCSSPrefix + &#39;frame&#39;,

    frameTpl: [
        &#39;&lt;tpl if=&quot;top&quot;&gt;&#39;,
            &#39;&lt;tpl if=&quot;left&quot;&gt;&lt;div class=&quot;{frameCls}-tl {baseCls}-tl&quot; style=&quot;background-position: 0 -{tl}px; padding-left: {frameWidth}px&quot; role=&quot;presentation&quot;&gt;&lt;/tpl&gt;&#39;,
                &#39;&lt;tpl if=&quot;right&quot;&gt;&lt;div class=&quot;{frameCls}-tr {baseCls}-tr&quot; style=&quot;background-position: right -{tr}px; padding-right: {frameWidth}px&quot; role=&quot;presentation&quot;&gt;&lt;/tpl&gt;&#39;,
                    &#39;&lt;div class=&quot;{frameCls}-tc {baseCls}-tc&quot; style=&quot;background-position: 0 0; height: {frameWidth}px&quot; role=&quot;presentation&quot;&gt;&lt;/div&gt;&#39;,
                &#39;&lt;tpl if=&quot;right&quot;&gt;&lt;/div&gt;&lt;/tpl&gt;&#39;,
            &#39;&lt;tpl if=&quot;left&quot;&gt;&lt;/div&gt;&lt;/tpl&gt;&#39;,
        &#39;&lt;/tpl&gt;&#39;,
        &#39;&lt;tpl if=&quot;left&quot;&gt;&lt;div class=&quot;{frameCls}-ml {baseCls}-ml&quot; style=&quot;background-position: 0 0; padding-left: {frameWidth}px&quot; role=&quot;presentation&quot;&gt;&lt;/tpl&gt;&#39;,
            &#39;&lt;tpl if=&quot;right&quot;&gt;&lt;div class=&quot;{frameCls}-mr {baseCls}-mr&quot; style=&quot;background-position: right 0; padding-right: {frameWidth}px&quot; role=&quot;presentation&quot;&gt;&lt;/tpl&gt;&#39;,
                &#39;&lt;div class=&quot;{frameCls}-mc {baseCls}-mc&quot; role=&quot;presentation&quot;&gt;&lt;/div&gt;&#39;,
            &#39;&lt;tpl if=&quot;right&quot;&gt;&lt;/div&gt;&lt;/tpl&gt;&#39;,
        &#39;&lt;tpl if=&quot;left&quot;&gt;&lt;/div&gt;&lt;/tpl&gt;&#39;,
        &#39;&lt;tpl if=&quot;bottom&quot;&gt;&#39;,
            &#39;&lt;tpl if=&quot;left&quot;&gt;&lt;div class=&quot;{frameCls}-bl {baseCls}-bl&quot; style=&quot;background-position: 0 -{bl}px; padding-left: {frameWidth}px&quot; role=&quot;presentation&quot;&gt;&lt;/tpl&gt;&#39;,
                &#39;&lt;tpl if=&quot;right&quot;&gt;&lt;div class=&quot;{frameCls}-br {baseCls}-br&quot; style=&quot;background-position: right -{br}px; padding-right: {frameWidth}px&quot; role=&quot;presentation&quot;&gt;&lt;/tpl&gt;&#39;,
                    &#39;&lt;div class=&quot;{frameCls}-bc {baseCls}-bc&quot; style=&quot;background-position: 0 -{frameWidth}px; height: {frameWidth}px&quot; role=&quot;presentation&quot;&gt;&lt;/div&gt;&#39;,
                &#39;&lt;tpl if=&quot;right&quot;&gt;&lt;/div&gt;&lt;/tpl&gt;&#39;,
            &#39;&lt;tpl if=&quot;left&quot;&gt;&lt;/div&gt;&lt;/tpl&gt;&#39;,
        &#39;&lt;/tpl&gt;&#39;
    ],

    frameTableTpl: [
        &#39;&lt;table&gt;&lt;tbody&gt;&#39;,
            &#39;&lt;tpl if=&quot;top&quot;&gt;&#39;,
                &#39;&lt;tr&gt;&#39;,
                    &#39;&lt;tpl if=&quot;left&quot;&gt;&lt;td class=&quot;{frameCls}-tl {baseCls}-tl&quot; style=&quot;background-position: 0 -{tl}px; padding-left:{frameWidth}px&quot; role=&quot;presentation&quot;&gt;&lt;/td&gt;&lt;/tpl&gt;&#39;,
                    &#39;&lt;td class=&quot;{frameCls}-tc {baseCls}-tc&quot; style=&quot;background-position: 0 0; height: {frameWidth}px&quot; role=&quot;presentation&quot;&gt;&lt;/td&gt;&#39;,
                    &#39;&lt;tpl if=&quot;right&quot;&gt;&lt;td class=&quot;{frameCls}-tr {baseCls}-tr&quot; style=&quot;background-position: right -{tr}px; padding-left: {frameWidth}px&quot; role=&quot;presentation&quot;&gt;&lt;/td&gt;&lt;/tpl&gt;&#39;,
                &#39;&lt;/tr&gt;&#39;,
            &#39;&lt;/tpl&gt;&#39;,
            &#39;&lt;tr&gt;&#39;,
                &#39;&lt;tpl if=&quot;left&quot;&gt;&lt;td class=&quot;{frameCls}-ml {baseCls}-ml&quot; style=&quot;background-position: 0 -{ml}px; padding-left: {frameWidth}px&quot; role=&quot;presentation&quot;&gt;&lt;/td&gt;&lt;/tpl&gt;&#39;,
                &#39;&lt;td class=&quot;{frameCls}-mc {baseCls}-mc&quot; style=&quot;background-position: 0 0;&quot; role=&quot;presentation&quot;&gt;&lt;/td&gt;&#39;,
                &#39;&lt;tpl if=&quot;right&quot;&gt;&lt;td class=&quot;{frameCls}-mr {baseCls}-mr&quot; style=&quot;background-position: right 0; padding-left: {frameWidth}px&quot; role=&quot;presentation&quot;&gt;&lt;/td&gt;&lt;/tpl&gt;&#39;,
            &#39;&lt;/tr&gt;&#39;,
            &#39;&lt;tpl if=&quot;bottom&quot;&gt;&#39;,
                &#39;&lt;tr&gt;&#39;,
                    &#39;&lt;tpl if=&quot;left&quot;&gt;&lt;td class=&quot;{frameCls}-bl {baseCls}-bl&quot; style=&quot;background-position: 0 -{bl}px; padding-left: {frameWidth}px&quot; role=&quot;presentation&quot;&gt;&lt;/td&gt;&lt;/tpl&gt;&#39;,
                    &#39;&lt;td class=&quot;{frameCls}-bc {baseCls}-bc&quot; style=&quot;background-position: 0 -{frameWidth}px; height: {frameWidth}px&quot; role=&quot;presentation&quot;&gt;&lt;/td&gt;&#39;,
                    &#39;&lt;tpl if=&quot;right&quot;&gt;&lt;td class=&quot;{frameCls}-br {baseCls}-br&quot; style=&quot;background-position: right -{br}px; padding-left: {frameWidth}px&quot; role=&quot;presentation&quot;&gt;&lt;/td&gt;&lt;/tpl&gt;&#39;,
                &#39;&lt;/tr&gt;&#39;,
            &#39;&lt;/tpl&gt;&#39;,
        &#39;&lt;/tbody&gt;&lt;/table&gt;&#39;
    ],

    initFrame : function(cls, styles) {
        var me = this,
            frameBaseCls = me.baseCls + (me.ui ? &#39;-&#39; + me.ui : &#39;&#39;),
            left = me.el.getStyle(&#39;background-position-x&#39;),
            top = me.el.getStyle(&#39;background-position-y&#39;),
            frameWidth = 0, frameSize,
            frameTpl, info, max;

        // Some browsers dont support background-position-x and y, so for those
        // browsers let&#39;s split background-position into two parts.
        if (!left &amp;&amp; !top) {
            info = me.el.getStyle(&#39;background-position&#39;).split(&#39; &#39;);
            left = info[0];
            top = info[1];
        }
        
        // We actually pass a string in the form of &#39;[type][tl][tr]px [type][br][bl]px&#39; as
        // the background position of this.el from the css to indicate to IE that this component needs
        // framing. We parse it here and change the markup accordingly.
        if (parseInt(left, 10) &gt;= 1000000 &amp;&amp; parseInt(top, 10) &gt;= 1000000) {
            // Table markup starts with 110, div markup with 100.
            frameTpl = me.getFrameTpl(left.substr(0, 3) == &#39;110&#39;);

            // Get and parse the different border radius sizes
            max = Math.max;
            frameSize  = {
                top:    max(left.substr(3, 2), left.substr(5, 2)),
                right:  max(left.substr(5, 2), top.substr(3, 2)),
                bottom: max(top.substr(3, 2), top.substr(5, 2)),
                left:   max(top.substr(5, 2), left.substr(3, 2))
            };
            frameWidth = max(frameSize.top, frameSize.right, frameSize.bottom, frameSize.left);
        
            // Just to be sure we set the background image of the el to none.
            me.el.setStyle(&#39;background-image&#39;, &#39;none&#39;);
        }
        
        // This happens when you set frame: true explicitly without using the x-frame mixin in sass.
        // This way IE can&#39;t figure out what sizes to use and thus framing can&#39;t work.
        if (me.frame === true &amp;&amp; !frameSize) {
            //&lt;debug error&gt;
            throw new Error(&quot;[&quot; + Ext.getClassName(me) + &quot;#initFrame] You have set frame: true explicity on this component &quot; +
                            &quot;while it doesnt have any framing in sass. This way IE can&#39;t figure out what sizes to use and thus framing &quot; +
                            &quot;on this component will be disabled&quot;);
            //&lt;/debug&gt;
        }
        
        me.frame = me.frame || !!frameWidth;
        me.frameSize = frameSize || false;
        
        if (me.frame) {
            //&lt;debug error&gt;
            if (!frameSize) {
                throw new Error(&quot;[&quot; + Ext.getClassName(me) + &quot;#initFrame] Unable to read background-image style &quot; +
                                &quot;(got &#39;&quot; + info + &quot;&#39;) of element: &quot; + me.el.dom.outerHTML + &quot; to handle framing.&quot;);
            }
            //&lt;/debug&gt;
        
            // Here we render the frameTpl to this component. This inserts the 9point div or the table framing.
            frameTpl.append(me.el, {
                frameCls:   me.frameCls,
                baseCls:    frameBaseCls,
                frameWidth: frameWidth,
                top:        !!frameSize.top,
                left:       !!frameSize.left,
                right:      !!frameSize.right,
                bottom:     !!frameSize.bottom,
                tl:         (frameWidth * 2),
                tr:         (frameWidth * 3),
                bl:         (frameWidth * 4),
                br:         (frameWidth * 5)
            });
        
            // The frameBody is returned in getTargetEl, so that layouts render items to the correct target.
            me.frameBody = me.el.down(&#39;.&#39; + frameBaseCls + &#39;-mc&#39;);
        }
    },

    getFrameTpl : function(table) {
        var frameTpl = table ? this.frameTableTpl : this.frameTpl;

        if (Ext.isArray(frameTpl) || typeof frameTpl === &quot;string&quot;) {
            frameTpl = new Ext.XTemplate(frameTpl);
        }

        return frameTpl;
    },

    /**
     * &lt;p&gt;Creates an array of class names from the configurations to add to this Component&#39;s &lt;code&gt;el&lt;/code&gt; on render.&lt;/p&gt;
     * &lt;p&gt;Private, but (possibly) used by ComponentQuery for selection by class name if Component is not rendered.&lt;/p&gt;
     * @return {Array} An array of class names with which the Component&#39;s element will be rendered.
     * @private
     */
    initCls: function() {
        var me = this,
            cls = [];
        
        cls.push(me.baseCls);

        //&lt;deprecated since=0.99&gt;
        if (Ext.isDefined(me.cmpCls)) {
            throw &quot;Ext.Component: cmpCls renamed to componentCls&quot;;
        }
        //&lt;/deprecated&gt;
        if (me.componentCls) {
            cls.push(me.componentCls);
        } else {
            me.componentCls = me.baseCls;
        }
        if (me.cls) {
            cls.push(me.cls);
            delete me.cls;
        }
        if (me.ui) {
            cls.push(me.componentCls + &#39;-&#39; + me.ui);
        }
        if (me.frame) {
            cls.push(&#39;x-framed &#39; + me.baseCls + &#39;-&#39; + (me.ui ? me.ui + &#39;-&#39; : &#39;&#39;) + &#39;framed&#39;);
        }
        return cls.concat(me.additionalCls);
    },

    getElConfig : function() {
        var result = this.autoEl || {tag: &#39;div&#39;};
        result.id = this.id;
        return result;
    },

    <a name="method-Ext.AbstractComponent-getInsertPosition"></a>/**
     * This function takes the position argument passed to onRender and returns a
     * DOM element that you can use in the insertBefore.
     * @param {String/Number/Element/HTMLElement} position Index, element id or element you want
     * to put this component before.
     * @return {HTMLElement} DOM element that you can use in the insertBefore
     */
    getInsertPosition: function(position) {
        // Convert the position to an element to insert before
        if (position !== undefined) {
            if (Ext.isNumber(position)) {
                position = this.container.dom.childNodes[position];
            }
            else {
                position = Ext.getDom(position);
            }
        }

        return position;
    },

    /**
     * Adds ctCls to container.
     * @return {Ext.core.Element} The initialized container
     * @private
     */
    initContainer: function(container) {
        var me = this;
        
        // If you render a component specifying the el, we get the container
        // of the el, and make sure we dont move the el around in the dom
        // during the render
        if (!container &amp;&amp; me.el) {
            container = me.el.dom.parentNode;
            me.allowDomMove = false;
        }

        me.container = Ext.get(container);

        if (me.ctCls) {
            me.container.addCls(me.ctCls);
        }

        return me.container;
    },

    /**
     * Initialized the renderData to be used when rendering the renderTpl.
     * @return {Object} Object with keys and values that are going to be applied to the renderTpl
     * @private
     */
    initRenderData: function() {
        var me = this;
        
        return Ext.applyIf(me.renderData, {
            ui: me.ui,
            baseCls: me.baseCls,
            componentCls: me.componentCls,
            frame: me.frame
        });
    },

    /**
     * Initializes the renderTpl.
     * @return {Ext.XTemplate} The renderTpl XTemplate instance.
     * @private
     */
    initRenderTpl: function() {
        var renderTpl = this.renderTpl,
            prototype = Ext.AbstractComponent.prototype;

        if (renderTpl) {
            if (prototype.renderTpl !== renderTpl) {
                if (Ext.isArray(renderTpl) || typeof renderTpl === &quot;string&quot;) {
                    renderTpl = new Ext.XTemplate(renderTpl);
                }
            }
            else if (Ext.isArray(prototype.renderTpl)){
                renderTpl = prototype.renderTpl = new Ext.XTemplate(renderTpl);
            }
        }
        return renderTpl;
    },

    /**
     * Function description
     * @return {String} A CSS style string with style, padding, margin and border.
     * @private
     */
    initStyles: function() {
        var style = {},
            me = this,
            Element = Ext.core.Element,
            i, ln, split, prop;

        if (Ext.isString(me.style)) {
            style = Element.parseStyles(me.style);
        } else {
            style = Ext.apply({}, me.style);
        }

        // Convert the padding, margin and border properties from a space seperated string
        // into a proper style string
        if (me.padding !== undefined) {
            style.padding = Element.unitizeBox((me.padding === true) ? 5 : me.padding);
        }

        if (me.margin !== undefined) {
            style.margin = Element.unitizeBox((me.margin === true) ? 5 : me.margin);
        }

        // Border styles on a Panel are different. Panel (and subclass) borders are handled by the theming.
        if (me.border !== undefined &amp;&amp; me.border !== false &amp;&amp; !(me instanceof Ext.panel.Panel)) {
            style.borderWidth = Element.unitizeBox((me.border === true) ? 1 : me.border);
        }

        delete me.style;
        return style;
    },

    /**
     * Initializes this components contents. It checks for the properties
     * html, contentEl and tpl/data.
     * @private
     */
    initContent: function() {
        var me = this,
            target = me.getTargetEl(),
            contentEl,
            pre;

        if (me.html) {
            target.update(Ext.core.DomHelper.markup(me.html));
            delete me.html;
        }

        if (me.contentEl) {
            contentEl = Ext.get(me.contentEl);
            pre = Ext.baseCSSPrefix;
            contentEl.removeCls([pre + &#39;hidden&#39;, pre + &#39;hide-display&#39;, pre + &#39;hide-offsets&#39;, pre + &#39;hide-nosize&#39;]);
            target.appendChild(contentEl.dom);
        }

        if (me.tpl) {
            // Make sure this.tpl is an instantiated XTemplate
            if (!me.tpl.isTemplate) {
                me.tpl = new Ext.XTemplate(me.tpl);
            }

            if (me.data) {
                me.tpl[me.tplWriteMode](target, me.data);
                delete me.data;
            }
        }
    },

    // @private
    initEvents : function() {
        var me = this,
            afterRenderEvents = me.afterRenderEvents,
            property, listeners;
        if (afterRenderEvents) {
            for (property in afterRenderEvents) {
                if (afterRenderEvents.hasOwnProperty(property)) {
                    listeners = afterRenderEvents[property];
                    if (me[property] &amp;&amp; me[property].on) {
                        me.mon(me[property], listeners);
                    }
                }
            }
        }
    },

    /**
     * Sets references to elements inside the component. E.g body -&gt; x-panel-body
     * @private
     */
    applyRenderSelectors: function() {
        var selectors = this.renderSelectors || {},
            el = this.el.dom,
            selector;

        for (selector in selectors) {
            if (selectors.hasOwnProperty(selector) &amp;&amp; selectors[selector]) {
                this[selector] = Ext.get(Ext.DomQuery.selectNode(selectors[selector], el));
            }
        }
    },

    <a name="method-Ext.AbstractComponent-is"></a>/**
     * Tests whether this Component matches the selector string.
     * @param {String} selector The selector string to test against.
     * @return {Boolean} True if this Component matches the selector.
     */
    is: function(selector) {
        return Ext.ComponentQuery.is(this, selector);
    },

    <a name="method-Ext.AbstractComponent-up"></a>/**
     * &lt;p&gt;Walks up the &lt;code&gt;ownerCt&lt;/code&gt; axis looking for an ancestor Container which matches
     * the passed simple selector.&lt;/p&gt;
     * &lt;p&gt;Example:<br><span style="display: none">**/</span>var owningTabPanel = grid.up(&#39;tabpanel&#39;);
<br><span style="display: none">/**</span>     * @param {String} selector Optional. The simple selector to test.
     * @return {Container} The matching ancestor Container (or &lt;code&gt;undefined&lt;/code&gt; if no match was found).
     */
    up: function(selector) {
        var result = this.ownerCt;
        if (selector) {
            for (; result; result = result.ownerCt) {
                if (Ext.ComponentQuery.is(result, selector)) {
                    return result;
                }
            }
        }
        return result;
    },

    <a name="method-Ext.AbstractComponent-nextSibling"></a>/**
     * &lt;p&gt;Returns the next sibling of this Component.&lt;/p&gt;
     * &lt;p&gt;Optionally selects the next sibling which matches the passed {@link Ext.ComponentQuery ComponentQuery} selector.&lt;/p&gt;
     * &lt;p&gt;May also be refered to as &lt;code&gt;&lt;b&gt;next()&lt;/b&gt;&lt;/code&gt;&lt;/p&gt;
     * &lt;p&gt;Note that this is limited to siblings, and if no siblings of the item match, &lt;code&gt;null&lt;/code&gt; is returned. Contrast with {@link #nextNode}&lt;/p&gt;
     * @param {String} selector Optional. A {@link Ext.ComponentQuery ComponentQuery} selector to filter the following items.
     * @returns The next sibling (or the next sibling which matches the selector). Returns null if there is no matching sibling.
     */
    nextSibling: function(selector) {
        var o = this.ownerCt, it, last, idx, c;
        if (o) {
            it = o.items;
            idx = it.indexOf(this) + 1;
            if (idx) {
                if (selector) {
                    for (last = it.getCount(); idx &lt; last; idx++) {
                        if ((c = it.getAt(idx)).is(selector)) {
                            return c;
                        }
                    }
                } else {
                    if (idx &lt; it.getCount()) {
                        return it.getAt(idx);
                    }
                }
            }
        }
        return null;
    },

    <a name="method-Ext.AbstractComponent-previousSibling"></a>/**
     * &lt;p&gt;Returns the previous sibling of this Component.&lt;/p&gt;
     * &lt;p&gt;Optionally selects the previous sibling which matches the passed {@link Ext.ComponentQuery ComponentQuery} selector.&lt;/p&gt;
     * &lt;p&gt;May also be refered to as &lt;code&gt;&lt;b&gt;prev()&lt;/b&gt;&lt;/code&gt;&lt;/p&gt;
     * &lt;p&gt;Note that this is limited to siblings, and if no siblings of the item match, &lt;code&gt;null&lt;/code&gt; is returned. Contrast with {@link #previousNode}&lt;/p&gt;
     * @param {String} selector Optional. A {@link Ext.ComponentQuery ComponentQuery} selector to filter the preceding items.
     * @returns The previous sibling (or the previous sibling which matches the selector). Returns null if there is no matching sibling.
     */
    previousSibling: function(selector) {
        var o = this.ownerCt, it, idx, c;
        if (o) {
            it = o.items;
            idx = it.indexOf(this);
            if (idx != -1) {
                if (selector) {
                    for (--idx; idx &gt;= 0; idx--) {
                        if ((c = it.getAt(idx)).is(selector)) {
                            return c;
                        }
                    }
                } else {
                    if (idx) {
                        return it.getAt(--idx);
                    }
                }
            }
        }
        return null;
    },

    <a name="method-Ext.AbstractComponent-previousNode"></a>/**
     * &lt;p&gt;Returns the previous node in the Component tree in tree traversal order.&lt;/p&gt;
     * &lt;p&gt;Note that this is not limited to siblings, and if invoked upon a node with no matching siblings, will
     * walk the tree in reverse order to attempt to find a match. Contrast with {@link #previousSibling}.&lt;/p&gt;
     * @param {String} selector Optional. A {@link Ext.ComponentQuery ComponentQuery} selector to filter the preceding nodes.
     * @returns The previous node (or the previous node which matches the selector). Returns null if there is no matching node.
     */
    previousNode: function(selector, includeSelf) {
        var node = this,
            result,
            it, len, i;

        // If asked to include self, test me
        if (includeSelf &amp;&amp; node.is(selector)) {
            return node;
        }

        result = this.prev(selector);
        if (result) {
            return result;
        }

        if (node.ownerCt) {
            for (it = node.ownerCt.items.items, i = Ext.Array.indexOf(it, node) - 1; i &gt; -1; i--) {
                if (it[i].query) {
                    result = it[i].query(selector);
                    result = result[result.length - 1];
                    if (result) {
                        return result;
                    }
                }
            }
            return node.ownerCt.previousNode(selector, true);
        }
    },

    <a name="method-Ext.AbstractComponent-nextNode"></a>/**
     * &lt;p&gt;Returns the next node in the Component tree in tree traversal order.&lt;/p&gt;
     * &lt;p&gt;Note that this is not limited to siblings, and if invoked upon a node with no matching siblings, will
     * walk the tree to attempt to find a match. Contrast with {@link #pnextSibling}.&lt;/p&gt;
     * @param {String} selector Optional. A {@link Ext.ComponentQuery ComponentQuery} selector to filter the following nodes.
     * @returns The next node (or the next node which matches the selector). Returns null if there is no matching node.
     */
    nextNode: function(selector, includeSelf) {
        var node = this,
            result,
            it, len, i;

        // If asked to include self, test me
        if (includeSelf &amp;&amp; node.is(selector)) {
            return node;
        }

        result = this.next(selector);
        if (result) {
            return result;
        }

        if (node.ownerCt) {
            for (it = node.ownerCt.items, i = it.indexOf(node) + 1, it = it.items, len = it.length; i &lt; len; i++) {
                if (it[i].down) {
                    result = it[i].down(selector);
                    if (result) {
                        return result;
                    }
                }
            }
            return node.ownerCt.nextNode(selector);
        }
    },

    <a name="method-Ext.AbstractComponent-getId"></a>/**
     * Retrieves the id of this component.
     * Will autogenerate an id if one has not already been set.
     */
    getId : function() {
        return this.id || (this.id = &#39;ext-comp-&#39; + (this.getAutoId()));
    },

    getItemId : function() {
        return this.itemId || this.id;
    },

    <a name="method-Ext.AbstractComponent-getEl"></a>/**
     * Retrieves the top level element representing this component.
     */
    getEl : function() {
        return this.el;
    },

    /**
     * This is used to determine where to insert the &#39;html&#39;, &#39;contentEl&#39; and &#39;items&#39; in this component.
     * @private
     */
    getTargetEl: function() {
        return this.frameBody || this.el;
    },

    <a name="method-Ext.AbstractComponent-isXType"></a>/**
     * &lt;p&gt;Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
     * from the xtype (default) or whether it is directly of the xtype specified (shallow = true).&lt;/p&gt;
     * &lt;p&gt;&lt;b&gt;If using your own subclasses, be aware that a Component must register its own xtype
     * to participate in determination of inherited xtypes.&lt;/b&gt;&lt;/p&gt;
     * &lt;p&gt;For a list of all available xtypes, see the {@link Ext.Component} header.&lt;/p&gt;
     * &lt;p&gt;Example usage:&lt;/p&gt;
     * <br><span style="display: none">**/</span>var t = new Ext.form.Text();
var isText = t.isXType(&#39;textfield&#39;);        // true
var isBoxSubclass = t.isXType(&#39;field&#39;);       // true, descended from Ext.form.Field
var isBoxInstance = t.isXType(&#39;field&#39;, true); // false, not a direct Ext.form.Field instance
<br><span style="display: none">/**</span>     * @param {String} xtype The xtype to check for this Component
     * @param {Boolean} shallow (optional) False to check whether this Component is descended from the xtype (this is
     * the default), or true to check whether this Component is directly of the specified xtype.
     * @return {Boolean} True if this component descends from the specified xtype, false otherwise.
     */
    isXType: function(xtype, shallow) {
        //assume a string by default
        if (Ext.isFunction(xtype)) {
            xtype = xtype.xtype;
            //handle being passed the class, e.g. Ext.Component
        } else if (Ext.isObject(xtype)) {
            xtype = xtype.statics().xtype;
            //handle being passed an instance
        }

        return !shallow ? (&#39;/&#39; + this.getXTypes() + &#39;/&#39;).indexOf(&#39;/&#39; + xtype + &#39;/&#39;) != -1: this.self.xtype == xtype;
    },

    <a name="method-Ext.AbstractComponent-getXTypes"></a>/**
     * &lt;p&gt;Returns this Component&#39;s xtype hierarchy as a slash-delimited string. For a list of all
     * available xtypes, see the {@link Ext.Component} header.&lt;/p&gt;
     * &lt;p&gt;&lt;b&gt;If using your own subclasses, be aware that a Component must register its own xtype
     * to participate in determination of inherited xtypes.&lt;/b&gt;&lt;/p&gt;
     * &lt;p&gt;Example usage:&lt;/p&gt;
     * <br><span style="display: none">**/</span>var t = new Ext.form.Text();
alert(t.getXTypes());  // alerts &#39;component/field/textfield&#39;
<br><span style="display: none">/**</span>     * @return {String} The xtype hierarchy string
     */
    getXTypes: function() {
        var self = this.self,
            xtypes      = [],
            parentPrototype  = this,
            xtype;

        if (!self.xtypes) {
            while (parentPrototype &amp;&amp; Ext.getClass(parentPrototype)) {
                xtype = Ext.getClass(parentPrototype).xtype;

                if (xtype !== undefined) {
                    xtypes.unshift(xtype);
                }

                parentPrototype = parentPrototype.superclass;
            }

            self.xtypeChain = xtypes;
            self.xtypes = xtypes.join(&#39;/&#39;);
        }

        return self.xtypes;
    },

    <a name="method-Ext.AbstractComponent-update"></a>/**
     * Update the content area of a component.
     * @param {Mixed} htmlOrData
     * If this component has been configured with a template via the tpl config
     * then it will use this argument as data to populate the template.
     * If this component was not configured with a template, the components
     * content area will be updated via Ext.core.Element update
     * @param {Boolean} loadScripts
     * (optional) Only legitimate when using the html configuration. Defaults to false
     * @param {Function} callback
     * (optional) Only legitimate when using the html configuration. Callback to execute when scripts have finished loading
     */
    update : function(htmlOrData, loadScripts, cb) {
        var me = this;

        if (me.tpl &amp;&amp; !Ext.isString(htmlOrData)) {
            me.data = htmlOrData;
            if (me.rendered) {
                me.tpl[me.tplWriteMode](me.getTargetEl(), htmlOrData || {});
            }
        } else {
            me.html = Ext.isObject(htmlOrData) ? Ext.core.DomHelper.markup(htmlOrData) : htmlOrData;
            if (me.rendered) {
                me.getTargetEl().update(me.html, loadScripts, cb);
            }
        }

        if (me.rendered) {
            me.doComponentLayout();
        }
    },

    <a name="method-Ext.AbstractComponent-setVisible"></a>/**
     * Convenience function to hide or show this component by boolean.
     * @param {Boolean} visible True to show, false to hide
     * @return {Ext.Component} this
     */
    setVisible : function(visible) {
        return this[visible ? &#39;show&#39;: &#39;hide&#39;]();
    },

    <a name="method-Ext.AbstractComponent-isVisible"></a>/**
     * Returns true if this component is visible.
     * @param {Boolean} deep. &lt;p&gt;Optional. Pass &lt;code&gt;true&lt;/code&gt; to interrogate the visibility status of all
     * parent Containers to determine whether this Component is truly visible to the user.&lt;/p&gt;
     * &lt;p&gt;Generally, to determine whether a Component is hidden, the no argument form is needed. For example
     * when creating dynamically laid out UIs in a hidden Container before showing them.&lt;/p&gt;
     * @return {Boolean} True if this component is visible, false otherwise.
     */
    isVisible: function(deep) {
        var me = this,
            child = me,
            visible = !me.hidden,
            ancestor = me.ownerCt;

        // Clear hiddenOwnerCt property
        me.hiddenAncestor = false;
        if (me.destroyed) {
            return false;
        }

        if (deep &amp;&amp; visible &amp;&amp; me.rendered &amp;&amp; ancestor) {
            while (ancestor) {
                // If any ancestor is hidden, then this is hidden.
                // If an ancestor Panel (only Panels have a collapse method) is collapsed,
                // then its layoutTarget (body) is hidden, so this is hidden unless its within a
                // docked item; they are still visible when collapsed (Unless they themseves are hidden)
                if (ancestor.hidden || (ancestor.collapsed &amp;&amp;
                        !(ancestor.getDockedItems &amp;&amp; Ext.Array.contains(ancestor.getDockedItems(), child)))) {
                    // Store hiddenOwnerCt property if needed
                    me.hiddenAncestor = ancestor;
                    visible = false;
                    break;
                }
                child = ancestor;
                ancestor = ancestor.ownerCt;
            }
        }
        return visible;
    },

    <a name="method-Ext.AbstractComponent-enable"></a>/**
     * Enable the component
     * @param {Boolean} silent
     * Passing false will supress the &#39;enable&#39; event from being fired.
     */
    enable : function(silent) {
        var me = this;

        if (me.rendered) {
            me.el.removeCls(me.disabledCls);
            me.el.dom.disabled = false;
            me.onEnable();
        }

        me.disabled = false;

        if (silent !== true) {
            me.fireEvent(&#39;enable&#39;, me);
        }

        return me;
    },

    <a name="method-Ext.AbstractComponent-disable"></a>/**
     * Disable the component.
     * @param {Boolean} silent
     * Passing true, will supress the &#39;disable&#39; event from being fired.
     */
    disable : function(silent) {
        var me = this;

        if (me.rendered) {
            me.el.addCls(me.disabledCls);
            me.el.dom.disabled = true;
            me.onDisable();
        }

        me.disabled = true;

        if (silent !== true) {
            me.fireEvent(&#39;disable&#39;, me);
        }

        return me;
    },

    <a name="method-Ext.AbstractComponent-isDisabled"></a>/**
     * Method to determine whether this Component is currently disabled.
     * @return {Boolean} the disabled state of this Component.
     */
    isDisabled : function() {
        return this.disabled;
    },

    <a name="method-Ext.AbstractComponent-setDisabled"></a>/**
     * Enable or disable the component.
     * @param {Boolean} disabled
     */
    setDisabled : function(disabled) {
        return this[disabled ? &#39;disable&#39;: &#39;enable&#39;]();
    },

    <a name="method-Ext.AbstractComponent-isHidden"></a>/**
     * Method to determine whether this Component is currently set to hidden.
     * @return {Boolean} the hidden state of this Component.
     */
    isHidden : function() {
        return this.hidden;
    },

    <a name="method-Ext.AbstractComponent-addCls"></a>/**
     * Adds a CSS class to the top level element representing this component.
     * @param {String} cls The CSS class name to add
     * @return {Ext.Component} Returns the Component to allow method chaining.
     */
    addCls : function() {
        var me = this,
            args = Ext.Array.toArray(arguments);
        if (me.rendered) {
            me.el.addCls(args);
        } else {
            me.additionalCls = Ext.Array.unique(me.additionalCls.concat(args));
        }
        return me;
    },

    //&lt;debug&gt;
    addClass : function() {
        throw &quot;Component: addClass has been deprecated. Please use addCls.&quot;;
    },
    //&lt;/debug&gt;

    <a name="method-Ext.AbstractComponent-removeCls"></a>/**
     * Removes a CSS class from the top level element representing this component.
     * @returns {Ext.Component} Returns the Component to allow method chaining.
     */
    removeCls : function() {
        var me = this,
            args = Ext.Array.toArray(arguments);
        if (me.rendered) {
            me.el.removeCls(args);
        } else if (me.additionalCls.length) {
            Ext.each(args, function(cls) {
                Ext.Array.remove(me.additionalCls, cls);
            });
        }
        return me;
    },

    //&lt;debug&gt;
    removeClass : function() {
        throw &quot;Component: removeClass has been deprecated. Please use removeCls.&quot;;
    },
    //&lt;/debug&gt;

    addOverCls: function() {
        var me = this;
        if (!me.disabled) {
            me.el.addCls(me.overCls);
        }  
    },

    removeOverCls: function() {
        this.el.removeCls(this.overCls);
    },

    addListener : function(element, listeners, scope, options) {
        var me = this,
            fn,
            option;

        if (Ext.isString(element) &amp;&amp; (Ext.isObject(listeners) || options &amp;&amp; options.element)) {
            if (options.element) {
                fn = listeners;

                listeners = {};
                listeners[element] = fn;
                element = options.element;
                if (scope) {
                    listeners.scope = scope;
                }

                for (option in options) {
                    if (options.hasOwnProperty(option)) {
                        if (me.eventOptionsRe.test(option)) {
                            listeners[option] = options[option];
                        }
                    }
                }
            }

            // At this point we have a variable called element,
            // and a listeners object that can be passed to on
            if (me[element] &amp;&amp; me[element].on) {
                me.mon(me[element], listeners);
            } else {
                me.afterRenderEvents = me.afterRenderEvents || {};
                me.afterRenderEvents[element] = listeners;
            }
        }

        return me.mixins.observable.addListener.apply(me, arguments);
    },

    // @TODO: implement removelistener to support the dom event stuff

    <a name="method-Ext.AbstractComponent-getBubbleTarget"></a>/**
     * Provides the link for Observable&#39;s fireEvent method to bubble up the ownership hierarchy.
     * @return {Ext.container.Container} the Container which owns this Component.
     */
    getBubbleTarget : function() {
        return this.ownerCt;
    },

    <a name="method-Ext.AbstractComponent-isFloating"></a>/**
     * Method to determine whether this Component is floating.
     * @return {Boolean} the floating state of this component.
     */
    isFloating : function() {
        return this.floating;
    },

    <a name="method-Ext.AbstractComponent-isDraggable"></a>/**
     * Method to determine whether this Component is draggable.
     * @return {Boolean} the draggable state of this component.
     */
    isDraggable : function() {
        return !!this.draggable;
    },

    <a name="method-Ext.AbstractComponent-isDroppable"></a>/**
     * Method to determine whether this Component is droppable.
     * @return {Boolean} the droppable state of this component.
     */
    isDroppable : function() {
        return !!this.droppable;
    },

    /**
     * @private
     * Method to manage awareness of when components are added to their
     * respective Container, firing an added event.
     * References are established at add time rather than at render time.
     * @param {Ext.container.Container} container Container which holds the component
     * @param {number} pos Position at which the component was added
     */
    onAdded : function(container, pos) {
        this.ownerCt = container;
        this.fireEvent(&#39;added&#39;, this, container, pos);
    },

    /**
     * @private
     * Method to manage awareness of when components are removed from their
     * respective Container, firing an removed event. References are properly
     * cleaned up after removing a component from its owning container.
     */
    onRemoved : function() {
        var me = this;
        
        me.fireEvent(&#39;removed&#39;, me, me.ownerCt);
        delete me.ownerCt;
    },

    // @private
    onEnable : function() {
        delete this.resetDisable;
    },
    
    // @private
    onDisable : function() {
        this.resetDisable = false;
    },
    
    // @private
    beforeDestroy : Ext.emptyFn,
    // @private
    // @private
    onResize : Ext.emptyFn,

    <a name="method-Ext.AbstractComponent-setSize"></a>/**
     * Sets the width and height of this Component. This method fires the {@link #resize} event. This method can accept
     * either width and height as separate arguments, or you can pass a size object like &lt;code&gt;{width:10, height:20}&lt;/code&gt;.
     * @param {Mixed} width The new width to set. This may be one of:&lt;div class=&quot;mdetail-params&quot;&gt;&lt;ul&gt;
     * &lt;li&gt;A Number specifying the new width in the {@link #getEl Element}&#39;s {@link Ext.core.Element#defaultUnit}s (by default, pixels).&lt;/li&gt;
     * &lt;li&gt;A String used to set the CSS width style.&lt;/li&gt;
     * &lt;li&gt;A size object in the format &lt;code&gt;{width: widthValue, height: heightValue}&lt;/code&gt;.&lt;/li&gt;
     * &lt;li&gt;&lt;code&gt;undefined&lt;/code&gt; to leave the width unchanged.&lt;/li&gt;
     * &lt;/ul&gt;&lt;/div&gt;
     * @param {Mixed} height The new height to set (not required if a size object is passed as the first arg).
     * This may be one of:&lt;div class=&quot;mdetail-params&quot;&gt;&lt;ul&gt;
     * &lt;li&gt;A Number specifying the new height in the {@link #getEl Element}&#39;s {@link Ext.core.Element#defaultUnit}s (by default, pixels).&lt;/li&gt;
     * &lt;li&gt;A String used to set the CSS height style. Animation may &lt;b&gt;not&lt;/b&gt; be used.&lt;/li&gt;
     * &lt;li&gt;&lt;code&gt;undefined&lt;/code&gt; to leave the height unchanged.&lt;/li&gt;
     * &lt;/ul&gt;&lt;/div&gt;
     * @return {Ext.Component} this
     */
    setSize : function(width, height) {
        var me = this,
            layoutCollection;
            
        // support for standard size objects
        if (Ext.isObject(width)) {
            height = width.height;
            width  = width.width;
        }

        // Constrain within configured maxima
        if (Ext.isNumber(width)) {
            width = Ext.Number.constrain(width, me.minWidth, me.maxWidth);
        }
        if (Ext.isNumber(height)) {
            height = Ext.Number.constrain(height, me.minHeight, me.maxHeight);
        }

        if (!me.rendered || !me.isVisible()) {
            // If an ownerCt is hidden, add my reference onto the layoutOnShow stack.  Set the needsLayout flag.
            if (me.hiddenAncestor) {
                layoutCollection = me.hiddenAncestor.layoutOnShow;
                layoutCollection.remove(me);
                layoutCollection.add(me);
            }
            me.needsLayout = {
                width: width,
                height: height,
                isSetSize: true
            };
            if (!me.rendered) {
                me.width  = (width !== undefined) ? width : me.width;
                me.height = (height !== undefined) ? height : me.height;
            }
            return me;
        }
        me.doComponentLayout(width, height, true);

        return me;
    },

    setCalculatedSize : function(width, height, ownerCt) {
        var me = this,
            layoutCollection;

        // support for standard size objects
        if (Ext.isObject(width)) {
            ownerCt = width.ownerCt;
            height = width.height;
            width  = width.width;
        }

        // Constrain within configured maxima
        if (Ext.isNumber(width)) {
            width = Ext.Number.constrain(width, me.minWidth, me.maxWidth);
        }
        if (Ext.isNumber(height)) {
            height = Ext.Number.constrain(height, me.minHeight, me.maxHeight);
        }

        if (!me.rendered || !me.isVisible()) {
            // If an ownerCt is hidden, add my reference onto the layoutOnShow stack.  Set the needsLayout flag.
            if (me.hiddenAncestor) {
                layoutCollection = me.hiddenAncestor.layoutOnShow;
                layoutCollection.remove(me);
                layoutCollection.add(me);
            }
            me.needsLayout = {
                width: width,
                height: height,
                isSetSize: false,
                ownerCt: ownerCt
            };
            return me;
        }
        me.doComponentLayout(width, height, false, ownerCt);

        return me;
    },

    <a name="method-Ext.AbstractComponent-doComponentLayout"></a>/**
     * This method needs to be called whenever you change something on this component that requires the Component&#39;s
     * layout to be recalculated.
     * @return {Ext.container.Container} this
     */
    doComponentLayout : function(width, height, isSetSize, ownerCt) {
        var me = this,
            componentLayout = me.getComponentLayout();

        // collapsed state is not relevant here, so no testing done.
        // Only Panels have a collapse method, and that just sets the width/height such that only
        // a single docked Header parallel to the collapseTo side are visible, and the Panel body is hidden.
        if (me.rendered &amp;&amp; componentLayout) {
            width = (width !== undefined) ? width : me.width;
            height = (height !== undefined) ? height : me.height;
            if (isSetSize) {
                me.width = width;
                me.height = height;
            }

            componentLayout.layout(width, height, isSetSize, ownerCt);
        }
        return me;
    },

    // @private
    setComponentLayout : function(layout) {
        var currentLayout = this.componentLayout;
        if (currentLayout &amp;&amp; currentLayout.isLayout &amp;&amp; currentLayout != layout) {
            currentLayout.setOwner(null);
        }
        this.componentLayout = layout;
        layout.setOwner(this);
    },

    getComponentLayout : function() {
        var me = this;
        
        if (!me.componentLayout || !me.componentLayout.isLayout) {
            me.setComponentLayout(Ext.layout.Manager.create(me.componentLayout, &#39;autocomponent&#39;));
        }
        return me.componentLayout;
    },

    <a name="method-Ext.AbstractComponent-afterComponentLayout"></a>/**
     * @param {Ext.Component} this
     * @param {Number} adjWidth The box-adjusted width that was set
     * @param {Number} adjHeight The box-adjusted height that was set
     */
    afterComponentLayout: function(width, height) {
        this.fireEvent(&#39;resize&#39;, this, width, height);
    },

    <a name="method-Ext.AbstractComponent-setPosition"></a>/**
     * Sets the left and top of the component.  To set the page XY position instead, use {@link #setPagePosition}.
     * This method fires the {@link #move} event.
     * @param {Number} left The new left
     * @param {Number} top The new top
     * @return {Ext.Component} this
     */
    setPosition : function(x, y) {
        var me = this;
        
        if (Ext.isObject(x)) {
            y = x.y;
            x = x.x;
        }

        if (!me.rendered) {
            return me;
        }

        if (x !== undefined || y !== undefined) {
            me.el.setBox(x, y);
            me.onPosition(x, y);
            me.fireEvent(&#39;move&#39;, me, x, y);
        }
        return me;
    },

    /* @private
     * Called after the component is moved, this method is empty by default but can be implemented by any
     * subclass that needs to perform custom logic after a move occurs.
     * @param {Number} x The new x position
     * @param {Number} y The new y position
     */
    onPosition: Ext.emptyFn,

    <a name="method-Ext.AbstractComponent-setWidth"></a>/**
     * Sets the width of the component.  This method fires the {@link #resize} event.
     * @param {Number} width The new width to setThis may be one of:&lt;div class=&quot;mdetail-params&quot;&gt;&lt;ul&gt;
     * &lt;li&gt;A Number specifying the new width in the {@link #getEl Element}&#39;s {@link Ext.core.Element#defaultUnit}s (by default, pixels).&lt;/li&gt;
     * &lt;li&gt;A String used to set the CSS width style.&lt;/li&gt;
     * &lt;/ul&gt;&lt;/div&gt;
     * @return {Ext.Component} this
     */
    setWidth : function(width) {
        return this.setSize(width);
    },

    <a name="method-Ext.AbstractComponent-setHeight"></a>/**
     * Sets the height of the component.  This method fires the {@link #resize} event.
     * @param {Number} height The new height to set. This may be one of:&lt;div class=&quot;mdetail-params&quot;&gt;&lt;ul&gt;
     * &lt;li&gt;A Number specifying the new height in the {@link #getEl Element}&#39;s {@link Ext.core.Element#defaultUnit}s (by default, pixels).&lt;/li&gt;
     * &lt;li&gt;A String used to set the CSS height style.&lt;/li&gt;
     * &lt;li&gt;&lt;i&gt;undefined&lt;/i&gt; to leave the height unchanged.&lt;/li&gt;
     * &lt;/ul&gt;&lt;/div&gt;
     * @return {Ext.Component} this
     */
    setHeight : function(height) {
        return this.setSize(undefined, height);
    },

    <a name="method-Ext.AbstractComponent-getSize"></a>/**
     * Gets the current size of the component&#39;s underlying element.
     * @return {Object} An object containing the element&#39;s size {width: (element width), height: (element height)}
     */
    getSize : function() {
        return this.el.getSize();
    },

    <a name="method-Ext.AbstractComponent-getWidth"></a>/**
     * Gets the current width of the component&#39;s underlying element.
     * @return {Number}
     */
    getWidth : function() {
        return this.el.getWidth();
    },

    <a name="method-Ext.AbstractComponent-getHeight"></a>/**
     * Gets the current height of the component&#39;s underlying element.
     * @return {Number}
     */
    getHeight : function() {
        return this.el.getHeight();
    },

    <a name="method-Ext.AbstractComponent-getLoader"></a>/**
     * Gets the {@link Ext.ComponentLoader} for this Component.
     * @return {Ext.ComponentLoader} The loader instance, null if it doesn&#39;t exist.
     */
    getLoader: function(){
        var me = this,
            autoLoad = me.autoLoad ? (Ext.isObject(me.autoLoad) ? me.autoLoad : {url: me.autoLoad}) : null,
            loader = me.loader || autoLoad;

        if (loader) {
            if (!loader.isLoader) {
                me.loader = Ext.create(&#39;Ext.ComponentLoader&#39;, Ext.apply({
                    target: me,
                    autoLoad: autoLoad
                }, loader));
            } else {
                loader.setTarget(me);
            }
            return me.loader;

        }
        return null;
    },

    <a name="method-Ext.AbstractComponent-setLoading"></a>/**
     * This method allows you to show or hide a LoadMask on top of this component.
     * @param {Boolean/Object} load True to show the default LoadMask or a config object
     * that will be passed to the LoadMask constructor. False to hide the current LoadMask.
     * @param {Boolean} targetEl True to mask the targetEl of this Component instead of the this.el.
     * For example, setting this to true on a Panel will cause only the body to be masked. (defaults to false)
     * @return {Ext.LoadMask} The LoadMask instance that has just been shown.
     */
    setLoading : function(load, targetEl) {
        var me = this;
        
        if (me.rendered) {
            if (load !== false) {
                me.loadMask = me.loadMask || new Ext.LoadMask(targetEl ? me.getTargetEl() : me.el, Ext.applyIf(Ext.isObject(load) ? load : {}));
                me.loadMask.show();
            } else {
                Ext.destroy(me.loadMask);
                me.loadMask = null;
            }
        }

        return me.loadMask;
    },

    <a name="method-Ext.AbstractComponent-setDocked"></a>/**
     * Sets the dock position of this component in its parent panel. Note that
     * this only has effect if this item is part of the dockedItems collection
     * of a parent that has a DockLayout (note that any Panel has a DockLayout
     * by default)
     * @return {Component} this
     */
    setDocked : function(dock, layoutParent) {
        var me = this;
        
        me.dock = dock;
        if (layoutParent &amp;&amp; me.ownerCt &amp;&amp; me.rendered) {
            me.ownerCt.doComponentLayout();
        }
        return me;
    },

    onDestroy : function() {
        var me = this;
        
        if (me.monitorResize &amp;&amp; Ext.EventManager.resizeEvent) {
            Ext.EventManager.resizeEvent.removeListener(me.setSize, me);
        }
        Ext.destroy(me.componentLayout, me.loadMask);
    },

    <a name="method-Ext.AbstractComponent-destroy"></a>/**
     * Destroys the Component.
     */
    destroy : function() {
        var me = this;

        if (!me.isDestroyed) {
            if (me.fireEvent(&#39;beforedestroy&#39;, me) !== false) {
                me.destroying = true;
                me.beforeDestroy();

                if (me.floating) {
                    delete me.floatParent;
                    // A zIndexManager is stamped into a *floating* Component when it is added to a Container.
                    // If it has no zIndexManager at render time, it is assigned to the global Ext.WindowMgr instance.
                    if (me.zIndexManager) {
                        me.zIndexManager.unregister(me);
                    }
                } else if (me.ownerCt &amp;&amp; me.ownerCt.remove) {
                    me.ownerCt.remove(me, false);
                }

                if (me.rendered) {
                    me.el.remove();
                }

                me.onDestroy();

                // Attempt to destroy all plugins
                Ext.destroy(me.plugins);

                Ext.ComponentMgr.unregister(me);
                me.fireEvent(&#39;destroy&#39;, me);

                me.mixins.state.destroy.call(me);

                me.clearListeners();
                me.destroying = false;
                me.isDestroyed = true;
            }
        }
    },

    <a name="method-Ext.AbstractComponent-getPlugin"></a>/**
     * Retrieves a plugin by its pluginId which has been bound to this
     * component.
     * @returns {Ext.AbstractPlugin} pluginInstance
     */
    getPlugin: function(pluginId) {
        var i = 0,
            plugins = this.plugins,
            ln = plugins.length;
        for (; i &lt; ln; i++) {
            if (plugins[i].pluginId === pluginId) {
                return plugins[i];
            }
        }
    }
}, function() {
    this.createAlias({
        on: &#39;addListener&#39;,
        prev: &#39;previousSibling&#39;,
        next: &#39;nextSibling&#39;
    });
});
￿</pre></pre></body></html>