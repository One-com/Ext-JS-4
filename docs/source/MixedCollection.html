<!DOCTYPE html><html><head><title>Sencha Documentation Project</title><link rel="stylesheet" href="../reset.css" type="text/css"><link rel="stylesheet" href="../prettify.css" type="text/css"><link rel="stylesheet" href="../prettify_sa.css" type="text/css"><script type="text/javascript" src="../prettify.js"></script></head><body onload="prettyPrint()"><pre class="prettyprint"><pre><a name="cls-Ext.util.MixedCollection"></a>/**
 * @class Ext.util.MixedCollection
 * &lt;p&gt;
 * Represents a collection of a set of key and value pairs. Each key in the MixedCollection
 * must be unique, the same key cannot exist twice. This collection is ordered, items in the
 * collection can be accessed by index  or via the key. Newly added items are added to
 * the end of the collection. This class is similar to {@link Ext.util.HashMap} however it
 * is heavier and provides more functionality. Sample usage:
 * <br><span style="display: none">**/</span>var coll = new Ext.util.MixedCollection();
coll.add(&#39;key1&#39;, &#39;val1&#39;);
coll.add(&#39;key2&#39;, &#39;val2&#39;);
coll.add(&#39;key3&#39;, &#39;val3&#39;);

console.log(coll.get(&#39;key1&#39;)); // prints &#39;val1&#39;
console.log(coll.indexOfKey(&#39;key3&#39;)); // prints 2
 * <br><span style="display: none">/**</span> *
 * &lt;p&gt;
 * The MixedCollection also has support for sorting and filtering of the values in the collection.
 * <br><span style="display: none">**/</span>var coll = new Ext.util.MixedCollection();
coll.add(&#39;key1&#39;, 100);
coll.add(&#39;key2&#39;, -100);
coll.add(&#39;key3&#39;, 17);
coll.add(&#39;key4&#39;, 0);
var biggerThanZero = coll.filterBy(function(value){
    return value &gt; 0;
});
console.log(biggerThanZero.getCount()); // prints 2
 * <br><span style="display: none">/**</span> * &lt;/p&gt;
 *
 * @constructor
 * @param {Boolean} allowFunctions Specify &lt;tt&gt;true&lt;/tt&gt; if the {@link #addAll}
 * function should add function references to the collection. Defaults to
 * &lt;tt&gt;false&lt;/tt&gt;.
 * @param {Function} keyFn A function that can accept an item of the type(s) stored in this MixedCollection
 * and return the key value for that item.  This is used when available to look up the key on items that
 * were passed without an explicit key parameter to a MixedCollection method.  Passing this parameter is
 * equivalent to providing an implementation for the {@link #getKey} method.
 */
Ext.define(&#39;Ext.util.MixedCollection&#39;, {
    extend: &#39;Ext.util.AbstractMixedCollection&#39;,
    mixins: {
        sortable: &#39;Ext.util.Sortable&#39;
    },

    constructor: function() {
        var me = this;
        me.callParent(arguments);
        me.addEvents(&#39;sort&#39;);
        me.mixins.sortable.initSortable.call(me);
    },

    doSort: function(sorterFn) {
        this.sortBy(sorterFn);
    },

    /**
     * @private
     * Performs the actual sorting based on a direction and a sorting function. Internally,
     * this creates a temporary array of all items in the MixedCollection, sorts it and then writes
     * the sorted array data back into this.items and this.keys
     * @param {String} property Property to sort by (&#39;key&#39;, &#39;value&#39;, or &#39;index&#39;)
     * @param {String} dir (optional) Direction to sort &#39;ASC&#39; or &#39;DESC&#39;. Defaults to &#39;ASC&#39;.
     * @param {Function} fn (optional) Comparison function that defines the sort order.
     * Defaults to sorting by numeric value.
     */
    _sort : function(property, dir, fn){
        var me = this,
            i, len,
            dsc   = String(dir).toUpperCase() == &#39;DESC&#39; ? -1 : 1,

            //this is a temporary array used to apply the sorting function
            c     = [],
            keys  = me.keys,
            items = me.items;

        //default to a simple sorter function if one is not provided
        fn = fn || function(a, b) {
            return a - b;
        };

        //copy all the items into a temporary array, which we will sort
        for(i = 0, len = items.length; i &lt; len; i++){
            c[c.length] = {
                key  : keys[i],
                value: items[i],
                index: i
            };
        }

        //sort the temporary array
        c.sort(function(a, b){
            var v = fn(a[property], b[property]) * dsc;
            if(v === 0){
                v = (a.index &lt; b.index ? -1 : 1);
            }
            return v;
        });

        //copy the temporary array back into the main this.items and this.keys objects
        for(i = 0, len = c.length; i &lt; len; i++){
            items[i] = c[i].value;
            keys[i]  = c[i].key;
        }

        me.fireEvent(&#39;sort&#39;, me);
    },

    <a name="method-Ext.util.MixedCollection-sortBy"></a>/**
     * Sorts the collection by a single sorter function
     * @param {Function} sorterFn The function to sort by
     */
    sortBy: function(sorterFn) {
        var me     = this,
            items  = me.items,
            keys   = me.keys,
            length = items.length,
            temp   = [],
            i;

        //first we create a copy of the items array so that we can sort it
        for (i = 0; i &lt; length; i++) {
            temp[i] = {
                key  : keys[i],
                value: items[i],
                index: i
            };
        }

        temp.sort(function(a, b) {
            var v = sorterFn(a.value, b.value);
            if (v === 0) {
                v = (a.index &lt; b.index ? -1 : 1);
            }

            return v;
        });

        //copy the temporary array back into the main this.items and this.keys objects
        for (i = 0; i &lt; length; i++) {
            items[i] = temp[i].value;
            keys[i]  = temp[i].key;
        }
        
        me.fireEvent(&#39;sort&#39;, me, items, keys);
    },

    <a name="method-Ext.util.MixedCollection-reorder"></a>/**
     * Reorders each of the items based on a mapping from old index to new index. Internally this
     * just translates into a sort. The &#39;sort&#39; event is fired whenever reordering has occured.
     * @param {Object} mapping Mapping from old item index to new item index
     */
    reorder: function(mapping) {
        var me = this,
            items = me.items,
            index = 0,
            length = items.length,
            order = [],
            remaining = [],
            oldIndex;

        me.suspendEvents();

        //object of {oldPosition: newPosition} reversed to {newPosition: oldPosition}
        for (oldIndex in mapping) {
            order[mapping[oldIndex]] = items[oldIndex];
        }

        for (index = 0; index &lt; length; index++) {
            if (mapping[index] == undefined) {
                remaining.push(items[index]);
            }
        }

        for (index = 0; index &lt; length; index++) {
            if (order[index] == undefined) {
                order[index] = remaining.shift();
            }
        }

        me.clear();
        me.addAll(order);

        me.resumeEvents();
        me.fireEvent(&#39;sort&#39;, me);
    },

    <a name="method-Ext.util.MixedCollection-sortByKey"></a>/**
     * Sorts this collection by &lt;b&gt;key&lt;/b&gt;s.
     * @param {String} direction (optional) &#39;ASC&#39; or &#39;DESC&#39;. Defaults to &#39;ASC&#39;.
     * @param {Function} fn (optional) Comparison function that defines the sort order.
     * Defaults to sorting by case insensitive string.
     */
    sortByKey : function(dir, fn){
        this._sort(&#39;key&#39;, dir, fn || function(a, b){
            var v1 = String(a).toUpperCase(), v2 = String(b).toUpperCase();
            return v1 &gt; v2 ? 1 : (v1 &lt; v2 ? -1 : 0);
        });
    }
});
ï¿¿</pre></pre></body></html>