<!DOCTYPE html><html><head><title>Sencha Documentation Project</title><link rel="stylesheet" href="../reset.css" type="text/css"><link rel="stylesheet" href="../prettify.css" type="text/css"><link rel="stylesheet" href="../prettify_sa.css" type="text/css"><script type="text/javascript" src="../prettify.js"></script></head><body onload="prettyPrint()"><pre class="prettyprint"><pre><a name="cls-Ext.data.Store"></a>/**
 * @author Ed Spencer
 * @class Ext.data.Store
 * @extends Ext.data.AbstractStore
 *
 * &lt;p&gt;The Store class encapsulates a client side cache of {@link Ext.data.Model Model} objects. Stores load
 * data via a {@link Ext.data.Proxy Proxy}, and also provide functions for {@link #sort sorting},
 * {@link #filter filtering} and querying the {@link Ext.data.Model model} instances contained within it.&lt;/p&gt;
 *
 * &lt;p&gt;Creating a Store is easy - we just tell it the Model and the Proxy to use to load and save its data:&lt;/p&gt;
 *
<br><span style="display: none">**/</span>// Set up a {@link Ext.data.Model model} to use in our Store
Ext.regModel(&#39;User&#39;, {
    fields: [
        {name: &#39;firstName&#39;, type: &#39;string&#39;},
        {name: &#39;lastName&#39;,  type: &#39;string&#39;},
        {name: &#39;age&#39;,       type: &#39;int&#39;},
        {name: &#39;eyeColor&#39;,  type: &#39;string&#39;}
    ]
});

var myStore = new Ext.data.Store({
    model: &#39;User&#39;,
    proxy: {
        type: &#39;ajax&#39;,
        url : &#39;/users.json&#39;,
        reader: {
            type: &#39;json&#39;,
            root: &#39;users&#39;
        }
    },
    autoLoad: true
});
<br><span style="display: none">/**</span>
 * &lt;p&gt;In the example above we configured an AJAX proxy to load data from the url &#39;/users.json&#39;. We told our Proxy
 * to use a {@link Ext.data.JsonReader JsonReader} to parse the response from the server into Model object -
 * {@link Ext.data.JsonReader see the docs on JsonReader} for details.&lt;/p&gt;
 * 
 * &lt;p&gt;&lt;u&gt;Inline data&lt;/u&gt;&lt;/p&gt;
 * 
 * &lt;p&gt;Stores can also load data inline. Internally, Store converts each of the objects we pass in as {@link #data}
 * into Model instances:&lt;/p&gt;
 * 
<br><span style="display: none">**/</span>new Ext.data.Store({
    model: &#39;User&#39;,
    data : [
        {firstName: &#39;Ed&#39;,    lastName: &#39;Spencer&#39;},
        {firstName: &#39;Tommy&#39;, lastName: &#39;Maintz&#39;},
        {firstName: &#39;Aaron&#39;, lastName: &#39;Conran&#39;},
        {firstName: &#39;Jamie&#39;, lastName: &#39;Avins&#39;}
    ]
});
<br><span style="display: none">/**</span> *
 * &lt;p&gt;Loading inline data using the method above is great if the data is in the correct format already (e.g. it doesn&#39;t need 
 * to be processed by a {@link Ext.data.Reader reader}). If your inline data requires processing to decode the data structure,
 * use a {@link Ext.data.MemoryProxy MemoryProxy} instead (see the {@link Ext.data.MemoryProxy MemoryProxy} docs for an example).&lt;/p&gt;
 * 
 * &lt;p&gt;Additional data can also be loaded locally using {@link #add}.&lt;/p&gt;
 * 
 * &lt;p&gt;&lt;u&gt;Loading Nested Data&lt;/u&gt;&lt;/p&gt;
 * 
 * &lt;p&gt;Applications often need to load sets of associated data - for example a CRM system might load a User and her Orders. 
 * Instead of issuing an AJAX request for the User and a series of additional AJAX requests for each Order, we can load a nested dataset
 * and allow the Reader to automatically populate the associated models. Below is a brief example, see the {@link Ext.data.Reader} intro
 * docs for a full explanation:&lt;/p&gt;
 * 
<br><span style="display: none">**/</span>var store = new Ext.data.Store({
    autoLoad: true,
    model: &quot;User&quot;,
    proxy: {
        type: &#39;ajax&#39;,
        url : &#39;users.json&#39;,
        reader: {
            type: &#39;json&#39;,
            root: &#39;users&#39;
        }
    }
});
<br><span style="display: none">/**</span> * 
 * &lt;p&gt;Which would consume a response like this:&lt;/p&gt;
 * 
<br><span style="display: none">**/</span>{
    &quot;users&quot;: [
        {
            &quot;id&quot;: 1,
            &quot;name&quot;: &quot;Ed&quot;,
            &quot;orders&quot;: [
                {
                    &quot;id&quot;: 10,
                    &quot;total&quot;: 10.76,
                    &quot;status&quot;: &quot;invoiced&quot;
                },
                {
                    &quot;id&quot;: 11,
                    &quot;total&quot;: 13.45,
                    &quot;status&quot;: &quot;shipped&quot;
                }
            ]
        }
    ]
}
<br><span style="display: none">/**</span> * 
 * &lt;p&gt;See the {@link Ext.data.Reader} intro docs for a full explanation.&lt;/p&gt;
 * 
 * &lt;p&gt;&lt;u&gt;Filtering and Sorting&lt;/u&gt;&lt;/p&gt;
 * 
 * &lt;p&gt;Stores can be sorted and filtered - in both cases either remotely or locally. The {@link #sorters} and {@link #filters} are 
 * held inside {@link Ext.util.MixedCollection MixedCollection} instances to make them easy to manage. Usually it is sufficient to
 * either just specify sorters and filters in the Store configuration or call {@link #sort} or {@link #filter}:
 * 
<br><span style="display: none">**/</span>var store = new Ext.data.Store({
    model: &#39;User&#39;,
    sorters: [
        {
            property : &#39;age&#39;,
            direction: &#39;DESC&#39;
        },
        {
            property : &#39;firstName&#39;,
            direction: &#39;ASC&#39;
        }
    ],

    filters: [
        {
            property: &#39;firstName&#39;,
            value   : /Ed/
        }
    ]
});
<br><span style="display: none">/**</span> * 
 * &lt;p&gt;The new Store will keep the configured sorters and filters in the MixedCollection instances mentioned above. By default, sorting
 * and filtering are both performed locally by the Store - see {@link #remoteSort} and {@link #remoteFilter} to allow the server to 
 * perform these operations instead.&lt;/p&gt;
 * 
 * &lt;p&gt;Filtering and sorting after the Store has been instantiated is also easy. Calling {@link #filter} adds another filter to the Store
 * and automatically filters the dataset (calling {@link #filter} with no arguments simply re-applies all existing filters). Note that by
 * default {@link #sortOnFilter} is set to true, which means that your sorters are automatically reapplied if using local sorting.&lt;/p&gt;
 * 
<br><span style="display: none">**/</span>store.filter(&#39;eyeColor&#39;, &#39;Brown&#39;);
<br><span style="display: none">/**</span> * 
 * &lt;p&gt;Change the sorting at any time by calling {@link #sort}:&lt;/p&gt;
 * 
<br><span style="display: none">**/</span>store.sort(&#39;height&#39;, &#39;ASC&#39;);
<br><span style="display: none">/**</span> * 
 * &lt;p&gt;Note that all existing sorters will be removed in favor of the new sorter data (if {@link #sort} is called with no arguments, 
 * the existing sorters are just reapplied instead of being removed). To keep existing sorters and add new ones, just add them
 * to the MixedCollection:&lt;/p&gt;
 * 
<br><span style="display: none">**/</span>store.sorters.add(new Ext.util.Sorter({
    property : &#39;shoeSize&#39;,
    direction: &#39;ASC&#39;
}));

store.sort();
<br><span style="display: none">/**</span> * 
 * &lt;p&gt;&lt;u&gt;Registering with StoreMgr&lt;/u&gt;&lt;/p&gt;
 * 
 * &lt;p&gt;Any Store that is instantiated with a {@link #storeId} will automatically be registed with the {@link Ext.data.StoreMgr StoreMgr}.
 * This makes it easy to reuse the same store in multiple views:&lt;/p&gt;
 * 
 <br><span style="display: none">**/</span>//this store can be used several times
new Ext.data.Store({
    model: &#39;User&#39;,
    storeId: &#39;usersStore&#39;
});

new Ext.List({
    store: &#39;usersStore&#39;,

    //other config goes here
});

new Ext.DataView({
    store: &#39;usersStore&#39;,

    //other config goes here
});
<br><span style="display: none">/**</span> * 
 * &lt;p&gt;&lt;u&gt;Further Reading&lt;/u&gt;&lt;/p&gt;
 * 
 * &lt;p&gt;Stores are backed up by an ecosystem of classes that enables their operation. To gain a full understanding of these
 * pieces and how they fit together, see:&lt;/p&gt;
 * 
 * &lt;ul style=&quot;list-style-type: disc; padding-left: 25px&quot;&gt;
 * &lt;li&gt;{@link Ext.data.Proxy Proxy} - overview of what Proxies are and how they are used&lt;/li&gt;
 * &lt;li&gt;{@link Ext.data.Model Model} - the core class in the data package&lt;/li&gt;
 * &lt;li&gt;{@link Ext.data.Reader Reader} - used by any subclass of {@link Ext.data.ServerProxy ServerProxy} to read a response&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * @constructor
 * @param {Object} config Optional config object
 */
Ext.define(&#39;Ext.data.Store&#39;, {
    extend: &#39;Ext.data.AbstractStore&#39;,
    
    alias: &#39;store.store&#39;,

    requires: [&#39;Ext.ModelMgr&#39;, &#39;Ext.data.Model&#39;],
    uses: [&#39;Ext.data.MemoryProxy&#39;],

    <a name="cfg-Ext.data.Store-remoteSort"></a>/**
     * @cfg {Boolean} remoteSort
     * True to defer any sorting operation to the server. If false, sorting is done locally on the client. Defaults to &lt;tt&gt;false&lt;/tt&gt;.
     */
    remoteSort: false,

    <a name="cfg-Ext.data.Store-remoteFilter"></a>/**
     * @cfg {Boolean} remoteFilter
     * True to defer any filtering operation to the server. If false, filtering is done locally on the client. Defaults to &lt;tt&gt;false&lt;/tt&gt;.
     */
    remoteFilter: false,

    <a name="cfg-Ext.data.Store-proxy"></a>/**
     * @cfg {String/Ext.data.Proxy/Object} proxy The Proxy to use for this Store. This can be either a string, a config
     * object or a Proxy instance - see {@link #setProxy} for details.
     */

    <a name="cfg-Ext.data.Store-data"></a>/**
     * @cfg {Array} data Optional array of Model instances or data objects to load locally. See &quot;Inline data&quot; above for details.
     */

    <a name="cfg-Ext.data.Store-model"></a>/**
     * @cfg {String} model The {@link Ext.data.Model} associated with this store
     */

    <a name="prop-Ext.data.Store-groupField"></a>/**
     * The (optional) field by which to group data in the store. Internally, grouping is very similar to sorting - the
     * groupField and {@link #groupDir} are injected as the first sorter (see {@link #sort}). Stores support a single
     * level of grouping, and groups can be fetched via the {@link #getGroups} method.
     * @property groupField
     * @type String
     */
    groupField: undefined,

    <a name="prop-Ext.data.Store-groupDir"></a>/**
     * The direction in which sorting should be applied when grouping. Defaults to &quot;ASC&quot; - the other supported value is &quot;DESC&quot;
     * @property groupDir
     * @type String
     */
    groupDir: &quot;ASC&quot;,

    <a name="prop-Ext.data.Store-pageSize"></a>/**
     * The number of records considered to form a &#39;page&#39;. This is used to power the built-in
     * paging using the nextPage and previousPage functions. Defaults to 25.
     * @property pageSize
     * @type Number
     */
    pageSize: 25,

    <a name="prop-Ext.data.Store-currentPage"></a>/**
     * The page that the Store has most recently loaded (see {@link #loadPage})
     * @property currentPage
     * @type Number
     */
    currentPage: 1,

    <a name="cfg-Ext.data.Store-clearOnPageLoad"></a>/**
     * @cfg {Boolean} clearOnPageLoad True to empty the store when loading another page via {@link #loadPage}, 
     * {@link #nextPage} or {@link #previousPage} (defaults to true). Setting to false keeps existing records, allowing
     * large data sets to be loaded one page at a time but rendered all together.
     */
    clearOnPageLoad: true,

    /**
     * True if a model was created implicitly for this Store. This happens if a fields array is passed to the Store&#39;s constructor
     * instead of a model constructor or name.
     * @property implicitModel
     * @type Boolean
     * @private
     */
    implicitModel: false,

    /**
     * True if the Store is currently loading via its Proxy
     * @property loading
     * @type Boolean
     * @private
     */
    loading: false,

    <a name="cfg-Ext.data.Store-sortOnFilter"></a>/**
     * @cfg {Boolean} sortOnFilter For local filtering only, causes {@link #sort} to be called whenever {@link #filter} is called,
     * causing the sorters to be reapplied after filtering. Defaults to true
     */
    sortOnFilter: true,

    isStore: true,

    //documented above
    constructor: function(config) {
        config = config || {};

        var me = this,
            proxy,
            data;

        <a name="prop-Ext.data.Store-data"></a>/**
         * The MixedCollection that holds this store&#39;s local cache of records
         * @property data
         * @type Ext.util.MixedCollection
         */
        me.data = new Ext.util.MixedCollection(false,
        function(record) {
            return record.internalId;
        });

        if (config.data) {
            me.inlineData = config.data;
            delete config.data;
        }

        Ext.data.Store.superclass.constructor.call(me, config);

        proxy = me.proxy;
        data = me.inlineData;

        if (data) {
            if (proxy instanceof Ext.data.MemoryProxy) {
                proxy.data = data;
                me.read();
            } else {
                me.add.apply(me, data);
            }

            me.sort();
            delete me.inlineData;
        } else if (me.autoLoad) {
            // debugger;
            Ext.defer(me.load, 10, me, [typeof me.autoLoad === &#39;object&#39; ? me.autoLoad: undefined]);
            // Remove the defer call, we may need reinstate this at some point, but currently it&#39;s not obvious why it&#39;s here.
            // this.load(typeof this.autoLoad == &#39;object&#39; ? this.autoLoad : undefined);
        }
    },

    <a name="method-Ext.data.Store-getGroups"></a>/**
     * Returns an object containing the result of applying grouping to the records in this store. See {@link #groupField},
     * {@link #groupDir} and {@link #getGroupString}. Example for a store containing records with a color field:
<br><span style="display: none">**/</span>var myStore = new Ext.data.Store({
    groupField: &#39;color&#39;,
    groupDir  : &#39;DESC&#39;
});

myStore.getGroups(); //returns:
[
    {
        name: &#39;yellow&#39;,
        children: [
            //all records where the color field is &#39;yellow&#39;
        ]
    },
    {
        name: &#39;red&#39;,
        children: [
            //all records where the color field is &#39;red&#39;
        ]
    }
]
<br><span style="display: none">/**</span>     * @return {Array} The grouped data
     */
    getGroups: function() {
        var records = this.data.items,
            length = records.length,
            groups = [],
            pointers = {},
            record,
            groupStr,
            group,
            i;

        for (i = 0; i &lt; length; i++) {
            record = records[i];
            groupStr = this.getGroupString(record);
            group = pointers[groupStr];

            if (group === undefined) {
                group = {
                    name: groupStr,
                    children: []
                };

                groups.push(group);
                pointers[groupStr] = group;
            }

            group.children.push(record);
        }

        return groups;
    },

    /**
     * @private
     * For a given set of records and a Grouper, returns an array of arrays - each of which is the set of records
     * matching a certain group.
     */
    getGroupsForGrouper: function(records, grouper) {
        var length = records.length,
            groups = [],
            oldValue,
            newValue,
            record,
            group,
            i;

        for (i = 0; i &lt; length; i++) {
            record = records[i];
            newValue = grouper.getGroupString(record);

            if (newValue !== oldValue) {
                group = {
                    name: newValue,
                    grouper: grouper,
                    records: []
                };
                groups.push(group);
            }

            group.records.push(record);

            oldValue = newValue;
        }

        return groups;
    },

    /**
     * @private
     * This is used recursively to gather the records into the configured Groupers. The data MUST have been sorted for
     * this to work properly (see {@link #getGroupData} and {@link #getGroupsForGrouper}) Most of the work is done by
     * {@link #getGroupsForGrouper} - this function largely just handles the recursion.
     * @param {Array} records The set or subset of records to group
     * @param {Number} grouperIndex The grouper index to retrieve
     * @return {Array} The grouped records
     */
    getGroupsForGrouperIndex: function(records, grouperIndex) {
        var me = this,
            groupers = me.groupers,
            grouper = groupers.getAt(grouperIndex),
            groups = me.getGroupsForGrouper(records, grouper),
            length = groups.length,
            i;

        if (grouperIndex + 1 &lt; groupers.length) {
            for (i = 0; i &lt; length; i++) {
                groups[i].children = me.getGroupsForGrouperIndex(groups[i].records, grouperIndex + 1);
            }
        }

        for (i = 0; i &lt; length; i++) {
            groups[i].depth = grouperIndex;
        }

        return groups;
    },

    /**
     * @private
     * &lt;p&gt;Returns records grouped by the configured {@link #groupers grouper} configuration. Sample return value (in
     * this case grouping by genre and then author in a fictional books dataset):&lt;/p&gt;
<br><span style="display: none">**/</span>[
    {
        name: &#39;Fantasy&#39;,
        depth: 0,
        records: [
            //book1, book2, book3, book4
        ],
        children: [
            {
                name: &#39;Rowling&#39;,
                depth: 1,
                records: [
                    //book1, book2
                ]
            },
            {
                name: &#39;Tolkein&#39;,
                depth: 1,
                records: [
                    //book3, book4
                ]
            }
        ]
    }
]
<br><span style="display: none">/**</span>     * @param {Boolean} sort True to call {@link #sort} before finding groups. Sorting is required to make grouping 
     * function correctly so this should only be set to false if the Store is known to already be sorted correctly
     * (defaults to true)
     * @return {Array} The group data
     */
    getGroupData: function(sort) {
        var me = this;
        if (sort !== false) {
            me.sort();
        }

        return me.getGroupsForGrouperIndex(me.data.items, 0);
    },

    <a name="method-Ext.data.Store-getGroupString"></a>/**
     * &lt;p&gt;Returns the string to group on for a given model instance. The default implementation of this method returns 
     * the model&#39;s {@link #groupField}, but this can be overridden to group by an arbitrary string. For example, to 
     * group by the first letter of a model&#39;s &#39;name&#39; field, use the following code:&lt;/p&gt;
<br><span style="display: none">**/</span>new Ext.data.Store({
    groupDir: &#39;ASC&#39;,
    getGroupString: function(instance) {
        return instance.get(&#39;name&#39;)[0];
    }
});
<br><span style="display: none">/**</span>     * @param {Ext.data.Model} instance The model instance
     * @return {String} The string to compare when forming groups
     */
    getGroupString: function(instance) {
        return instance.get(this.groupField);
    },
    <a name="method-Ext.data.Store-insert"></a>/**
     * Inserts Model instances into the Store at the given index and fires the {@link #add} event.
     * See also &lt;code&gt;{@link #add}&lt;/code&gt;.
     * @param {Number} index The start index at which to insert the passed Records.
     * @param {Ext.data.Model[]} records An Array of Ext.data.Model objects to add to the cache.
     */
    insert: function(index, records) {
        var me = this,
            i,
            record,
            len;

        records = [].concat(records);
        for (i = 0, len = records.length; i &lt; len; i++) {
            record = me.createModel(records[i]);
            record.set(me.modelDefaults);

            me.data.insert(index + i, record);
            record.join(me);
            
            if (me.autoSync &amp;&amp; record.phantom === true) {
                me.sync();
            }
        }

        if (me.snapshot) {
            me.snapshot.addAll(records);
        }

        me.fireEvent(&#39;add&#39;, me, records, index);
        me.fireEvent(&#39;datachanged&#39;, me);
    },

    <a name="method-Ext.data.Store-add"></a>/**
     * Adds Model instances to the Store by instantiating them based on a JavaScript object. When adding already-
     * instantiated Models, use {@link #insert} instead. The instances will be added at the end of the existing collection.
     * This method accepts either a single argument array of Model instances or any number of model instance arguments.
     * Sample usage:
     * 
<br><span style="display: none">**/</span>myStore.add({some: &#39;data&#39;}, {some: &#39;other data&#39;});
<br><span style="display: none">/**</span>     * 
     * @param {Object} data The data for each model
     * @return {Array} The array of newly created model instances
     */
    add: function(records) {
        //accept both a single-argument array of records, or any number of record arguments
        if (!Ext.isArray(records)) {
            records = Array.prototype.slice.apply(arguments);
        }

        var me = this,
            i = 0,
            length = records.length,
            record;

        for (; i &lt; length; i++) {
            record = me.createModel(records[i]);
            records[i] = record;
        }

        me.insert(me.data.length, records);

        return records;
    },

    /**
     * Converts a literal to a model, if it&#39;s not a model already 
     * @private
     * @param record {Ext.data.Model/Object} The record to create
     * @return {Ext.data.Model}
     */
    createModel: function(record) {
        if (!record.isModel) {
            record = Ext.ModelMgr.create(record, this.model);
        }

        return record;
    },

    <a name="method-Ext.data.Store-each"></a>/**
     * Calls the specified function for each of the {@link Ext.data.Model Records} in the cache.
     * @param {Function} fn The function to call. The {@link Ext.data.Model Record} is passed as the first parameter.
     * Returning &lt;tt&gt;false&lt;/tt&gt; aborts and exits the iteration.
     * @param {Object} scope (optional) The scope (&lt;code&gt;this&lt;/code&gt; reference) in which the function is executed.
     * Defaults to the current {@link Ext.data.Model Record} in the iteration.
     */
    each: function(fn, scope) {
        this.data.each(fn, scope);
    },

    <a name="method-Ext.data.Store-remove"></a>/**
     * Removes the given record from the Store, firing the &#39;remove&#39; event for each instance that is removed, plus a single
     * &#39;datachanged&#39; event after removal.
     * @param {Ext.data.Model/Array} records The Ext.data.Model instance or array of instances to remove
     */
    remove: function(records) {
        if (!Ext.isArray(records)) {
            records = [records];
        }

        var me = this,
            i = 0,
            length = records.length,
            index,
            record;

        for (; i &lt; length; i++) {
            record = records[i];
            index = me.data.indexOf(record);

            if (index &gt; -1) {
                me.removed.push(record);
                record.lastIndex = index;

                if (me.snapshot) {
                    me.snapshot.remove(record);
                }

                record.unjoin(me);
                me.data.remove(record);
                
                if (me.autoSync &amp;&amp; record.phantom !== true) {
                    me.sync();
                }

                me.fireEvent(&#39;remove&#39;, me, record, index);
            }
        }

        me.fireEvent(&#39;datachanged&#39;, me);
    },

    <a name="method-Ext.data.Store-removeAt"></a>/**
     * Removes the model instance at the given index
     * @param {Number} index The record index
     */
    removeAt: function(index) {
        var record = this.getAt(index);

        if (record) {
            this.remove(record);
        }
    },

    <a name="method-Ext.data.Store-load"></a>/**
     * &lt;p&gt;Loads data into the Store via the configured {@link #proxy}. This uses the Proxy to make an
     * asynchronous call to whatever storage backend the Proxy uses, automatically adding the retrieved
     * instances into the Store and calling an optional callback if required. Example usage:&lt;/p&gt;
     * 
<br><span style="display: none">**/</span>store.load({
    scope   : this,
    callback: function(records, operation, success) {
        //the {@link Ext.data.Operation operation} object contains all of the details of the load operation
        console.log(records);
    }
});
<br><span style="display: none">/**</span>     * 
     * &lt;p&gt;If the callback scope does not need to be set, a function can simply be passed:&lt;/p&gt;
     * 
<br><span style="display: none">**/</span>store.load(function(records, operation, success) {
    console.log(&#39;loaded records&#39;);
});
<br><span style="display: none">/**</span>     * 
     * @param {Object/Function} options Optional config object, passed into the Ext.data.Operation object before loading.
     */
    load: function(options) {
        var me = this;
            options = options || {};

        if (Ext.isFunction(options)) {
            options = {
                callback: options
            };
        }

        Ext.applyIf(options, {
            group: {
                field: me.groupField,
                direction: me.groupDir
            },
            page: me.currentPage,
            start: (me.currentPage - 1) * me.pageSize,
            limit: me.pageSize,
            addRecords: false
        });

        return Ext.data.Store.superclass.load.call(me, options);
    },

    <a name="method-Ext.data.Store-isLoading"></a>/**
     * Returns true if the Store is currently performing a load operation
     * @return {Boolean} True if the Store is currently loading
     */
    isLoading: function() {
        return this.loading;
    },

    /**
     * @private
     * Called internally when a Proxy has completed a load request
     */
    onProxyLoad: function(operation) {
        var me = this,
            resultSet = operation.getResultSet(),
            records = operation.getRecords(),
            successful = operation.wasSuccessful();

        if (resultSet) {
            me.totalCount = resultSet.total;
        }

        if (successful) {
            me.loadRecords(records, operation);
        }

        me.loading = false;
        me.fireEvent(&#39;load&#39;, me, records, successful);

        //TODO: deprecate this event, it should always have been &#39;load&#39; instead. &#39;load&#39; is now documented, &#39;read&#39; is not.
        //People are definitely using this so can&#39;t deprecate safely until 2.x
        me.fireEvent(&#39;read&#39;, me, records, operation.wasSuccessful());

        //this is a callback that would have been passed to the &#39;read&#39; function and is optional
        Ext.callback(operation.callback, operation.scope || me, [records, operation, successful]);
    },

    /**
     * @private
     * Callback for any write Operation over the Proxy. Updates the Store&#39;s MixedCollection to reflect
     * the updates provided by the Proxy
     */
    onProxyWrite: function(operation) {
        var me = this,
            success = operation.wasSuccessful(),
            records = operation.getRecords();

        switch (operation.action) {
            case &#39;create&#39;:
                me.onCreateRecords(records, operation, success);
                break;
            case &#39;update&#39;:
                me.onUpdateRecords(records, operation, success);
                break;
            case &#39;destroy&#39;:
                me.onDestroyRecords(records, operation, success);
                break;
        }
        
        if (success) {
            me.fireEvent(&#39;write&#39;, me, operation);
            me.fireEvent(&#39;datachanged&#39;, me);
        }
        //this is a callback that would have been passed to the &#39;create&#39;, &#39;update&#39; or &#39;destroy&#39; function and is optional
        Ext.callback(operation.callback, operation.scope || me, [records, operation, success]);
    },
    
    /**
     * Create any new records when a write is returned from the server.
     * @private
     * @param {Array} records The array of new records
     * @param {Ext.data.Operation} operation The operation that just completed
     * @param {Boolean} success True if the operation was successful
     */
    onCreateRecords: function(records, operation, success) {
        if (success) {
            var i = 0,
                data = this.data,
                length = records.length,
                originalRecords = operation.records,
                record,
                original,
                index;
                
            <a name="prop-Ext.data.Store-for"></a>/**
             * Loop over each record returned from the server. Assume they are
             * returned in order of how they were sent. If we find a matching
             * record, replace it with the newly created one.
             */
            for (; i &lt; length; ++i) {
                record = records[i];
                original = originalRecords[i];
                if (original) {
                    data.replace(original.internalId, record);
                    // index = this.data.indexOf(original);
                    // data.removeAt(index);
                    // data.insert(index, record);
                    record.phantom = false;
                    record.join(this);
                }
            }
        }
    },
    
    /**
     * Update any records when a write is returned from the server.
     * @private
     * @param {Array} records The array of updated records
     * @param {Ext.data.Operation} operation The operation that just completed
     * @param {Boolean} success True if the operation was successful
     */
    onUpdateRecords: function(records, operation, success){
        if (success) {
            var i = 0,
                length = records.length,
                record;
            
            for (; i &lt; length; ++i) {
                record = records[i];
                this.data.replace(record);
                record.join(this);
            }
        }
    },
    
    /**
     * Remove any records when a write is returned from the server.
     * @private
     * @param {Array} records The array of removed records
     * @param {Ext.data.Operation} operation The operation that just completed
     * @param {Boolean} success True if the operation was successful
     */
    onDestroyRecords: function(records, operation, success){
        if (success) {
            var i = 0,
                length = records.length,
                record;
                
            for (; i &lt; length; ++i) {
                record = records[i];
                record.unjoin(this);
                this.data.remove(record);
            }
            this.removed = [];
        }
    },

    //inherit docs
    getNewRecords: function() {
        return this.data.filterBy(this.filterNew).items;
    },

    //inherit docs
    getUpdatedRecords: function() {
        return this.data.filterBy(this.filterUpdated).items;
    },

    <a name="method-Ext.data.Store-filter"></a>/**
     * Filters the loaded set of records by a given set of filters.
     * @param {Mixed} filters The set of filters to apply to the data. These are stored internally on the store,
     * but the filtering itself is done on the Store&#39;s {@link Ext.util.MixedCollection MixedCollection}. See
     * MixedCollection&#39;s {@link Ext.util.MixedCollection#filter filter} method for filter syntax. Alternatively,
     * pass in a property string
     * @param {String} value Optional value to filter by (only if using a property string as the first argument)
     */
    filter: function(filters, value) {
        if (Ext.isString(filters)) {
            filters = {
                property: filters,
                value: value
            };
        }

        var me = this,
            decoded = me.decodeFilters(filters),
            i = 0,
            doLocalSort = me.sortOnFilter &amp;&amp; !me.remoteSort,
            length = decoded.length;

        for (; i &lt; length; i++) {
            me.filters.replace(decoded[i]);
        }

        if (me.remoteFilter) {
            //the load function will pick up the new filters and request the filtered data from the proxy
            me.load();
        } else {
            <a name="prop-Ext.data.Store-snapshot"></a>/**
             * A pristine (unfiltered) collection of the records in this store. This is used to reinstate
             * records when a filter is removed or changed
             * @property snapshot
             * @type Ext.util.MixedCollection
             */
            me.snapshot = me.snapshot || me.data.clone();

            me.data = me.data.filter(me.filters.items);

            if (doLocalSort) {
                me.sort();
            }
            // fire datachanged event if it hasn&#39;t already been fired by doSort
            if (!doLocalSort || me.sorters.length &lt; 1) {
                me.fireEvent(&#39;datachanged&#39;, me);
            }
        }
    },

    <a name="method-Ext.data.Store-clearFilter"></a>/**
     * Revert to a view of the Record cache with no filtering applied.
     * @param {Boolean} suppressEvent If &lt;tt&gt;true&lt;/tt&gt; the filter is cleared silently without firing the
     * {@link #datachanged} event.
     */
    clearFilter: function(suppressEvent) {
        var me = this;

        me.filters.clear();

        if (me.remoteFilter) {
            me.load();
        } else if (me.isFiltered()) {
            me.data = me.snapshot.clone();
            delete me.snapshot;

            if (suppressEvent !== true) {
                me.fireEvent(&#39;datachanged&#39;, me);
            }
        }
    },

    <a name="method-Ext.data.Store-isFiltered"></a>/**
     * Returns true if this store is currently filtered
     * @return {Boolean}
     */
    isFiltered: function() {
        var snapshot = this.snapshot;
        return !! snapshot &amp;&amp; snapshot !== this.data;
    },

    <a name="method-Ext.data.Store-filterBy"></a>/**
     * Filter by a function. The specified function will be called for each
     * Record in this Store. If the function returns &lt;tt&gt;true&lt;/tt&gt; the Record is included,
     * otherwise it is filtered out.
     * @param {Function} fn The function to be called. It will be passed the following parameters:&lt;ul&gt;
     * &lt;li&gt;&lt;b&gt;record&lt;/b&gt; : Ext.data.Model&lt;p class=&quot;sub-desc&quot;&gt;The {@link Ext.data.Model record}
     * to test for filtering. Access field values using {@link Ext.data.Model#get}.&lt;/p&gt;&lt;/li&gt;
     * &lt;li&gt;&lt;b&gt;id&lt;/b&gt; : Object&lt;p class=&quot;sub-desc&quot;&gt;The ID of the Record passed.&lt;/p&gt;&lt;/li&gt;
     * &lt;/ul&gt;
     * @param {Object} scope (optional) The scope (&lt;code&gt;this&lt;/code&gt; reference) in which the function is executed. Defaults to this Store.
     */
    filterBy: function(fn, scope) {
        var me = this;

        me.snapshot = me.snapshot || me.data.clone();
        me.data = me.queryBy(fn, scope || me);
        me.fireEvent(&#39;datachanged&#39;, me);
    },

    <a name="method-Ext.data.Store-queryBy"></a>/**
     * Query the cached records in this Store using a filtering function. The specified function
     * will be called with each record in this Store. If the function returns &lt;tt&gt;true&lt;/tt&gt; the record is
     * included in the results.
     * @param {Function} fn The function to be called. It will be passed the following parameters:&lt;ul&gt;
     * &lt;li&gt;&lt;b&gt;record&lt;/b&gt; : Ext.data.Model&lt;p class=&quot;sub-desc&quot;&gt;The {@link Ext.data.Model record}
     * to test for filtering. Access field values using {@link Ext.data.Model#get}.&lt;/p&gt;&lt;/li&gt;
     * &lt;li&gt;&lt;b&gt;id&lt;/b&gt; : Object&lt;p class=&quot;sub-desc&quot;&gt;The ID of the Record passed.&lt;/p&gt;&lt;/li&gt;
     * &lt;/ul&gt;
     * @param {Object} scope (optional) The scope (&lt;code&gt;this&lt;/code&gt; reference) in which the function is executed. Defaults to this Store.
     * @return {MixedCollection} Returns an Ext.util.MixedCollection of the matched records
     **/
    queryBy: function(fn, scope) {
        var me = this,
        data = me.snapshot || me.data;
        return data.filterBy(fn, scope || me);
    },

    <a name="method-Ext.data.Store-loadData"></a>/**
     * Loads an array of data straight into the Store
     * @param {Array} data Array of data to load. Any non-model instances will be cast into model instances first
     * @param {Boolean} append True to add the records to the existing records in the store, false to remove the old ones first
     */
    loadData: function(data, append) {
        var model = this.model,
            length = data.length,
            i,
            record;

        //make sure each data element is an Ext.data.Model instance
        for (i = 0; i &lt; length; i++) {
            record = data[i];

            if (! (record instanceof Ext.data.Model)) {
                data[i] = Ext.ModelMgr.create(record, model);
            }
        }

        this.loadRecords(data, {addRecords: append});
    },

    <a name="method-Ext.data.Store-loadRecords"></a>/**
     * Loads an array of {@Ext.data.Model model} instances into the store, fires the datachanged event. This should only usually
     * be called internally when loading from the {@link Ext.data.Proxy Proxy}, when adding records manually use {@link #add} instead
     * @param {Array} records The array of records to load
     * @param {Object} options {addRecords: true} to add these records to the existing records, false to remove the Store&#39;s existing records first
     */
    loadRecords: function(records, options) {
        var me     = this,
            i      = 0,
            length = records.length;
            
        options = options || {};
            
        
        if (!options.addRecords) {
            delete me.snapshot;
            me.data.clear();
        }
        
        me.data.addAll(records);

        //FIXME: this is not a good solution. Ed Spencer is totally responsible for this and should be forced to fix it immediately.
        for (; i &lt; length; i++) {
            if (options.start !== undefined) {
                records[i].index = options.start + i;
            
            }
            records[i].join(me);
        }

        /*
         * this rather inelegant suspension and resumption of events is required because both the filter and sort functions
         * fire an additional datachanged event, which is not wanted. Ideally we would do this a different way. The first
         * datachanged event is fired by the call to this.add, above.
         */
        me.suspendEvents();

        if (me.filterOnLoad &amp;&amp; !me.remoteFilter) {
            me.filter();
        }

        if (me.sortOnLoad &amp;&amp; !me.remoteSort) {
            me.sort();
        }

        me.resumeEvents();
        me.fireEvent(&#39;datachanged&#39;, me, records);
    },
    
    // PAGING METHODS
    <a name="method-Ext.data.Store-loadPage"></a>/**
     * Loads a given &#39;page&#39; of data by setting the start and limit values appropriately. Internally this just causes a normal
     * load operation, passing in calculated &#39;start&#39; and &#39;limit&#39; params
     * @param {Number} page The number of the page to load
     */
    loadPage: function(page) {
        var me = this;

        me.currentPage = page;

        me.read({
            page: page,
            start: (page - 1) * me.pageSize,
            limit: me.pageSize,
            addRecords: !me.clearOnPageLoad
        });
    },

    <a name="method-Ext.data.Store-nextPage"></a>/**
     * Loads the next &#39;page&#39; in the current data set
     */
    nextPage: function() {
        this.loadPage(this.currentPage + 1);
    },

    <a name="method-Ext.data.Store-previousPage"></a>/**
     * Loads the previous &#39;page&#39; in the current data set
     */
    previousPage: function() {
        this.loadPage(this.currentPage - 1);
    },

    // private
    clearData: function() {
        this.data.each(function(record) {
            record.unjoin();
        });

        this.data.clear();
    },

    <a name="method-Ext.data.Store-find"></a>/**
     * Finds the index of the first matching Record in this store by a specific field value.
     * @param {String} fieldName The name of the Record field to test.
     * @param {String/RegExp} value Either a string that the field value
     * should begin with, or a RegExp to test against the field.
     * @param {Number} startIndex (optional) The index to start searching at
     * @param {Boolean} anyMatch (optional) True to match any part of the string, not just the beginning
     * @param {Boolean} caseSensitive (optional) True for case sensitive comparison
     * @param {Boolean} exactMatch True to force exact match (^ and $ characters added to the regex). Defaults to false. 
     * @return {Number} The matched index or -1
     */
    find: function(property, value, start, anyMatch, caseSensitive, exactMatch) {
        var fn = this.createFilterFn(property, value, anyMatch, caseSensitive, exactMatch);
        return fn ? this.data.findIndexBy(fn, null, start) : -1;
    },

    <a name="method-Ext.data.Store-findRecord"></a>/**
     * Finds the first matching Record in this store by a specific field value.
     * @param {String} fieldName The name of the Record field to test.
     * @param {String/RegExp} value Either a string that the field value
     * should begin with, or a RegExp to test against the field.
     * @param {Number} startIndex (optional) The index to start searching at
     * @param {Boolean} anyMatch (optional) True to match any part of the string, not just the beginning
     * @param {Boolean} caseSensitive (optional) True for case sensitive comparison
     * @param {Boolean} exactMatch True to force exact match (^ and $ characters added to the regex). Defaults to false.
     * @return {Ext.data.Model} The matched record or null
     */
    findRecord: function() {
        var me = this,
            index = me.find.apply(me, arguments);
        return index !== -1 ? me.getAt(index) : null;
    },

    /**
     * @private
     * Returns a filter function used to test a the given property&#39;s value. Defers most of the work to
     * Ext.util.MixedCollection&#39;s createValueMatcher function
     * @param {String} property The property to create the filter function for
     * @param {String/RegExp} value The string/regex to compare the property value to
     * @param {Boolean} anyMatch True if we don&#39;t care if the filter value is not the full value (defaults to false)
     * @param {Boolean} caseSensitive True to create a case-sensitive regex (defaults to false)
     * @param {Boolean} exactMatch True to force exact match (^ and $ characters added to the regex). Defaults to false. 
     * Ignored if anyMatch is true.
     */
    createFilterFn: function(property, value, anyMatch, caseSensitive, exactMatch) {
        if (Ext.isEmpty(value)) {
            return false;
        }
        value = this.data.createValueMatcher(value, anyMatch, caseSensitive, exactMatch);
        return function(r) {
            return value.test(r.data[property]);
        };
    },

    <a name="method-Ext.data.Store-findExact"></a>/**
     * Finds the index of the first matching Record in this store by a specific field value.
     * @param {String} fieldName The name of the Record field to test.
     * @param {Mixed} value The value to match the field against.
     * @param {Number} startIndex (optional) The index to start searching at
     * @return {Number} The matched index or -1
     */
    findExact: function(property, value, start) {
        return this.data.findIndexBy(function(rec) {
            return rec.get(property) === value;
        },
        this, start);
    },

    <a name="method-Ext.data.Store-findBy"></a>/**
     * Find the index of the first matching Record in this Store by a function.
     * If the function returns &lt;tt&gt;true&lt;/tt&gt; it is considered a match.
     * @param {Function} fn The function to be called. It will be passed the following parameters:&lt;ul&gt;
     * &lt;li&gt;&lt;b&gt;record&lt;/b&gt; : Ext.data.Model&lt;p class=&quot;sub-desc&quot;&gt;The {@link Ext.data.Model record}
     * to test for filtering. Access field values using {@link Ext.data.Model#get}.&lt;/p&gt;&lt;/li&gt;
     * &lt;li&gt;&lt;b&gt;id&lt;/b&gt; : Object&lt;p class=&quot;sub-desc&quot;&gt;The ID of the Record passed.&lt;/p&gt;&lt;/li&gt;
     * &lt;/ul&gt;
     * @param {Object} scope (optional) The scope (&lt;code&gt;this&lt;/code&gt; reference) in which the function is executed. Defaults to this Store.
     * @param {Number} startIndex (optional) The index to start searching at
     * @return {Number} The matched index or -1
     */
    findBy: function(fn, scope, start) {
        return this.data.findIndexBy(fn, scope, start);
    },

    <a name="method-Ext.data.Store-collect"></a>/**
     * Collects unique values for a particular dataIndex from this store.
     * @param {String} dataIndex The property to collect
     * @param {Boolean} allowNull (optional) Pass true to allow null, undefined or empty string values
     * @param {Boolean} bypassFilter (optional) Pass true to collect from all records, even ones which are filtered
     * @return {Array} An array of the unique values
     **/
    collect: function(dataIndex, allowNull, bypassFilter) {
        var me = this,
            data = (bypassFilter === true &amp;&amp; me.snapshot) ? me.snapshot: me.data;

        return data.collect(dataIndex, &#39;data&#39;, allowNull);
    },

    <a name="method-Ext.data.Store-getCount"></a>/**
     * Gets the number of cached records.
     * &lt;p&gt;If using paging, this may not be the total size of the dataset. If the data object
     * used by the Reader contains the dataset size, then the {@link #getTotalCount} function returns
     * the dataset size.  &lt;b&gt;Note&lt;/b&gt;: see the Important note in {@link #load}.&lt;/p&gt;
     * @return {Number} The number of Records in the Store&#39;s cache.
     */
    getCount: function() {
        return this.data.length || 0;
    },

    <a name="method-Ext.data.Store-getTotalCount"></a>/**
     * Returns the total number of {@link Ext.data.Model Model} instances that the {@link Ext.data.Proxy Proxy} 
     * indicates exist. This will usually differ from {@link #getCount} when using paging - getCount returns the 
     * number of records loaded into the Store at the moment, getTotalCount returns the number of records that 
     * could be loaded into the Store if the Store contained all data
     * @return {Number} The total number of Model instances available via the Proxy
     */
    getTotalCount: function() {
        return this.totalCount;
    },

    <a name="method-Ext.data.Store-getAt"></a>/**
     * Get the Record at the specified index.
     * @param {Number} index The index of the Record to find.
     * @return {Ext.data.Model} The Record at the passed index. Returns undefined if not found.
     */
    getAt: function(index) {
        return this.data.getAt(index);
    },

    <a name="method-Ext.data.Store-getRange"></a>/**
     * Returns a range of Records between specified indices.
     * @param {Number} startIndex (optional) The starting index (defaults to 0)
     * @param {Number} endIndex (optional) The ending index (defaults to the last Record in the Store)
     * @return {Ext.data.Model[]} An array of Records
     */
    getRange: function(start, end) {
        return this.data.getRange(start, end);
    },

    <a name="method-Ext.data.Store-getById"></a>/**
     * Get the Record with the specified id.
     * @param {String} id The id of the Record to find.
     * @return {Ext.data.Model} The Record with the passed id. Returns undefined if not found.
     */
    getById: function(id) {
        return (this.snapshot || this.data).findBy(function(record) {
            return record.getId() === id;
        });
    },

    <a name="method-Ext.data.Store-indexOf"></a>/**
     * Get the index within the cache of the passed Record.
     * @param {Ext.data.Model} record The Ext.data.Model object to find.
     * @return {Number} The index of the passed Record. Returns -1 if not found.
     */
    indexOf: function(record) {
        return this.data.indexOf(record);
    },
    
    
    <a name="method-Ext.data.Store-indexOfTotal"></a>/**
     * Get the index within the entire dataset. From 0 to the totalCount.
     * @param {Ext.data.Model} record The Ext.data.Model object to find.
     * @return {Number} The index of the passed Record. Returns -1 if not found.
     */
    indexOfTotal: function(record) {
        return record.index || this.indexOf(record);
    },

    <a name="method-Ext.data.Store-indexOfId"></a>/**
     * Get the index within the cache of the Record with the passed id.
     * @param {String} id The id of the Record to find.
     * @return {Number} The index of the Record. Returns -1 if not found.
     */
    indexOfId: function(id) {
        return this.data.indexOfKey(id);
    },

    removeAll: function(silent) {
        var me = this,
            items = [];

        me.each(function(rec) {
            items.push(rec);
        });
        me.clearData();
        if (me.snapshot) {
            me.snapshot.clear();
        }
        //if(this.pruneModifiedRecords){
        //    this.modified = [];
        //}
        if (silent !== true) {
            me.fireEvent(&#39;clear&#39;, me, items);
        }
    },

    /*
     * Aggregation methods
     */

    <a name="method-Ext.data.Store-first"></a>/**
     * Convenience function for getting the first model instance in the store
     * @param {Boolean} grouped (Optional) True to perform the operation for each group
     * in the store. The value returned will be an object literal with the key being the group
     * name and the first record being the value. The grouped parameter is only honored if
     * the store has a groupField.
     * @return {Ext.data.Model/undefined} The first model instance in the store, or undefined
     */
    first: function(grouped) {
        var me = this;

        if (grouped &amp;&amp; me.groupField) {
            return me.aggregate(function(records) {
                return records.length ? records[0] : undefined;
            }, me, true);
        } else {
            return me.data.first();
        }
    },

    <a name="method-Ext.data.Store-last"></a>/**
     * Convenience function for getting the last model instance in the store
     * @param {Boolean} grouped (Optional) True to perform the operation for each group
     * in the store. The value returned will be an object literal with the key being the group
     * name and the last record being the value. The grouped parameter is only honored if
     * the store has a groupField.
     * @return {Ext.data.Model/undefined} The last model instance in the store, or undefined
     */
    last: function(grouped) {
        var me = this;

        if (grouped &amp;&amp; me.groupField) {
            return me.aggregate(function(records) {
                var len = records.length;
                return len ? records[len - 1] : undefined;
            }, me, true);
        } else {
            return me.data.last();
        }
    },

    <a name="method-Ext.data.Store-sum"></a>/**
     * Sums the value of &lt;tt&gt;property&lt;/tt&gt; for each {@link Ext.data.Model record} between &lt;tt&gt;start&lt;/tt&gt;
     * and &lt;tt&gt;end&lt;/tt&gt; and returns the result.
     * @param {String} field A field in each record
     * @param {Boolean} grouped (Optional) True to perform the operation for each group
     * in the store. The value returned will be an object literal with the key being the group
     * name and the sum for that group being the value. The grouped parameter is only honored if
     * the store has a groupField.
     * @return {Number} The sum
     */
    sum: function(field, grouped) {
        var me = this;

        if (grouped &amp;&amp; me.groupField) {
            return me.aggregate(me.getSum, me, true, [field]);
        } else {
            return me.getSum(me.data.items, field);
        }
    },
    
    // @private, see sum
    getSum: function(records, field) {
        var total = 0,
            i = 0,
            len = records.length;

        for (; i &lt; len; ++i) {
            total += records[i].get(field);
        }

        return total;
    },

    <a name="method-Ext.data.Store-count"></a>/**
     * Gets the count of items in the store.
     * @param {Boolean} grouped (Optional) True to perform the operation for each group
     * in the store. The value returned will be an object literal with the key being the group
     * name and the count for each group being the value. The grouped parameter is only honored if
     * the store has a groupField.
     * @return {Number} the count
     */
    count: function(grouped) {
        var me = this;

        if (grouped &amp;&amp; me.groupField) {
            return me.aggregate(function(records) {
                return records.length;
            }, me, true);
        } else {
            return me.getCount();
        }
    },

    <a name="method-Ext.data.Store-min"></a>/**
     * Gets the minimum value in the store.
     * @param {String} field The field in each record
     * @param {Boolean} grouped (Optional) True to perform the operation for each group
     * in the store. The value returned will be an object literal with the key being the group
     * name and the minimum in the group being the value. The grouped parameter is only honored if
     * the store has a groupField.
     * @return {Mixed/undefined} The minimum value, if no items exist, undefined.
     */
    min: function(field, grouped) {
        var me = this;

        if (grouped &amp;&amp; me.groupField) {
            return me.aggregate(me.getMin, me, true, [field]);
        } else {
            return me.getMin(me.data.items, field);
        }
    },
    
    // @private, see min
    getMin: function(records, field){
        var i = 1, 
            len = records.length, 
            value, min;
        
        if (len &gt; 0) {
            min = records[0].get(field);
        }
        
        for (; i &lt; len; ++i) {
            value = records[i].get(field);
            if (value &lt; min) {
                min = value;
            }
        }
        return min;
    },

    <a name="method-Ext.data.Store-max"></a>/**
     * Gets the maximum value in the store.
     * @param {String} field The field in each record
     * @param {Boolean} grouped (Optional) True to perform the operation for each group
     * in the store. The value returned will be an object literal with the key being the group
     * name and the maximum in the group being the value. The grouped parameter is only honored if
     * the store has a groupField.
     * @return {Mixed/undefined} The maximum value, if no items exist, undefined.
     */
    max: function(field, grouped) {
        var me = this;

        if (grouped &amp;&amp; me.groupField) {
            return me.aggregate(me.getMax, me, true, [field]);
        } else {
            return me.getMax(me.data.items, field);
        }
    },
    
    // @private, see max
    getMax: function(records, field) {
        var i = 1, 
            len = records.length, 
            value, 
            max;
        
        if (len &gt; 0) {
            max = records[0].get(field);
        }
        
        for (; i &lt; len; ++i) {
            value = records[i].get(field);
            if (value &gt; max) {
                max = value;
            }
        }
        return max;
    },

    <a name="method-Ext.data.Store-average"></a>/**
     * Gets the average value in the store.
     * @param {String} field The field in each record
     * @param {Boolean} grouped (Optional) True to perform the operation for each group
     * in the store. The value returned will be an object literal with the key being the group
     * name and the group average being the value. The grouped parameter is only honored if
     * the store has a groupField.
     * @return {Mixed/undefined} The average value, if no items exist, 0.
     */
    average: function(field, grouped) {
        var me = this;

        if (grouped &amp;&amp; me.groupField) {
            return me.aggregate(me.getAverage, me, true, [field]);
        } else {
            return me.getAverage(me.data.items, field);
        }
    },
    
    // @private, see average
    getAverage: function(records, field) {
        var i = 0,
            len = records.length,
            sum = 0;

        if (records.length &gt; 0) {
            for (; i &lt; len; ++i) {
                sum += records[i].get(field);
            }
            return sum / len;
        }
        return 0;
    },

    <a name="method-Ext.data.Store-aggregate"></a>/**
     * Runs the aggregate function for all the records in the store.
     * @param {Function} fn The function to execute. The function is called with a single parameter,
     * an array of records for that group.
     * @param {Object} scope (optional) The scope to execute the function in. Defaults to the store.
     * @param {Boolean} grouped (Optional) True to perform the operation for each group
     * in the store. The value returned will be an object literal with the key being the group
     * name and the group average being the value. The grouped parameter is only honored if
     * the store has a groupField.
     * @param {Array} args (optional) Any arguments to append to the function call
     * @return {Object} An object literal with the group names and their appropriate values.
     */
    aggregate: function(fn, scope, grouped, args) {
        args = args || [];
        if (grouped &amp;&amp; this.groupField) {
            var groups = this.getGroups(),
                i = 0,
                len = groups.length,
                out = {},
                group;
                
            for (; i &lt; len; ++i) {
                group = groups[i];
                out[group.name] = fn.apply(scope || this, [group.children].concat(args));
            }
            return out;
        } else {
            return fn.apply(scope || this, [this.data.items].concat(args));
        }
    }
});
￿</pre></pre></body></html>