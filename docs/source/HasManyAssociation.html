<!DOCTYPE html><html><head><title>Sencha Documentation Project</title><link rel="stylesheet" href="../reset.css" type="text/css"><link rel="stylesheet" href="../prettify.css" type="text/css"><link rel="stylesheet" href="../prettify_sa.css" type="text/css"><script type="text/javascript" src="../prettify.js"></script></head><body onload="prettyPrint()"><pre class="prettyprint"><pre><a name="cls-Ext.data.HasManyAssociation"></a>/**
 * @author Ed Spencer
 * @class Ext.data.HasManyAssociation
 * @extends Ext.data.Association
 * 
 * &lt;p&gt;Represents a one-to-many relationship between two models. Usually created indirectly via a model definition:&lt;/p&gt;
 * 
<br><span style="display: none">**/</span>Ext.regModel(&#39;Product&#39;, {
    fields: [
        {name: &#39;id&#39;,      type: &#39;int&#39;},
        {name: &#39;user_id&#39;, type: &#39;int&#39;},
        {name: &#39;name&#39;,    type: &#39;string&#39;}
    ]
});

Ext.regModel(&#39;User&#39;, {
    fields: [
        {name: &#39;id&#39;,   type: &#39;int&#39;},
        {name: &#39;name&#39;, type: &#39;string&#39;}
    ],
    
    hasMany: {model: &#39;Product&#39;, name: &#39;products&#39;}
});
&lt;/pre&gt;&lt;/code&gt;
* 
 * &lt;p&gt;Above we created Product and User models, and linked them by saying that a User hasMany Products. This gives
 * us a new function on every User instance, in this case the function is called &#39;products&#39; because that is the name
 * we specified in the association configuration above.&lt;/p&gt;
 * 
 * &lt;p&gt;This new function returns a specialized {@link Ext.data.Store Store} which is automatically filtered to load
 * only Products for the given model instance:&lt;/p&gt;
 * 
<br><span style="display: none">**/</span>//first, we load up a User with id of 1
var user = Ext.ModelMgr.create({id: 1, name: &#39;Ed&#39;}, &#39;User&#39;);

//the user.products function was created automatically by the association and returns a {@link Ext.data.Store Store}
//the created store is automatically scoped to the set of Products for the User with id of 1
var products = user.products();

//we still have all of the usual Store functions, for example it&#39;s easy to add a Product for this User
products.add({
    name: &#39;Another Product&#39;
});

//saves the changes to the store - this automatically sets the new Product&#39;s user_id to 1 before saving
products.sync();
<br><span style="display: none">/**</span> * 
 * &lt;p&gt;The new Store is only instantiated the first time you call products() to conserve memory and processing time,
 * though calling products() a second time returns the same store instance.&lt;/p&gt;
 * 
 * &lt;p&gt;&lt;u&gt;Custom filtering&lt;/u&gt;&lt;/p&gt;
 * 
 * &lt;p&gt;The Store is automatically furnished with a filter - by default this filter tells the store to only return
 * records where the associated model&#39;s foreign key matches the owner model&#39;s primary key. For example, if a User
 * with ID = 100 hasMany Products, the filter loads only Products with user_id == 100.&lt;/p&gt;
 * 
 * &lt;p&gt;Sometimes we want to filter by another field - for example in the case of a Twitter search application we may
 * have models for Search and Tweet:&lt;/p&gt;
 * 
<br><span style="display: none">**/</span>var Search = Ext.regModel(&#39;Search&#39;, {
    fields: [
        &#39;id&#39;, &#39;query&#39;
    ],

    hasMany: {
        model: &#39;Tweet&#39;,
        name : &#39;tweets&#39;,
        filterProperty: &#39;query&#39;
    }
});

Ext.regModel(&#39;Tweet&#39;, {
    fields: [
        &#39;id&#39;, &#39;text&#39;, &#39;from_user&#39;
    ]
});

//returns a Store filtered by the filterProperty
var store = new Search({query: &#39;Sencha Touch&#39;}).tweets();
<br><span style="display: none">/**</span> * 
 * &lt;p&gt;The tweets association above is filtered by the query property by setting the {@link #filterProperty}, and is
 * equivalent to this:&lt;/p&gt;
 * 
<br><span style="display: none">**/</span>var store = new Ext.data.Store({
    model: &#39;Tweet&#39;,
    filters: [
        {
            property: &#39;query&#39;,
            value   : &#39;Sencha Touch&#39;
        }
    ]
});
<br><span style="display: none">/**</span> */
Ext.define(&#39;Ext.data.HasManyAssociation&#39;, {
    extend: &#39;Ext.data.Association&#39;,
    requires: [&#39;Ext.util.Inflector&#39;],
    
    <a name="cfg-Ext.data.HasManyAssociation-foreignKey"></a>/**
     * @cfg {String} foreignKey The name of the foreign key on the associated model that links it to the owner
     * model. Defaults to the lowercased name of the owner model plus &quot;_id&quot;, e.g. an association with a where a
     * model called Group hasMany Users would create &#39;group_id&#39; as the foreign key.
     */
    
    <a name="cfg-Ext.data.HasManyAssociation-name"></a>/**
     * @cfg {String} name The name of the function to create on the owner model. Required
     */
    
    <a name="cfg-Ext.data.HasManyAssociation-storeConfig"></a>/**
     * @cfg {Object} storeConfig Optional configuration object that will be passed to the generated Store. Defaults to 
     * undefined.
     */
    
    <a name="cfg-Ext.data.HasManyAssociation-filterProperty"></a>/**
     * @cfg {String} filterProperty Optionally overrides the default filter that is set up on the associated Store. If
     * this is not set, a filter is automatically created which filters the association based on the configured 
     * {@link #foreignKey}. See intro docs for more details. Defaults to undefined
     */
    
    <a name="cfg-Ext.data.HasManyAssociation-autoLoad"></a>/**
     * @cfg {Boolean} autoLoad True to automatically load the related store from a remote source when instantiated.
     * Defaults to &lt;tt&gt;false&lt;/tt&gt;.
     */
    
    constructor: function(config) {
        var me = this,
            ownerProto,
            name;
            
        me.callParent(arguments);
        
        me.name = me.name || Ext.util.Inflector.pluralize(me.associatedName.toLowerCase());
        
        ownerProto = me.ownerModel.prototype;
        name = me.name;
        
        Ext.applyIf(me, {
            storeName : name + &quot;Store&quot;,
            foreignKey: me.ownerName.toLowerCase() + &quot;_id&quot;
        });
        
        ownerProto[name] = me.createStore();
    },
    
    /**
     * @private
     * Creates a function that returns an Ext.data.Store which is configured to load a set of data filtered
     * by the owner model&#39;s primary key - e.g. in a hasMany association where Group hasMany Users, this function
     * returns a Store configured to return the filtered set of a single Group&#39;s Users.
     * @return {Function} The store-generating function
     */
    createStore: function() {
        var that            = this,
            associatedModel = that.associatedModel,
            storeName       = that.storeName,
            foreignKey      = that.foreignKey,
            primaryKey      = that.primaryKey,
            filterProperty  = that.filterProperty,
            autoLoad        = that.autoLoad,
            storeConfig     = that.storeConfig || {};
        
        return function() {
            var me = this,
                config, filter,
                modelDefaults = {};
                
            if (me[storeName] === undefined) {
                if (filterProperty) {
                    filter = {
                        property  : filterProperty,
                        value     : me.get(filterProperty),
                        exactMatch: true
                    };
                } else {
                    filter = {
                        property  : foreignKey,
                        value     : me.get(primaryKey),
                        exactMatch: true
                    };
                }
                
                modelDefaults[foreignKey] = me.get(primaryKey);
                
                config = Ext.apply({}, storeConfig, {
                    model        : associatedModel,
                    filters      : [filter],
                    remoteFilter : false,
                    modelDefaults: modelDefaults
                });
                
                me[storeName] = Ext.create(&#39;Ext.data.Store&#39;, config);
                if (autoLoad) {
                    me[storeName].load();
                }
            }
            
            return me[storeName];
        };
    },
    
    /**
     * Read associated data
     * @private
     * @param {Ext.data.Model} record The record we&#39;re writing to
     * @param {Ext.data.Reader} reader The reader for the associated model
     * @param {Object} associationData The raw associated data
     */
    read: function(record, reader, associationData){
        var store = record[this.name](),
            inverse;
    
        store.add(reader.read(associationData).records);
    
        //now that we&#39;ve added the related records to the hasMany association, set the inverse belongsTo
        //association on each of them if it exists
        inverse = this.associatedModel.prototype.associations.findBy(function(assoc){
            return assoc.type === &#39;belongsTo&#39; &amp;&amp; assoc.associatedName === record.$className;
        });
    
        //if the inverse association was found, set it now on each record we&#39;ve just created
        if (inverse) {
            store.data.each(function(associatedRecord){
                associatedRecord[inverse.instanceName] = record;
            });
        }
    }
});ï¿¿</pre></pre></body></html>